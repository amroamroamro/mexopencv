<!DOCTYPE html>
<html>
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   
      <!--This HTML was auto-generated from published MATLAB code.-->
      <title>BRIEF (Binary Robust Independent Elementary Features)</title>
      <meta name="generator" content="MATLAB 9.2">
      <link rel="schema.DC" href="http://purl.org/dc/elements/1.1/">
      <meta name="DC.date" content="2017-11-27">
      <meta name="DC.source" content="descriptor_extractor_brief_demo.m">
      <link rel="stylesheet" type="text/css" href="publish_custom.css">
   </head>
   <body>
      <div class="content">
         <h1 id="1">BRIEF (Binary Robust Independent Elementary Features)</h1>
         <!--introduction-->
         <p>In this demo, we will see the basics of BRIEF algorithm.</p>
         <p>Sources:</p>
         <div>
            <ul>
               <li><a href="https://docs.opencv.org/3.2.0/dc/d7d/tutorial_py_brief.html">https://docs.opencv.org/3.2.0/dc/d7d/tutorial_py_brief.html</a></li>
            </ul>
         </div>
         <!--/introduction-->
         <h2 id="toc">Contents</h2>
         <div>
            <ul>
               <li><a href="#2">Theory</a></li>
               <li><a href="#3">BRIEF in OpenCV</a></li>
               <li><a href="#8">Additional Resources</a></li>
            </ul>
         </div>
         <h2 id="2">Theory</h2>
         <p>We know SIFT uses 128-dim vector for descriptors. Since it is using floating point numbers, it takes basically 512 bytes.
            Similarly SURF also takes minimum of 256 bytes (for 64-dim). Creating such a vector for thousands of features takes a lot
            of memory which are not feasible for resouce-constraint applications especially for embedded systems. Larger the memory, longer
            the time it takes for matching.
         </p>
         <p>But all these dimensions may not be needed for actual matching. We can compress it using several methods like PCA, LDA etc.
            Even other methods like hashing using LSH (Locality Sensitive Hashing) is used to convert these SIFT descriptors in floating-point
            numbers to binary strings. These binary strings are used to match features using Hamming distance. This provides better speed-up
            because finding hamming distance is just applying XOR and bit count, which are very fast in modern CPUs with SSE instructions.
            But here, we need to find the descriptors first, then only we can apply hashing, which doesn't solve our initial problem on
            memory.
         </p>
         <p>BRIEF comes into picture at this moment. It provides a shortcut to find the binary strings directly without finding descriptors.
            It takes smoothened image patch and selects a set of <img src="descriptor_extractor_brief_demo_eq02599506990898489944.png" alt="$n_d$" class="equation" width="15" height="9"> (x,y) location pairs in an unique way (explained in paper). Then some pixel intensity comparisons are done on these location
            pairs. For example, let first location pairs be <img src="descriptor_extractor_brief_demo_eq09941021013676836398.png" alt="$p$" class="equation" width="8" height="10"> and <img src="descriptor_extractor_brief_demo_eq15226540192103580117.png" alt="$q$" class="equation" width="7" height="10">. If <img src="descriptor_extractor_brief_demo_eq10686262423334378464.png" alt="$I(p) < I(q)$" class="equation" width="71" height="15">, then its result is 1, else it is 0. This is applied for all the <img src="descriptor_extractor_brief_demo_eq02599506990898489944.png" alt="$n_d$" class="equation" width="15" height="9"> location pairs to get a <img src="descriptor_extractor_brief_demo_eq02599506990898489944.png" alt="$n_d$" class="equation" width="15" height="9">-dimensional bit string.
         </p>
         <p>This <img src="descriptor_extractor_brief_demo_eq02599506990898489944.png" alt="$n_d$" class="equation" width="15" height="9"> can be 128, 256 or 512. OpenCV supports all of these, but by default, it would be 256 (OpenCV represents it in bytes. So
            the values will be 16, 32 and 64). So once you get this, you can use Hamming Distance to match these descriptors.
         </p>
         <p>One important point is that BRIEF is a feature descriptor, it doesn't provide any method to find the features. So you will
            have to use any other feature detectors like SIFT, SURF etc. The paper recommends to use CenSurE which is a fast detector
            and BRIEF works even slightly better for CenSurE points than for SURF points.
         </p>
         <p>In short, BRIEF is a faster method feature descriptor calculation and matching. It also provides high recognition rate unless
            there is large in-plane rotation.
         </p>
         <h2 id="3">BRIEF in OpenCV</h2>
         <p>Below code shows the computation of BRIEF descriptors with the help of CenSurE detector. (CenSurE detector is called STAR
            detector in OpenCV).
         </p>
         <p>Note that you need opencv_contrib to use this.</p>
         <p>load source image</p><pre class="codeinput">img = cv.imread(fullfile(mexopencv.root(),<span class="string">'test'</span>,<span class="string">'butterfly.jpg'</span>), <span class="keyword">...</span>
    <span class="string">'Grayscale'</span>,true);</pre><p>detect keypoints using STAR detector</p><pre class="codeinput">star = cv.StarDetector();
keypoints = star.detect(img);
whos <span class="string">keypoints</span></pre><pre class="codeoutput">  Name           Size              Bytes  Class     Attributes

  keypoints      1x429            312696  struct              

</pre><p>compute the descriptors with BRIEF</p><pre class="codeinput">brief = cv.BriefDescriptorExtractor();
descriptors = brief.compute(img, keypoints);
whos <span class="string">descriptors</span></pre><pre class="codeoutput">  Name               Size            Bytes  Class    Attributes

  descriptors      429x32            13728  uint8              

</pre><p>The function <tt>descriptorSize</tt> gives the <img src="descriptor_extractor_brief_demo_eq02599506990898489944.png" alt="$n_d$" class="equation" width="15" height="9"> size used in bytes. By default it is 32.
         </p><pre class="codeinput">disp(brief.descriptorSize())</pre><pre class="codeoutput">    32
</pre><h2 id="8">Additional Resources</h2>
         <div>
            <ul>
               <li>Michael Calonder, Vincent Lepetit, Christoph Strecha, and Pascal Fua,   "BRIEF: Binary Robust Independent Elementary Features",
                  11th European   Conference on Computer Vision (ECCV), Heraklion, Crete. LNCS Springer,   September 2010.
               </li>
               <li><a href="https://en.wikipedia.org/wiki/Locality-sensitive_hashing">LSH (Locality Sensitive Hashing)</a>.
               </li>
            </ul>
         </div>
         <div class="footer">
            <p><a href="https://www.mathworks.com/products/matlab.html">Published with MATLAB&reg; R2017a</a></p>
         </div>
      </div><script type="text/x-mathjax-config">
  // https://stackoverflow.com/a/14631703/97160
  MathJax.Extension.myImg2jax = {
    version: "1.0",
    PreProcess: function (element) {
      var images = element.getElementsByTagName("img");
      for (var i = images.length - 1; i >= 0; i--) {
        var img = images[i];
        if (img.className === "equation") {
          var match = img.alt.match(/^(\$\$?)([\s\S]*)\1$/m);
          if (!match) continue;
          var script = document.createElement("script");
          script.type = "math/tex";
          if (match[1] === "$$") {script.type += ";mode=display"}
          MathJax.HTML.setScript(script, match[2]);
          img.parentNode.replaceChild(script, img);
        }
      }
    }
  };
  MathJax.Hub.Register.PreProcessor(["PreProcess", MathJax.Extension.myImg2jax]);
  </script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-AMS_CHTML"></script>
      <!--
##### SOURCE BEGIN #####
%% BRIEF (Binary Robust Independent Elementary Features)
%
% In this demo, we will see the basics of BRIEF algorithm.
%
% Sources:
%
% * <https://docs.opencv.org/3.2.0/dc/d7d/tutorial_py_brief.html>
%

%% Theory
%
% We know SIFT uses 128-dim vector for descriptors. Since it is using floating
% point numbers, it takes basically 512 bytes. Similarly SURF also takes
% minimum of 256 bytes (for 64-dim). Creating such a vector for thousands of
% features takes a lot of memory which are not feasible for resouce-constraint
% applications especially for embedded systems. Larger the memory, longer the
% time it takes for matching.
%
% But all these dimensions may not be needed for actual matching. We can
% compress it using several methods like PCA, LDA etc. Even other methods like
% hashing using LSH (Locality Sensitive Hashing) is used to convert these SIFT
% descriptors in floating-point numbers to binary strings. These binary
% strings are used to match features using Hamming distance. This provides
% better speed-up because finding hamming distance is just applying XOR and
% bit count, which are very fast in modern CPUs with SSE instructions. But
% here, we need to find the descriptors first, then only we can apply hashing,
% which doesn't solve our initial problem on memory.
%
% BRIEF comes into picture at this moment. It provides a shortcut to find the
% binary strings directly without finding descriptors. It takes smoothened
% image patch and selects a set of $n_d$ (x,y) location pairs in an unique way
% (explained in paper). Then some pixel intensity comparisons are done on
% these location pairs. For example, let first location pairs be $p$ and $q$.
% If $I(p) < I(q)$, then its result is 1, else it is 0. This is applied for
% all the $n_d$ location pairs to get a $n_d$-dimensional bit string.
%
% This $n_d$ can be 128, 256 or 512. OpenCV supports all of these, but by
% default, it would be 256 (OpenCV represents it in bytes. So the values will
% be 16, 32 and 64). So once you get this, you can use Hamming Distance to
% match these descriptors.
%
% One important point is that BRIEF is a feature descriptor, it doesn't
% provide any method to find the features. So you will have to use any other
% feature detectors like SIFT, SURF etc. The paper recommends to use CenSurE
% which is a fast detector and BRIEF works even slightly better for CenSurE
% points than for SURF points.
%
% In short, BRIEF is a faster method feature descriptor calculation and
% matching. It also provides high recognition rate unless there is large
% in-plane rotation.
%

%% BRIEF in OpenCV
%
% Below code shows the computation of BRIEF descriptors with the help of
% CenSurE detector. (CenSurE detector is called STAR detector in OpenCV).
%
% Note that you need opencv_contrib to use this.
%

%%
% load source image
img = cv.imread(fullfile(mexopencv.root(),'test','butterfly.jpg'), ...
    'Grayscale',true);

%%
% detect keypoints using STAR detector
star = cv.StarDetector();
keypoints = star.detect(img);
whos keypoints

%%
% compute the descriptors with BRIEF
brief = cv.BriefDescriptorExtractor();
descriptors = brief.compute(img, keypoints);
whos descriptors

%%
% The function |descriptorSize| gives the $n_d$ size used in bytes.
% By default it is 32.
disp(brief.descriptorSize())

%% Additional Resources
%
% * Michael Calonder, Vincent Lepetit, Christoph Strecha, and Pascal Fua,
%   "BRIEF: Binary Robust Independent Elementary Features", 11th European
%   Conference on Computer Vision (ECCV), Heraklion, Crete. LNCS Springer,
%   September 2010.
% * <https://en.wikipedia.org/wiki/Locality-sensitive_hashing LSH (Locality Sensitive Hashing)>.
%

##### SOURCE END #####
--></body>
</html>