<!DOCTYPE html>
<html>
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   
      <!--This HTML was auto-generated from published MATLAB code.-->
      <title>retina_hdr_tonemapping_demo_gui</title>
      <meta name="generator" content="MATLAB 9.2">
      <link rel="schema.DC" href="http://purl.org/dc/elements/1.1/">
      <meta name="DC.date" content="2017-11-27">
      <meta name="DC.source" content="retina_hdr_tonemapping_demo_gui.m">
      <link rel="stylesheet" type="text/css" href="publish_custom.css">
   </head>
   <body>
      <div class="content">
         <h2 id="toc">Contents</h2>
         <div>
            <ul>
               <li><a href="#1">OpenEXR images HDR Retina tone mapping demo</a></li>
               <li><a href="#3">Event handlers</a></li>
            </ul>
         </div>
         <h2 id="1">OpenEXR images HDR Retina tone mapping demo</h2>
         <p>High Dynamic Range retina tone mapping with the help of the Gipsa/Listic's retina.</p>
         <p>Retina demonstration for High Dynamic Range compression (tone-mapping): demonstrates the use of wrapper class of the Gipsa/Listic
            Labs retina model.
         </p>
         <p>This retina model allows spatio-temporal image processing (applied on a still image).</p>
         <p>This demo focuses demonstration of the dynamic compression capabilities of the model. The main application is tone mapping
            of HDR images (i.e. see on a 8bit display a more than 8bits coded (up to 16bits) image with details in high and low luminance
            ranges.
         </p>
         <p>The retina model still have the following properties:</p>
         <div>
            <ul>
               <li>It applies a spectral whithening (mid-frequency details enhancement)</li>
               <li>high frequency spatio-temporal noise reduction</li>
               <li>low frequency luminance to be reduced (luminance range compression)</li>
               <li>local logarithmic luminance compression allows details to be enhanced in   low light conditions</li>
            </ul>
         </div>
         <p>Sources:</p>
         <div>
            <ul>
               <li><a href="https://github.com/opencv/opencv_contrib/blob/3.2.0/modules/bioinspired/samples/cpp/OpenEXRimages_HDR_Retina_toneMapping.cpp">https://github.com/opencv/opencv_contrib/blob/3.2.0/modules/bioinspired/samples/cpp/OpenEXRimages_HDR_Retina_toneMapping.cpp</a></li>
               <li><a href="https://github.com/opencv/opencv_contrib/blob/3.2.0/modules/bioinspired/samples/cpp/OpenEXRimages_HDR_Retina_toneMapping_video.cpp">https://github.com/opencv/opencv_contrib/blob/3.2.0/modules/bioinspired/samples/cpp/OpenEXRimages_HDR_Retina_toneMapping_video.cpp</a></li>
            </ul>
         </div><pre class="codeinput"><span class="keyword">function</span> varargout = retina_hdr_tonemapping_demo_gui(fname)</pre><pre class="codeinput">    <span class="comment">% load HDR image</span>
    <span class="keyword">if</span> nargin &lt; 1
        <span class="comment">% http://www.pauldebevec.com/Research/HDR/memorial.hdr</span>
        <span class="comment">% http://www.pauldebevec.com/Research/HDR/memorial.exr</span>
        fname = fullfile(mexopencv.root(),<span class="string">'test'</span>,<span class="string">'memorial.hdr'</span>);
    <span class="keyword">end</span>
    [imgs, isz] = loadInputImage(fname);
    showInputImage(imgs);

    <span class="comment">% create retina object</span>
    opts = defaultOptions();
    retina = createRetina(fliplr(isz), opts);

    <span class="comment">% create the UI, hook event handlers, and trigger timer</span>
    h = buildGUI(imgs, isz, opts);
    props = {<span class="string">'Interruptible'</span>,<span class="string">'off'</span>, <span class="string">'BusyAction'</span>,<span class="string">'cancel'</span>};
    set(h.fig, <span class="string">'WindowKeyPressFcn'</span>,@onType, props{:});
    set(h.slid(1), <span class="string">'Callback'</span>,@onChangeClipping, props{:});
    set(h.slid(2), <span class="string">'Callback'</span>,@onChangeSaturation, props{:});
    set(h.slid(3:5), <span class="string">'Callback'</span>,@onChangeParams, props{:});
    set(h.t, <span class="string">'TimerFcn'</span>,@onTimer, <span class="string">'BusyMode'</span>,<span class="string">'drop'</span>);
    start(h.t);

    <span class="keyword">if</span> nargout &gt; 0, varargout{1} = h; <span class="keyword">end</span>
    <span class="keyword">if</span> nargout &gt; 1, varargout{2} = retina; <span class="keyword">end</span></pre><pre class="codeoutput">=&gt; image size (w,h) = 484,714
Input image rescaling with histogram edges cutting
(in order to eliminate bad pixels in HDR image creation):
=&gt; Histogram limits
	0% index = 0
		normalized hist value = 0.354646
		input gray level = 0
	100% index = 256
		normalized hist value = 0.999998
		input gray level = 255
Current Retina instance setup :
OPLandIPLparvo{
	 colorMode : 1
	 normalizeParvoOutput :1
	 photoreceptorsLocalAdaptationSensitivity : 0.985
	 photoreceptorsTemporalConstant : 0.5
	 photoreceptorsSpatialConstant : 0.43
	 horizontalCellsGain : 40
	 hcellsTemporalConstant : 1
	 hcellsSpatialConstant : 7
	 parvoGanglionCellsSensitivity : 0.95}
Current Retina instance setup :
IPLmagno{
	 normaliseOutput : 1
	 parasolCells_beta : 0
	 parasolCells_tau : 0
	 parasolCells_k : 7
	 amacrinCellsTemporalCutFrequency : 2
	 V0CompressionParameter : 0.95
	 localAdaptintegration_tau : 0
	 localAdaptintegration_k : 7}
</pre><img src="retina_hdr_tonemapping_demo_gui_01.png"><img src="retina_hdr_tonemapping_demo_gui_02.png"><h2 id="3">Event handlers</h2><pre class="codeinput">    <span class="keyword">function</span> onType(~, e)
        <span class="comment">%ONTYPE  Event handler for key press on figure</span>

        <span class="comment">% handle keys</span>
        <span class="keyword">switch</span> e.Key
            <span class="keyword">case</span> <span class="string">'h'</span>
                helpdlg({
                    <span class="string">'Hot keys:'</span>
                    <span class="string">'h - this help dialog'</span>
                    <span class="string">'q - quit the program'</span>
                    <span class="string">'c - clear all retina buffers (open your eyes)'</span>
                });

            <span class="keyword">case</span> {<span class="string">'q'</span>, <span class="string">'escape'</span>}
                stop(h.t);
                delete(h.t);
                close(h.fig);

            <span class="keyword">case</span> <span class="string">'v'</span>
                <span class="comment">% toggle verbose mode</span>
                verbose(~verbose());

            <span class="keyword">case</span> <span class="string">'c'</span>
                <span class="comment">% clear retina buffers</span>
                <span class="keyword">if</span> ~opts.fastMethod
                    retina.clearBuffers();
                <span class="keyword">end</span>

            <span class="keyword">case</span> <span class="string">'f'</span>
                <span class="comment">% switch between retina and fast retina tone mapper</span>
                opts.fastMethod = ~opts.fastMethod;
                retina = createRetina(fliplr(isz), opts);
                <span class="comment">% update plot title</span>
                str = {<span class="string">'Retina tonemapping output'</span>, <span class="string">'Parvocellular pathway'</span>};
                <span class="keyword">if</span> opts.fastMethod
                    str{2} = <span class="string">'fast tone mapping'</span>;
                <span class="keyword">end</span>
                title(h.ax(2), str, <span class="string">'FontSize'</span>,10, <span class="string">'Interpreter'</span>,<span class="string">'none'</span>);

            <span class="keyword">case</span> <span class="string">'l'</span>
                <span class="comment">% toggle retina log sampling</span>
                opts.useLogSampling = ~opts.useLogSampling;
                retina = createRetina(fliplr(isz), opts);

            <span class="keyword">case</span> <span class="string">'r'</span>
                <span class="comment">% reset default options</span>
                opts = defaultOptions();
                retina = createRetina(fliplr(isz), opts);
                <span class="comment">% update UI</span>
                set(h.slid(1), <span class="string">'Value'</span>,opts.histogramClippingValue);
                set(h.slid(2), <span class="string">'Value'</span>,opts.colorSaturationFactor);
                set(h.slid(3), <span class="string">'Value'</span>,opts.retinaHcellsGain);
                set(h.slid(4), <span class="string">'Value'</span>,opts.localAdaptation_photoreceptors);
                set(h.slid(5), <span class="string">'Value'</span>,opts.localAdaptation_Gcells);
                onChangeClipping([],[]);
                onChangeSaturation([],[]);
                onChangeParams([],[]);
                drawnow;

            <span class="keyword">case</span> {<span class="string">'s'</span>, <span class="string">'space'</span>}
                <span class="comment">% start/stop the timer</span>
                <span class="keyword">if</span> strcmp(h.t.Running, <span class="string">'on'</span>)
                    stop(h.t);
                <span class="keyword">else</span>
                    start(h.t);
                <span class="keyword">end</span>
        <span class="keyword">end</span>
    <span class="keyword">end</span>

    <span class="keyword">function</span> onChangeClipping(~, ~)
        <span class="comment">%ONCHANGECLIPPING  Event handler for UI controls</span>

        <span class="comment">% retrieve current values from UI controls</span>
        opts.histogramClippingValue = round(get(h.slid(1), <span class="string">'Value'</span>));
        set(h.txt(1), <span class="string">'String'</span>,sprintf(<span class="string">'hist edges clip limit: %2d'</span>, <span class="keyword">...</span>
            opts.histogramClippingValue));

        <span class="comment">% apply new parameters</span>
        [imgs.rescaled, imgs.histo] = rescaleGrayLevelMat(imgs.src, <span class="keyword">...</span>
            opts.histogramClippingValue/100);

        <span class="comment">% manually run one step if timer if off</span>
        <span class="keyword">if</span> strcmp(h.t.Running, <span class="string">'off'</span>), onTimer([], []); <span class="keyword">end</span>
    <span class="keyword">end</span>

    <span class="keyword">function</span> onChangeSaturation(~, ~)
        <span class="comment">%ONCHANGESATURATION  Event handler for UI controls</span>

        <span class="comment">% retrieve current values from UI controls</span>
        opts.colorSaturationFactor = round(get(h.slid(2), <span class="string">'Value'</span>));
        set(h.txt(2), <span class="string">'String'</span>,sprintf(<span class="string">'Color saturation: %1d'</span>, <span class="keyword">...</span>
            opts.colorSaturationFactor));

        <span class="comment">% apply new parameters</span>
        <span class="keyword">if</span> ~opts.fastMethod
            retina.setColorSaturation(<span class="string">'SaturateColors'</span>,true, <span class="keyword">...</span>
                <span class="string">'ColorSaturationValue'</span>,opts.colorSaturationFactor);

            <span class="comment">% manually run one step if timer if off</span>
            <span class="keyword">if</span> strcmp(h.t.Running, <span class="string">'off'</span>), onTimer([], []); <span class="keyword">end</span>
        <span class="keyword">end</span>
    <span class="keyword">end</span>

    <span class="keyword">function</span> onChangeParams(~, ~)
        <span class="comment">%ONCHANGEPARAMS  Event handler for UI controls</span>

        <span class="comment">% retrieve current values from UI controls</span>
        opts.retinaHcellsGain = round(get(h.slid(3), <span class="string">'Value'</span>));
        opts.localAdaptation_photoreceptors = round(get(h.slid(4), <span class="string">'Value'</span>));
        opts.localAdaptation_Gcells = round(get(h.slid(5), <span class="string">'Value'</span>));
        set(h.txt(3), <span class="string">'String'</span>,sprintf(<span class="string">'Hcells gain: %3d'</span>, <span class="keyword">...</span>
            opts.retinaHcellsGain));
        set(h.txt(4), <span class="string">'String'</span>,sprintf(<span class="string">'Ph sensitivity: %3d'</span>, <span class="keyword">...</span>
            opts.localAdaptation_photoreceptors));
        set(h.txt(5), <span class="string">'String'</span>,sprintf(<span class="string">'Gcells sensitivity: %3d'</span>, <span class="keyword">...</span>
            opts.localAdaptation_Gcells));

        <span class="comment">% apply new parameters</span>
        <span class="keyword">if</span> ~opts.fastMethod
            retina.setupOPLandIPLParvoChannel(<span class="keyword">...</span>
                <span class="string">'PhotoreceptorsLocalAdaptationSensitivity'</span>,<span class="keyword">...</span>
                    opts.localAdaptation_photoreceptors/200, <span class="keyword">...</span>
                <span class="string">'PhotoreceptorsSpatialConstant'</span>,0.43, <span class="keyword">...</span>
                <span class="string">'HorizontalCellsGain'</span>,opts.retinaHcellsGain, <span class="keyword">...</span>
                <span class="string">'GanglionCellsSensitivity'</span>,opts.localAdaptation_Gcells/200);

            <span class="comment">% manually run one step if timer if off</span>
            <span class="keyword">if</span> strcmp(h.t.Running, <span class="string">'off'</span>), onTimer([], []); <span class="keyword">end</span>
        <span class="keyword">end</span>
    <span class="keyword">end</span>

    <span class="keyword">function</span> onTimer(~, ~)
        <span class="comment">%ONTIMER  Timer callback function</span>

        <span class="comment">% stop timer if figure was closed</span>
        <span class="keyword">if</span> ~ishghandle(h.fig)
            stop(h.t);
            delete(h.t);
            <span class="keyword">return</span>;
        <span class="keyword">end</span>

        <span class="comment">% run retina filter</span>
        <span class="keyword">if</span> opts.fastMethod
            <span class="comment">% apply the simplified hdr tone mapping method</span>
            imgs.dst = retina.applyFastToneMapping(imgs.rescaled);
        <span class="keyword">else</span>
            <span class="comment">% run and retrieve retina output</span>
            retina.run(imgs.rescaled);
            imgs.dst = retina.getParvo();
        <span class="keyword">end</span>

        <span class="comment">% display retina HDR input and LDR output, and clipped histogram</span>
        set(h.img(1), <span class="string">'CData'</span>,imgs.rescaled./255);
        set(h.img(2), <span class="string">'CData'</span>,imgs.dst);
        set(h.img(3), <span class="string">'CData'</span>,imgs.histo);
        drawnow;
    <span class="keyword">end</span></pre><pre class="codeinput"><span class="keyword">end</span>

<span class="keyword">function</span> b = verbose(varargin)
    <span class="comment">%VERBOSE  Get/set verbosity</span>

    <span class="keyword">persistent</span> verbose
    <span class="keyword">if</span> isempty(verbose), verbose = true; <span class="keyword">end</span>

    <span class="keyword">if</span> nargin &gt; 0
        verbose = logical(varargin{1});
    <span class="keyword">end</span>
    b = verbose;
<span class="keyword">end</span>

<span class="keyword">function</span> [imgs, isz] = loadInputImage(fname)
    <span class="comment">%LOADIMAGE  Load HDR image</span>

    <span class="comment">% load retina input image</span>
    img = cv.imread(fname, <span class="string">'Unchanged'</span>,true);
    assert(~isempty(img), <span class="string">'could not load image'</span>);
    isz = [size(img,1) size(img,2)];
    <span class="keyword">if</span> verbose()
        fprintf(<span class="string">'=&gt; image size (w,h) = %d,%d\n'</span>, isz(2), isz(1));
    <span class="keyword">end</span>

    <span class="comment">% rescale between 0 and 1, still floating-point</span>
    img = cv.normalize(img, <span class="string">'Alpha'</span>,0, <span class="string">'Beta'</span>,1, <span class="string">'NormType'</span>,<span class="string">'MinMax'</span>);
    img = min(max(img, 0), 1);  <span class="comment">% avoid tiny negative values</span>

    <span class="comment">% output structure of images:</span>
    <span class="comment">%   src      -&gt; single, [0,1]   = input image</span>
    <span class="comment">%   gamma    -&gt; single, [0,1]   = gamme transformed image</span>
    <span class="comment">%   rescaled -&gt; single, [0,255] = input image rescaled</span>
    <span class="comment">%   dst      -&gt; uint8,  [0,255] = retina output image</span>
    <span class="comment">%   histo    -&gt; uint8,  [0,255] = histogram image</span>
    imgs = struct();
    imgs.src = img;
    imgs.gamma = img .^ (1/5);  <span class="comment">% apply gamma curve</span>
    [imgs.rescaled, imgs.histo] = rescaleGrayLevelMat(img, 0);
    imgs.dst = zeros(size(img), <span class="string">'uint8'</span>);
<span class="keyword">end</span>

<span class="keyword">function</span> showInputImage(imgs)
    <span class="comment">%SHOWINPUTIMAGES  Show input HDR images</span>

    <span class="comment">% overlay titles</span>
    props = {<span class="string">'FontScale'</span>,0.5, <span class="string">'Color'</span>,[0 255 0]};
    srcImg = cv.putText(imgs.src, <span class="keyword">...</span>
        <span class="string">'EXR original (linear rescaling)'</span>, [10 20], props{:});
    gammaImg = cv.putText(imgs.gamma, <span class="keyword">...</span>
        <span class="string">'EXR w/ basic processing (gamma correction)'</span>, [10 20], props{:});

    <span class="comment">% show image montage</span>
    im = cat(2, srcImg, gammaImg);
    fig = figure(<span class="string">'Name'</span>,<span class="string">'HDR'</span>, <span class="string">'NumberTitle'</span>,<span class="string">'off'</span>, <span class="string">'Menubar'</span>,<span class="string">'none'</span>, <span class="keyword">...</span>
        <span class="string">'Position'</span>,[200 200 size(im,2) size(im,1)]);
    <span class="keyword">if</span> ~mexopencv.isOctave()
        movegui(fig, <span class="string">'center'</span>);
    <span class="keyword">end</span>
    ax = axes(<span class="string">'Parent'</span>,fig, <span class="string">'Units'</span>,<span class="string">'normalized'</span>, <span class="string">'Position'</span>,[0 0 1 1]);
    <span class="keyword">if</span> ~mexopencv.isOctave()
        imshow(im, <span class="string">'Parent'</span>,ax);
    <span class="keyword">else</span>
        <span class="comment">%HACK: https://savannah.gnu.org/bugs/index.php?45473</span>
        axes(ax); imshow(im);
    <span class="keyword">end</span>
<span class="keyword">end</span>

<span class="keyword">function</span> opts = defaultOptions()
    <span class="comment">%DEFAULTOPTIONS  Create default options structure</span>

    opts = struct();
    opts.useLogSampling = false;               <span class="comment">% retina log sampling processing</span>
    opts.fastMethod = false;                   <span class="comment">% fast method (no spectral whitening)</span>
    opts.histogramClippingValue = 0;           <span class="comment">% histogram edges clipping limit</span>
    opts.colorSaturationFactor = 3;            <span class="comment">% Color saturation</span>
    opts.retinaHcellsGain = 40;                <span class="comment">% Hcells gain</span>
    opts.localAdaptation_photoreceptors = 197; <span class="comment">% Ph sensitivity</span>
    opts.localAdaptation_Gcells = 190;         <span class="comment">% Gcells sensitivity</span>
<span class="keyword">end</span>

<span class="keyword">function</span> retina = createRetina(isz, opts)
    <span class="comment">%CREATERETINA  Create retina instance</span>

    <span class="keyword">if</span> opts.useLogSampling
        <span class="comment">% activate log sampling</span>
        <span class="comment">% (favour foveal vision and subsamples peripheral vision)</span>
        props = {<span class="string">'UseRetinaLogSampling'</span>,true, <span class="string">'ReductionFactor'</span>,2.0};
    <span class="keyword">else</span>
        <span class="comment">% allocate "classical" retina</span>
        props = {};
    <span class="keyword">end</span>

    <span class="keyword">if</span> opts.fastMethod
        <span class="comment">%TODO: untested</span>
        <span class="comment">% create a fast retina tone mapper (Meylan et al. algorithm)</span>
        retina = cv.RetinaFastToneMapping(isz);
        retina.setup(<span class="string">'PhotoreceptorsNeighborhoodRadius'</span>,3, <span class="keyword">...</span>
            <span class="string">'GanglioncellsNeighborhoodRadius'</span>,1.5, <span class="keyword">...</span>
            <span class="string">'MeanLuminanceModulatorK'</span>,1);
    <span class="keyword">else</span>
        <span class="comment">% create a retina instance with default parameters setup</span>
        retina = cv.Retina(isz, props{:});

        <span class="comment">% desactivate Magnocellular pathway processing</span>
        <span class="comment">% (motion information extraction) since it is not useful here</span>
        retina.activateMovingContoursProcessing(false);

        <span class="comment">% set retina params</span>
        retina.setColorSaturation(<span class="string">'SaturateColors'</span>,true, <span class="keyword">...</span>
            <span class="string">'ColorSaturationValue'</span>,opts.colorSaturationFactor);
        retina.setupOPLandIPLParvoChannel(<span class="keyword">...</span>
            <span class="string">'PhotoreceptorsLocalAdaptationSensitivity'</span>,<span class="keyword">...</span>
                opts.localAdaptation_photoreceptors/200, <span class="keyword">...</span>
            <span class="string">'PhotoreceptorsSpatialConstant'</span>,0.43, <span class="keyword">...</span>
            <span class="string">'HorizontalCellsGain'</span>,opts.retinaHcellsGain, <span class="keyword">...</span>
            <span class="string">'GanglionCellsSensitivity'</span>,opts.localAdaptation_Gcells/200);

        <span class="comment">% display params</span>
        <span class="keyword">if</span> verbose()
            disp(retina.printSetup());
        <span class="keyword">end</span>
    <span class="keyword">end</span>
<span class="keyword">end</span>

<span class="keyword">function</span> [dst, histoImg] = rescaleGrayLevelMat(src, clipLimit)
    <span class="comment">%RESCALEGRAYLEVELMAT  Get the gray level map of the input image and rescale it to the range [0-255]</span>
    <span class="comment">%</span>
    <span class="comment">% Performs histogram stretching.</span>
    <span class="comment">%</span>
    <span class="comment">% See also: imadjust, stretchlim, cv.SimpleWB</span>
    <span class="comment">%</span>

    <span class="comment">% rescale to [0,255], keeping floating-point values</span>
    dst = cv.normalize(src, <span class="string">'Alpha'</span>,0.0, <span class="string">'Beta'</span>,255.0, <span class="string">'NormType'</span>,<span class="string">'MinMax'</span>);

    <span class="comment">% extract a 8bit image that will be used for histogram edge cut</span>
    gray = uint8(dst);
    <span class="keyword">if</span> size(dst,3) == 3
        gray = cv.cvtColor(gray, <span class="string">'RGB2GRAY'</span>);
    <span class="keyword">end</span>

    <span class="comment">% get histogram density probability in order to cut values under/above</span>
    <span class="comment">% edges limits (e.g 5-95%)... useful for HDR pixel errors cancellation</span>
    HIST_SIZE = 256;  <span class="comment">% resolution of histogram</span>
    histo = cv.calcHist(gray, linspace(0,255+1,HIST_SIZE+1));
    <span class="comment">% normalize histogram so that its sum equals 1</span>
    histo = cv.normalize(histo, <span class="keyword">...</span>
        <span class="string">'Alpha'</span>,1.0, <span class="string">'Beta'</span>,0.0, <span class="string">'NormType'</span>,<span class="string">'L1'</span>, <span class="string">'DType'</span>,<span class="string">'single'</span>);

    <span class="comment">% compute density probability</span>
    denseProb = cumsum(histo);

    <span class="comment">% deduce min and max admitted gray level indices</span>
    <span class="keyword">if</span> clipLimit == 0
        lowerLimit = 0;
        upperLimit = 256;
    <span class="keyword">else</span>
        lowerLimit = nnz(denseProb &lt; clipLimit);
        upperLimit = nnz(denseProb &lt; (1-clipLimit));
    <span class="keyword">end</span>

    <span class="comment">% corresponding gray level values</span>
    mn = 255.0 * lowerLimit / HIST_SIZE;
    mx = 255.0 * upperLimit / HIST_SIZE;

    <span class="keyword">if</span> verbose()
        disp(<span class="string">'Input image rescaling with histogram edges cutting'</span>);
        disp(<span class="string">'(in order to eliminate bad pixels in HDR image creation):'</span>);
        disp(<span class="string">'=&gt; Histogram limits'</span>);
        fprintf(<span class="string">'\t%g%% index = %d\n'</span>, clipLimit*100, lowerLimit);
        fprintf(<span class="string">'\t\tnormalized hist value = %g\n'</span>, <span class="keyword">...</span>
            denseProb(find(denseProb &gt;= clipLimit, 1, <span class="string">'first'</span>)));
        fprintf(<span class="string">'\t\tinput gray level = %g\n'</span>, mn);
        fprintf(<span class="string">'\t%g%% index = %d\n'</span>, (1-clipLimit)*100, upperLimit);
        fprintf(<span class="string">'\t\tnormalized hist value = %g\n'</span>, <span class="keyword">...</span>
            denseProb(find(denseProb &lt;= (1-clipLimit), 1, <span class="string">'last'</span>)));
        fprintf(<span class="string">'\t\tinput gray level = %g\n'</span>, mx);
    <span class="keyword">end</span>

    <span class="comment">% draw clipped histogram image</span>
    <span class="keyword">if</span> nargout &gt; 1
        [~, hsz] = calcSizes(size(gray));
        histoImg = drawHistogram(histo, hsz, lowerLimit, upperLimit);
    <span class="keyword">end</span>

    <span class="comment">% rescale image range [mn,mx] to [0,255]</span>
    dst = (dst - mn) * 255.0 / (mx - mn);

    <span class="comment">% cut original histogram and back project to original image</span>
    <span class="keyword">if</span> true
        <span class="comment">% clips values above 255, and values below 0</span>
        dst = cv.threshold(dst, 255.0, <span class="string">'MaxValue'</span>,255.0, <span class="string">'Type'</span>,<span class="string">'Trunc'</span>);
        dst = cv.threshold(dst, 0.0, <span class="string">'MaxValue'</span>,0.0, <span class="string">'Type'</span>,<span class="string">'ToZero'</span>);
    <span class="keyword">else</span>
        dst = max(min(dst, 255.0), 0.0);
    <span class="keyword">end</span>

    dst = cv.normalize(dst, <span class="string">'Alpha'</span>,0.0, <span class="string">'Beta'</span>,255.0, <span class="string">'NormType'</span>,<span class="string">'MinMax'</span>);
<span class="keyword">end</span>

<span class="keyword">function</span> histoImg = drawHistogram(histo, hsz, lowerLimit, upperLimit)
    <span class="comment">%DRAWHISTOGRAM  Simple procedure for 1D curve tracing</span>
    <span class="comment">%</span>
    <span class="comment">% See also: imhist, hist, bar, histogram</span>
    <span class="comment">%</span>

    <span class="comment">% bar width</span>
    len = numel(histo);
    binW = round(hsz(2) / len);

    <span class="comment">% normalize histogram to fit output image height</span>
    histo = round(cv.normalize(histo, <span class="keyword">...</span>
        <span class="string">'Alpha'</span>,0, <span class="string">'Beta'</span>,hsz(1), <span class="string">'NormType'</span>,<span class="string">'MinMax'</span>, <span class="string">'DType'</span>,<span class="string">'single'</span>));

    <span class="comment">% output image on which to draw histogram</span>
    histoImg = 255 * ones([hsz 3], <span class="string">'uint8'</span>);  <span class="comment">% white background</span>

    <span class="comment">% draw histogram bars</span>
    <span class="comment">% (BG is white, we simply draw from top to bar height in black)</span>
    <span class="keyword">for</span> i=1:len
        histoImg = cv.rectangle(histoImg, <span class="keyword">...</span>
            [(i-1)*binW, hsz(1)], [i*binW, hsz(1) - histo(i)], <span class="keyword">...</span>
            <span class="string">'Color'</span>,[0 0 0], <span class="string">'Thickness'</span>,<span class="string">'Filled'</span>);
    <span class="keyword">end</span>

    <span class="comment">% show lower/upper clip limits</span>
    <span class="keyword">if</span> nargin &gt; 2
        histoImg = cv.rectangle(histoImg, <span class="keyword">...</span>
            [0, 0], [lowerLimit*binW, hsz(1)], <span class="keyword">...</span>
            <span class="string">'Color'</span>,[128 128 128], <span class="string">'Thickness'</span>,<span class="string">'Filled'</span>);
    <span class="keyword">end</span>
    <span class="keyword">if</span> nargin &gt; 3
        histoImg = cv.rectangle(histoImg, <span class="keyword">...</span>
            [hsz(2), 0], [upperLimit*binW, hsz(1)], <span class="keyword">...</span>
            <span class="string">'Color'</span>,[128 128 128], <span class="string">'Thickness'</span>,<span class="string">'Filled'</span>);
    <span class="keyword">end</span>

    <span class="comment">% title</span>
    histoImg = cv.putText(histoImg, <span class="string">'Histogram'</span>, [10 20], <span class="keyword">...</span>
        <span class="string">'FontScale'</span>,0.5, <span class="string">'Color'</span>,[0 255 0]);
<span class="keyword">end</span>

<span class="keyword">function</span> [sz, hsz] = calcSizes(isz)
    <span class="comment">%CALCSIZE  Calculate axes sizes to maximally fit screen</span>

    <span class="comment">% isz = input image size [h,w]</span>
    <span class="comment">% sz  = image axis size [h,w]</span>
    <span class="comment">% hsz = histogram axis size [h,w]</span>
    <span class="comment">% ss  = screen size [1,1,w,h]</span>

    <span class="comment">%NOTE: width divided between 2 equal size axes</span>
    <span class="comment">%TODO: more portable height calculation</span>
    <span class="comment">%  ss(4) = screen height</span>
    <span class="comment">% hsz(1) = histogram height</span>
    <span class="comment">%    130 = sliders height</span>
    <span class="comment">%     35 = axis-title height (2 lines)</span>
    <span class="comment">%     40 = window frame height</span>
    <span class="comment">%     40 = windows taskbar height</span>
    hsz = [120 2*isz(2)];
    ss = get(0, <span class="string">'ScreenSize'</span>);
    sz = round(min([ss(4)-hsz(1)-130-35-40-40 ss(3)./2] ./ isz) .* isz);
    hsz(2) = 2*sz(2);
<span class="keyword">end</span>

<span class="keyword">function</span> h = buildGUI(imgs, isz, opts)
    <span class="comment">%BUILDGUI  Creates the UI</span>

    <span class="comment">% calculate axes sizes to best fit to screen</span>
    [sz, hsz] = calcSizes(isz);

    <span class="comment">% build the user interface (no resizing to keep it simple)</span>
    h = struct();
    h.fig = figure(<span class="string">'Name'</span>,<span class="string">'Retina HDR Tonemapping Demo'</span>, <span class="keyword">...</span>
        <span class="string">'NumberTitle'</span>,<span class="string">'off'</span>, <span class="string">'Menubar'</span>,<span class="string">'none'</span>, <span class="string">'Resize'</span>,<span class="string">'off'</span>, <span class="keyword">...</span>
        <span class="string">'Position'</span>,[200 200 sz(2)*2 sz(1)+hsz(1)+130+35-1]);
    <span class="keyword">if</span> ~mexopencv.isOctave()
        <span class="comment">%HACK: not implemented in Octave</span>
        movegui(h.fig, <span class="string">'center'</span>);
    <span class="keyword">end</span>
    im = {imgs.rescaled, imgs.dst, imgs.histo};
    pos = {
        [1       130+hsz(1)  sz(2)  sz(1)]
        [1+sz(2) 130+hsz(1)  sz(2)  sz(1)]
        [1       130        hsz(2) hsz(1)]
    };
    titles = {
        {<span class="string">'Retina input'</span>, <span class="string">'(w/ clipped histogram)'</span>}
        {<span class="string">'Retina tonemapping output'</span>, <span class="string">'Parvocellular pathway'</span>}
        <span class="string">''</span>  <span class="comment">% Histogram</span>
    };
    <span class="keyword">if</span> opts.fastMethod, titles{2}{2} = <span class="string">'fast tone mapping'</span>; <span class="keyword">end</span>
    <span class="keyword">for</span> i=1:numel(im)
        h.ax(i) = axes(<span class="string">'Parent'</span>,h.fig, <span class="string">'Units'</span>,<span class="string">'pixels'</span>, <span class="string">'Position'</span>,pos{i});
        <span class="keyword">if</span> ~mexopencv.isOctave()
            h.img(i) = imshow(im{i}, <span class="string">'Parent'</span>,h.ax(i));
        <span class="keyword">else</span>
            <span class="comment">%HACK: https://savannah.gnu.org/bugs/index.php?45473</span>
            axes(h.ax(i)); h.img(i) = imshow(im{i});
        <span class="keyword">end</span>
        <span class="keyword">if</span> ~isempty(titles{i})
            title(h.ax(i), titles{i}, <span class="string">'FontSize'</span>,10, <span class="string">'Interpreter'</span>,<span class="string">'none'</span>);
        <span class="keyword">end</span>
    <span class="keyword">end</span>
    props = {<span class="string">'FontSize'</span>,11, <span class="string">'HorizontalAlignment'</span>,<span class="string">'right'</span>};
    h.txt(1) = uicontrol(<span class="string">'Parent'</span>,h.fig, <span class="string">'Style'</span>,<span class="string">'text'</span>, props{:}, <span class="keyword">...</span>
        <span class="string">'Position'</span>,[5 5 150 20], <span class="keyword">...</span>
        <span class="string">'String'</span>,sprintf(<span class="string">'hist edges clip limit: %2d'</span>, opts.histogramClippingValue));
    h.txt(2) = uicontrol(<span class="string">'Parent'</span>,h.fig, <span class="string">'Style'</span>,<span class="string">'text'</span>, props{:}, <span class="keyword">...</span>
        <span class="string">'Position'</span>,[5 30 150 20], <span class="keyword">...</span>
        <span class="string">'String'</span>,sprintf(<span class="string">'Color saturation: %1d'</span>, opts.colorSaturationFactor));
    h.txt(3) = uicontrol(<span class="string">'Parent'</span>,h.fig, <span class="string">'Style'</span>,<span class="string">'text'</span>, props{:}, <span class="keyword">...</span>
        <span class="string">'Position'</span>,[5 55 150 20], <span class="keyword">...</span>
        <span class="string">'String'</span>,sprintf(<span class="string">'Hcells gain: %3d'</span>, opts.retinaHcellsGain));
    h.txt(4) = uicontrol(<span class="string">'Parent'</span>,h.fig, <span class="string">'Style'</span>,<span class="string">'text'</span>, props{:}, <span class="keyword">...</span>
        <span class="string">'Position'</span>,[5 80 150 20], <span class="keyword">...</span>
        <span class="string">'String'</span>,sprintf(<span class="string">'Ph sensitivity: %3d'</span>, opts.localAdaptation_photoreceptors));
    h.txt(5) = uicontrol(<span class="string">'Parent'</span>,h.fig, <span class="string">'Style'</span>,<span class="string">'text'</span>, props{:}, <span class="keyword">...</span>
        <span class="string">'Position'</span>,[5 105 150 20], <span class="keyword">...</span>
        <span class="string">'String'</span>,sprintf(<span class="string">'Gcells sensitivity: %3d'</span>, opts.localAdaptation_Gcells));
    h.slid(1) = uicontrol(<span class="string">'Parent'</span>,h.fig, <span class="string">'Style'</span>,<span class="string">'slider'</span>, <span class="keyword">...</span>
        <span class="string">'Value'</span>,opts.histogramClippingValue, <span class="keyword">...</span>
        <span class="string">'Min'</span>,0, <span class="string">'Max'</span>,50, <span class="string">'SliderStep'</span>,[1 5]./(50-0), <span class="keyword">...</span>
        <span class="string">'Position'</span>,[155 5 sz(2)*2-155-20 20]);
    h.slid(2) = uicontrol(<span class="string">'Parent'</span>,h.fig, <span class="string">'Style'</span>,<span class="string">'slider'</span>, <span class="keyword">...</span>
        <span class="string">'Value'</span>,opts.colorSaturationFactor, <span class="keyword">...</span>
        <span class="string">'Min'</span>,0, <span class="string">'Max'</span>,5, <span class="string">'SliderStep'</span>,[1 2]./(5-0), <span class="keyword">...</span>
        <span class="string">'Position'</span>,[155 30 sz(2)*2-155-20 20]);
    h.slid(3) = uicontrol(<span class="string">'Parent'</span>,h.fig, <span class="string">'Style'</span>,<span class="string">'slider'</span>, <span class="keyword">...</span>
        <span class="string">'Value'</span>,opts.retinaHcellsGain, <span class="keyword">...</span>
        <span class="string">'Min'</span>,0, <span class="string">'Max'</span>,100, <span class="string">'SliderStep'</span>,[1 10]./(100-0), <span class="keyword">...</span>
        <span class="string">'Position'</span>,[155 55 sz(2)*2-155-20 20]);
    h.slid(4) = uicontrol(<span class="string">'Parent'</span>,h.fig, <span class="string">'Style'</span>,<span class="string">'slider'</span>, <span class="keyword">...</span>
        <span class="string">'Value'</span>,opts.localAdaptation_photoreceptors, <span class="keyword">...</span>
        <span class="string">'Min'</span>,0, <span class="string">'Max'</span>,200, <span class="string">'SliderStep'</span>,[1 20]./(200-0), <span class="keyword">...</span>
        <span class="string">'Position'</span>,[155 80 sz(2)*2-155-20 20]);
    h.slid(5) = uicontrol(<span class="string">'Parent'</span>,h.fig, <span class="string">'Style'</span>,<span class="string">'slider'</span>, <span class="keyword">...</span>
        <span class="string">'Value'</span>,opts.localAdaptation_Gcells, <span class="keyword">...</span>
        <span class="string">'Min'</span>,0, <span class="string">'Max'</span>,200, <span class="string">'SliderStep'</span>,[1 20]./(200-0), <span class="keyword">...</span>
        <span class="string">'Position'</span>,[155 105 sz(2)*2-155-20 20]);

    <span class="comment">% create timer</span>
    h.t = timer(<span class="string">'ExecutionMode'</span>,<span class="string">'fixedSpacing'</span>, <span class="string">'Period'</span>,0.1);
<span class="keyword">end</span></pre><div class="footer">
            <p><a href="https://www.mathworks.com/products/matlab.html">Published with MATLAB&reg; R2017a</a></p>
         </div>
      </div>
      <!--
##### SOURCE BEGIN #####
%% OpenEXR images HDR Retina tone mapping demo
% High Dynamic Range retina tone mapping with the help of the Gipsa/Listic's
% retina.
%
% Retina demonstration for High Dynamic Range compression (tone-mapping):
% demonstrates the use of wrapper class of the Gipsa/Listic Labs retina model.
%
% This retina model allows spatio-temporal image processing (applied on a
% still image).
%
% This demo focuses demonstration of the dynamic compression capabilities of
% the model. The main application is tone mapping of HDR images (i.e. see on a
% 8bit display a more than 8bits coded (up to 16bits) image with details in
% high and low luminance ranges.
%
% The retina model still have the following properties:
%
% * It applies a spectral whithening (mid-frequency details enhancement)
% * high frequency spatio-temporal noise reduction
% * low frequency luminance to be reduced (luminance range compression)
% * local logarithmic luminance compression allows details to be enhanced in
%   low light conditions
%
% Sources:
%
% * <https://github.com/opencv/opencv_contrib/blob/3.2.0/modules/bioinspired/samples/cpp/OpenEXRimages_HDR_Retina_toneMapping.cpp>
% * <https://github.com/opencv/opencv_contrib/blob/3.2.0/modules/bioinspired/samples/cpp/OpenEXRimages_HDR_Retina_toneMapping_video.cpp>
%

function varargout = retina_hdr_tonemapping_demo_gui(fname)
    % load HDR image
    if nargin < 1
        % http://www.pauldebevec.com/Research/HDR/memorial.hdr
        % http://www.pauldebevec.com/Research/HDR/memorial.exr
        fname = fullfile(mexopencv.root(),'test','memorial.hdr');
    end
    [imgs, isz] = loadInputImage(fname);
    showInputImage(imgs);

    % create retina object
    opts = defaultOptions();
    retina = createRetina(fliplr(isz), opts);

    % create the UI, hook event handlers, and trigger timer
    h = buildGUI(imgs, isz, opts);
    props = {'Interruptible','off', 'BusyAction','cancel'};
    set(h.fig, 'WindowKeyPressFcn',@onType, props{:});
    set(h.slid(1), 'Callback',@onChangeClipping, props{:});
    set(h.slid(2), 'Callback',@onChangeSaturation, props{:});
    set(h.slid(3:5), 'Callback',@onChangeParams, props{:});
    set(h.t, 'TimerFcn',@onTimer, 'BusyMode','drop');
    start(h.t);

    if nargout > 0, varargout{1} = h; end
    if nargout > 1, varargout{2} = retina; end

    %% Event handlers

    function onType(~, e)
        %ONTYPE  Event handler for key press on figure

        % handle keys
        switch e.Key
            case 'h'
                helpdlg({
                    'Hot keys:'
                    'h - this help dialog'
                    'q - quit the program'
                    'c - clear all retina buffers (open your eyes)'
                });

            case {'q', 'escape'}
                stop(h.t);
                delete(h.t);
                close(h.fig);

            case 'v'
                % toggle verbose mode
                verbose(~verbose());

            case 'c'
                % clear retina buffers
                if ~opts.fastMethod
                    retina.clearBuffers();
                end

            case 'f'
                % switch between retina and fast retina tone mapper
                opts.fastMethod = ~opts.fastMethod;
                retina = createRetina(fliplr(isz), opts);
                % update plot title
                str = {'Retina tonemapping output', 'Parvocellular pathway'};
                if opts.fastMethod
                    str{2} = 'fast tone mapping';
                end
                title(h.ax(2), str, 'FontSize',10, 'Interpreter','none');

            case 'l'
                % toggle retina log sampling
                opts.useLogSampling = ~opts.useLogSampling;
                retina = createRetina(fliplr(isz), opts);

            case 'r'
                % reset default options
                opts = defaultOptions();
                retina = createRetina(fliplr(isz), opts);
                % update UI
                set(h.slid(1), 'Value',opts.histogramClippingValue);
                set(h.slid(2), 'Value',opts.colorSaturationFactor);
                set(h.slid(3), 'Value',opts.retinaHcellsGain);
                set(h.slid(4), 'Value',opts.localAdaptation_photoreceptors);
                set(h.slid(5), 'Value',opts.localAdaptation_Gcells);
                onChangeClipping([],[]);
                onChangeSaturation([],[]);
                onChangeParams([],[]);
                drawnow;

            case {'s', 'space'}
                % start/stop the timer
                if strcmp(h.t.Running, 'on')
                    stop(h.t);
                else
                    start(h.t);
                end
        end
    end

    function onChangeClipping(~, ~)
        %ONCHANGECLIPPING  Event handler for UI controls

        % retrieve current values from UI controls
        opts.histogramClippingValue = round(get(h.slid(1), 'Value'));
        set(h.txt(1), 'String',sprintf('hist edges clip limit: %2d', ...
            opts.histogramClippingValue));

        % apply new parameters
        [imgs.rescaled, imgs.histo] = rescaleGrayLevelMat(imgs.src, ...
            opts.histogramClippingValue/100);

        % manually run one step if timer if off
        if strcmp(h.t.Running, 'off'), onTimer([], []); end
    end

    function onChangeSaturation(~, ~)
        %ONCHANGESATURATION  Event handler for UI controls

        % retrieve current values from UI controls
        opts.colorSaturationFactor = round(get(h.slid(2), 'Value'));
        set(h.txt(2), 'String',sprintf('Color saturation: %1d', ...
            opts.colorSaturationFactor));

        % apply new parameters
        if ~opts.fastMethod
            retina.setColorSaturation('SaturateColors',true, ...
                'ColorSaturationValue',opts.colorSaturationFactor);

            % manually run one step if timer if off
            if strcmp(h.t.Running, 'off'), onTimer([], []); end
        end
    end

    function onChangeParams(~, ~)
        %ONCHANGEPARAMS  Event handler for UI controls

        % retrieve current values from UI controls
        opts.retinaHcellsGain = round(get(h.slid(3), 'Value'));
        opts.localAdaptation_photoreceptors = round(get(h.slid(4), 'Value'));
        opts.localAdaptation_Gcells = round(get(h.slid(5), 'Value'));
        set(h.txt(3), 'String',sprintf('Hcells gain: %3d', ...
            opts.retinaHcellsGain));
        set(h.txt(4), 'String',sprintf('Ph sensitivity: %3d', ...
            opts.localAdaptation_photoreceptors));
        set(h.txt(5), 'String',sprintf('Gcells sensitivity: %3d', ...
            opts.localAdaptation_Gcells));

        % apply new parameters
        if ~opts.fastMethod
            retina.setupOPLandIPLParvoChannel(...
                'PhotoreceptorsLocalAdaptationSensitivity',...
                    opts.localAdaptation_photoreceptors/200, ...
                'PhotoreceptorsSpatialConstant',0.43, ...
                'HorizontalCellsGain',opts.retinaHcellsGain, ...
                'GanglionCellsSensitivity',opts.localAdaptation_Gcells/200);

            % manually run one step if timer if off
            if strcmp(h.t.Running, 'off'), onTimer([], []); end
        end
    end

    function onTimer(~, ~)
        %ONTIMER  Timer callback function

        % stop timer if figure was closed
        if ~ishghandle(h.fig)
            stop(h.t);
            delete(h.t);
            return;
        end

        % run retina filter
        if opts.fastMethod
            % apply the simplified hdr tone mapping method
            imgs.dst = retina.applyFastToneMapping(imgs.rescaled);
        else
            % run and retrieve retina output
            retina.run(imgs.rescaled);
            imgs.dst = retina.getParvo();
        end

        % display retina HDR input and LDR output, and clipped histogram
        set(h.img(1), 'CData',imgs.rescaled./255);
        set(h.img(2), 'CData',imgs.dst);
        set(h.img(3), 'CData',imgs.histo);
        drawnow;
    end
end

function b = verbose(varargin)
    %VERBOSE  Get/set verbosity

    persistent verbose
    if isempty(verbose), verbose = true; end

    if nargin > 0
        verbose = logical(varargin{1});
    end
    b = verbose;
end

function [imgs, isz] = loadInputImage(fname)
    %LOADIMAGE  Load HDR image

    % load retina input image
    img = cv.imread(fname, 'Unchanged',true);
    assert(~isempty(img), 'could not load image');
    isz = [size(img,1) size(img,2)];
    if verbose()
        fprintf('=> image size (w,h) = %d,%d\n', isz(2), isz(1));
    end

    % rescale between 0 and 1, still floating-point
    img = cv.normalize(img, 'Alpha',0, 'Beta',1, 'NormType','MinMax');
    img = min(max(img, 0), 1);  % avoid tiny negative values

    % output structure of images:
    %   src      -> single, [0,1]   = input image
    %   gamma    -> single, [0,1]   = gamme transformed image
    %   rescaled -> single, [0,255] = input image rescaled
    %   dst      -> uint8,  [0,255] = retina output image
    %   histo    -> uint8,  [0,255] = histogram image
    imgs = struct();
    imgs.src = img;
    imgs.gamma = img .^ (1/5);  % apply gamma curve
    [imgs.rescaled, imgs.histo] = rescaleGrayLevelMat(img, 0);
    imgs.dst = zeros(size(img), 'uint8');
end

function showInputImage(imgs)
    %SHOWINPUTIMAGES  Show input HDR images

    % overlay titles
    props = {'FontScale',0.5, 'Color',[0 255 0]};
    srcImg = cv.putText(imgs.src, ...
        'EXR original (linear rescaling)', [10 20], props{:});
    gammaImg = cv.putText(imgs.gamma, ...
        'EXR w/ basic processing (gamma correction)', [10 20], props{:});

    % show image montage
    im = cat(2, srcImg, gammaImg);
    fig = figure('Name','HDR', 'NumberTitle','off', 'Menubar','none', ...
        'Position',[200 200 size(im,2) size(im,1)]);
    if ~mexopencv.isOctave()
        movegui(fig, 'center');
    end
    ax = axes('Parent',fig, 'Units','normalized', 'Position',[0 0 1 1]);
    if ~mexopencv.isOctave()
        imshow(im, 'Parent',ax);
    else
        %HACK: https://savannah.gnu.org/bugs/index.php?45473
        axes(ax); imshow(im);
    end
end

function opts = defaultOptions()
    %DEFAULTOPTIONS  Create default options structure

    opts = struct();
    opts.useLogSampling = false;               % retina log sampling processing
    opts.fastMethod = false;                   % fast method (no spectral whitening)
    opts.histogramClippingValue = 0;           % histogram edges clipping limit
    opts.colorSaturationFactor = 3;            % Color saturation
    opts.retinaHcellsGain = 40;                % Hcells gain
    opts.localAdaptation_photoreceptors = 197; % Ph sensitivity
    opts.localAdaptation_Gcells = 190;         % Gcells sensitivity
end

function retina = createRetina(isz, opts)
    %CREATERETINA  Create retina instance

    if opts.useLogSampling
        % activate log sampling
        % (favour foveal vision and subsamples peripheral vision)
        props = {'UseRetinaLogSampling',true, 'ReductionFactor',2.0};
    else
        % allocate "classical" retina
        props = {};
    end

    if opts.fastMethod
        %TODO: untested
        % create a fast retina tone mapper (Meylan et al. algorithm)
        retina = cv.RetinaFastToneMapping(isz);
        retina.setup('PhotoreceptorsNeighborhoodRadius',3, ...
            'GanglioncellsNeighborhoodRadius',1.5, ...
            'MeanLuminanceModulatorK',1);
    else
        % create a retina instance with default parameters setup
        retina = cv.Retina(isz, props{:});

        % desactivate Magnocellular pathway processing
        % (motion information extraction) since it is not useful here
        retina.activateMovingContoursProcessing(false);

        % set retina params
        retina.setColorSaturation('SaturateColors',true, ...
            'ColorSaturationValue',opts.colorSaturationFactor);
        retina.setupOPLandIPLParvoChannel(...
            'PhotoreceptorsLocalAdaptationSensitivity',...
                opts.localAdaptation_photoreceptors/200, ...
            'PhotoreceptorsSpatialConstant',0.43, ...
            'HorizontalCellsGain',opts.retinaHcellsGain, ...
            'GanglionCellsSensitivity',opts.localAdaptation_Gcells/200);

        % display params
        if verbose()
            disp(retina.printSetup());
        end
    end
end

function [dst, histoImg] = rescaleGrayLevelMat(src, clipLimit)
    %RESCALEGRAYLEVELMAT  Get the gray level map of the input image and rescale it to the range [0-255]
    %
    % Performs histogram stretching.
    %
    % See also: imadjust, stretchlim, cv.SimpleWB
    %

    % rescale to [0,255], keeping floating-point values
    dst = cv.normalize(src, 'Alpha',0.0, 'Beta',255.0, 'NormType','MinMax');

    % extract a 8bit image that will be used for histogram edge cut
    gray = uint8(dst);
    if size(dst,3) == 3
        gray = cv.cvtColor(gray, 'RGB2GRAY');
    end

    % get histogram density probability in order to cut values under/above
    % edges limits (e.g 5-95%)... useful for HDR pixel errors cancellation
    HIST_SIZE = 256;  % resolution of histogram
    histo = cv.calcHist(gray, linspace(0,255+1,HIST_SIZE+1));
    % normalize histogram so that its sum equals 1
    histo = cv.normalize(histo, ...
        'Alpha',1.0, 'Beta',0.0, 'NormType','L1', 'DType','single');

    % compute density probability
    denseProb = cumsum(histo);

    % deduce min and max admitted gray level indices
    if clipLimit == 0
        lowerLimit = 0;
        upperLimit = 256;
    else
        lowerLimit = nnz(denseProb < clipLimit);
        upperLimit = nnz(denseProb < (1-clipLimit));
    end

    % corresponding gray level values
    mn = 255.0 * lowerLimit / HIST_SIZE;
    mx = 255.0 * upperLimit / HIST_SIZE;

    if verbose()
        disp('Input image rescaling with histogram edges cutting');
        disp('(in order to eliminate bad pixels in HDR image creation):');
        disp('=> Histogram limits');
        fprintf('\t%g%% index = %d\n', clipLimit*100, lowerLimit);
        fprintf('\t\tnormalized hist value = %g\n', ...
            denseProb(find(denseProb >= clipLimit, 1, 'first')));
        fprintf('\t\tinput gray level = %g\n', mn);
        fprintf('\t%g%% index = %d\n', (1-clipLimit)*100, upperLimit);
        fprintf('\t\tnormalized hist value = %g\n', ...
            denseProb(find(denseProb <= (1-clipLimit), 1, 'last')));
        fprintf('\t\tinput gray level = %g\n', mx);
    end

    % draw clipped histogram image
    if nargout > 1
        [~, hsz] = calcSizes(size(gray));
        histoImg = drawHistogram(histo, hsz, lowerLimit, upperLimit);
    end

    % rescale image range [mn,mx] to [0,255]
    dst = (dst - mn) * 255.0 / (mx - mn);

    % cut original histogram and back project to original image
    if true
        % clips values above 255, and values below 0
        dst = cv.threshold(dst, 255.0, 'MaxValue',255.0, 'Type','Trunc');
        dst = cv.threshold(dst, 0.0, 'MaxValue',0.0, 'Type','ToZero');
    else
        dst = max(min(dst, 255.0), 0.0);
    end

    dst = cv.normalize(dst, 'Alpha',0.0, 'Beta',255.0, 'NormType','MinMax');
end

function histoImg = drawHistogram(histo, hsz, lowerLimit, upperLimit)
    %DRAWHISTOGRAM  Simple procedure for 1D curve tracing
    %
    % See also: imhist, hist, bar, histogram
    %

    % bar width
    len = numel(histo);
    binW = round(hsz(2) / len);

    % normalize histogram to fit output image height
    histo = round(cv.normalize(histo, ...
        'Alpha',0, 'Beta',hsz(1), 'NormType','MinMax', 'DType','single'));

    % output image on which to draw histogram
    histoImg = 255 * ones([hsz 3], 'uint8');  % white background

    % draw histogram bars
    % (BG is white, we simply draw from top to bar height in black)
    for i=1:len
        histoImg = cv.rectangle(histoImg, ...
            [(i-1)*binW, hsz(1)], [i*binW, hsz(1) - histo(i)], ...
            'Color',[0 0 0], 'Thickness','Filled');
    end

    % show lower/upper clip limits
    if nargin > 2
        histoImg = cv.rectangle(histoImg, ...
            [0, 0], [lowerLimit*binW, hsz(1)], ...
            'Color',[128 128 128], 'Thickness','Filled');
    end
    if nargin > 3
        histoImg = cv.rectangle(histoImg, ...
            [hsz(2), 0], [upperLimit*binW, hsz(1)], ...
            'Color',[128 128 128], 'Thickness','Filled');
    end

    % title
    histoImg = cv.putText(histoImg, 'Histogram', [10 20], ...
        'FontScale',0.5, 'Color',[0 255 0]);
end

function [sz, hsz] = calcSizes(isz)
    %CALCSIZE  Calculate axes sizes to maximally fit screen

    % isz = input image size [h,w]
    % sz  = image axis size [h,w]
    % hsz = histogram axis size [h,w]
    % ss  = screen size [1,1,w,h]

    %NOTE: width divided between 2 equal size axes
    %TODO: more portable height calculation
    %  ss(4) = screen height
    % hsz(1) = histogram height
    %    130 = sliders height
    %     35 = axis-title height (2 lines)
    %     40 = window frame height
    %     40 = windows taskbar height
    hsz = [120 2*isz(2)];
    ss = get(0, 'ScreenSize');
    sz = round(min([ss(4)-hsz(1)-130-35-40-40 ss(3)./2] ./ isz) .* isz);
    hsz(2) = 2*sz(2);
end

function h = buildGUI(imgs, isz, opts)
    %BUILDGUI  Creates the UI

    % calculate axes sizes to best fit to screen
    [sz, hsz] = calcSizes(isz);

    % build the user interface (no resizing to keep it simple)
    h = struct();
    h.fig = figure('Name','Retina HDR Tonemapping Demo', ...
        'NumberTitle','off', 'Menubar','none', 'Resize','off', ...
        'Position',[200 200 sz(2)*2 sz(1)+hsz(1)+130+35-1]);
    if ~mexopencv.isOctave()
        %HACK: not implemented in Octave
        movegui(h.fig, 'center');
    end
    im = {imgs.rescaled, imgs.dst, imgs.histo};
    pos = {
        [1       130+hsz(1)  sz(2)  sz(1)]
        [1+sz(2) 130+hsz(1)  sz(2)  sz(1)]
        [1       130        hsz(2) hsz(1)]
    };
    titles = {
        {'Retina input', '(w/ clipped histogram)'}
        {'Retina tonemapping output', 'Parvocellular pathway'}
        ''  % Histogram
    };
    if opts.fastMethod, titles{2}{2} = 'fast tone mapping'; end
    for i=1:numel(im)
        h.ax(i) = axes('Parent',h.fig, 'Units','pixels', 'Position',pos{i});
        if ~mexopencv.isOctave()
            h.img(i) = imshow(im{i}, 'Parent',h.ax(i));
        else
            %HACK: https://savannah.gnu.org/bugs/index.php?45473
            axes(h.ax(i)); h.img(i) = imshow(im{i});
        end
        if ~isempty(titles{i})
            title(h.ax(i), titles{i}, 'FontSize',10, 'Interpreter','none');
        end
    end
    props = {'FontSize',11, 'HorizontalAlignment','right'};
    h.txt(1) = uicontrol('Parent',h.fig, 'Style','text', props{:}, ...
        'Position',[5 5 150 20], ...
        'String',sprintf('hist edges clip limit: %2d', opts.histogramClippingValue));
    h.txt(2) = uicontrol('Parent',h.fig, 'Style','text', props{:}, ...
        'Position',[5 30 150 20], ...
        'String',sprintf('Color saturation: %1d', opts.colorSaturationFactor));
    h.txt(3) = uicontrol('Parent',h.fig, 'Style','text', props{:}, ...
        'Position',[5 55 150 20], ...
        'String',sprintf('Hcells gain: %3d', opts.retinaHcellsGain));
    h.txt(4) = uicontrol('Parent',h.fig, 'Style','text', props{:}, ...
        'Position',[5 80 150 20], ...
        'String',sprintf('Ph sensitivity: %3d', opts.localAdaptation_photoreceptors));
    h.txt(5) = uicontrol('Parent',h.fig, 'Style','text', props{:}, ...
        'Position',[5 105 150 20], ...
        'String',sprintf('Gcells sensitivity: %3d', opts.localAdaptation_Gcells));
    h.slid(1) = uicontrol('Parent',h.fig, 'Style','slider', ...
        'Value',opts.histogramClippingValue, ...
        'Min',0, 'Max',50, 'SliderStep',[1 5]./(50-0), ...
        'Position',[155 5 sz(2)*2-155-20 20]);
    h.slid(2) = uicontrol('Parent',h.fig, 'Style','slider', ...
        'Value',opts.colorSaturationFactor, ...
        'Min',0, 'Max',5, 'SliderStep',[1 2]./(5-0), ...
        'Position',[155 30 sz(2)*2-155-20 20]);
    h.slid(3) = uicontrol('Parent',h.fig, 'Style','slider', ...
        'Value',opts.retinaHcellsGain, ...
        'Min',0, 'Max',100, 'SliderStep',[1 10]./(100-0), ...
        'Position',[155 55 sz(2)*2-155-20 20]);
    h.slid(4) = uicontrol('Parent',h.fig, 'Style','slider', ...
        'Value',opts.localAdaptation_photoreceptors, ...
        'Min',0, 'Max',200, 'SliderStep',[1 20]./(200-0), ...
        'Position',[155 80 sz(2)*2-155-20 20]);
    h.slid(5) = uicontrol('Parent',h.fig, 'Style','slider', ...
        'Value',opts.localAdaptation_Gcells, ...
        'Min',0, 'Max',200, 'SliderStep',[1 20]./(200-0), ...
        'Position',[155 105 sz(2)*2-155-20 20]);

    % create timer
    h.t = timer('ExecutionMode','fixedSpacing', 'Period',0.1);
end

##### SOURCE END #####
-->
   </body>
</html>