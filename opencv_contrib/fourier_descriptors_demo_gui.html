<!DOCTYPE html>
<html>
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   
      <!--This HTML was auto-generated from published MATLAB code.-->
      <title>Fourier Descriptors Demo</title>
      <meta name="generator" content="MATLAB 9.2">
      <link rel="schema.DC" href="http://purl.org/dc/elements/1.1/">
      <meta name="DC.date" content="2018-02-20">
      <meta name="DC.source" content="fourier_descriptors_demo_gui.m">
      <link rel="stylesheet" type="text/css" href="publish_custom.css">
   </head>
   <body>
      <div class="content">
         <h1 id="1">Fourier Descriptors Demo</h1>
         <p>Demostrates using Fourier descriptors for contour matching.</p>
         <p>Sources</p>
         <div>
            <ul>
               <li><a href="https://github.com/opencv/opencv_contrib/blob/3.4.0/modules/ximgproc/samples/fourier_descriptors_demo.cpp">https://github.com/opencv/opencv_contrib/blob/3.4.0/modules/ximgproc/samples/fourier_descriptors_demo.cpp</a></li>
            </ul>
         </div><pre class="codeinput"><span class="keyword">function</span> varargout = fourier_descriptors_demo_gui()
    <span class="comment">% create the UI</span>
    h = buildGUI();
    <span class="keyword">if</span> nargout &gt; 0, varargout{1} = h; <span class="keyword">end</span>
<span class="keyword">end</span>

<span class="keyword">function</span> out = noisyPolygon(pts, noise)
    <span class="keyword">if</span> noise == 0
        out = pts;
        <span class="keyword">return</span>;
    <span class="keyword">end</span>
    <span class="keyword">try</span>
        <span class="comment">% we want reproducible random numbers</span>
        rng(<span class="string">'default'</span>)
    <span class="keyword">end</span>
    pts = pts + (rand(size(pts)) * 2*noise - noise);
    out = pts(1,:);
    <span class="keyword">for</span> i=1:size(pts,1)
        next = i + 1;
        <span class="keyword">if</span> next &gt; size(pts,1), next = 1; <span class="keyword">end</span>
        u = pts(next,:) - pts(i,:);
        d = norm(u);
        a = atan2(u(2), u(1));
        step = max(d/noise, 1);
        <span class="keyword">for</span> j=1:step:d
            pAct = u * j/d;
            r = rand() * noise;
            theta = a + rand()*2*pi;
            pNew = r*[cos(theta), sin(theta)] + pAct + pts(i,:);
            out(end+1,:) = pNew;
        <span class="keyword">end</span>
    <span class="keyword">end</span>
    out = fix(out);
<span class="keyword">end</span>

<span class="keyword">function</span> img = FDCurveMatching(p)
    <span class="comment">% reference shape with 5 vertices</span>
    ctr0 = [250 250; 400 250; 400 300; 250 300; 180 270];

    <span class="comment">% noisy shape, transformed (rotate and scale)</span>
    M = cv.getRotationMatrix2D([p.xg, p.yg], p.angle, 10/p.scale);
    ctr1 = noisyPolygon(ctr0, p.levelNoise);
    ctr1 = permute(cv.transform(permute(ctr1, [1 3 2]), M), [1 3 2]);

    <span class="comment">% phase-shift (i.e same order just different starting point)</span>
    n = size(ctr1,1);
    orig = fix(p.origin/100 * n);
    ctr1 = circshift(ctr1, orig, 1);

    <span class="comment">% estimate transformation</span>
    <span class="keyword">if</span> true
        obj = cv.ContourFitting(<span class="string">'FDSize'</span>,16, <span class="string">'CtrSize'</span>,256);
        t = obj.estimateTransformation(ctr1, ctr0, <span class="string">'FD'</span>,false);
    <span class="keyword">else</span>
        <span class="comment">% explicit contour sampling with 256 points</span>
        ctr0s = cv.ContourFitting.contourSampling(ctr0, 256);
        ctr1s = cv.ContourFitting.contourSampling(ctr1, 256);
        obj = cv.ContourFitting(<span class="string">'FDSize'</span>,16);
        t = obj.estimateTransformation(ctr1s, ctr0s, <span class="string">'FD'</span>,false);
    <span class="keyword">end</span>

    <span class="comment">% fix t values to same range as ours: origin in (0,1)*n, angle in (0,360)</span>
    <span class="keyword">if</span> t(1) &lt; 0, t(1) = 1 + t(1); <span class="keyword">end</span>
    <span class="keyword">if</span> t(2) &lt; 0, t(2) = 2*pi + t(2); <span class="keyword">end</span>
    fprintf(<span class="string">'Transform: t=%s\n'</span>, mat2str(t,3));
    fprintf(<span class="string">' Origin = %f, expected %d (%d)\n'</span>, t(1)*n, orig, n);
    fprintf(<span class="string">' Angle  = %f, expected %d\n'</span>, t(2)*180/pi, p.angle);
    fprintf(<span class="string">' Scale  = %f, expected %g\n'</span>, t(3), p.scale/10);

    <span class="comment">% apply estimated transformation to bring noisy shape to reference shape</span>
    ctr2 = cv.ContourFitting.transformFD(ctr1, t, <span class="string">'FD'</span>,false);
    ctr2 = cat(1, ctr2{:});

    <span class="comment">% draw the three contours</span>
    C = {ctr0, ctr1, ctr2};
    clr = [255 0 0; 0 255 0; 0 255 255];
    txt = {<span class="string">'reference'</span>, <span class="string">'noisy'</span>, <span class="string">'recovered'</span>};

    <span class="comment">% output image size</span>
    rect = [0 0 500 500];
    <span class="keyword">if</span> false
        <span class="keyword">for</span> i=1:numel(C)
            rect = cv.Rect.union(rect, cv.boundingRect(C{i}));
        <span class="keyword">end</span>
    <span class="keyword">end</span>

    img = zeros([rect(3:4) 3], <span class="string">'uint8'</span>);
    <span class="keyword">for</span> i=1:numel(C)
        <span class="comment">% legend</span>
        img = cv.putText(img, txt{i}, [10 20*i], <span class="keyword">...</span>
            <span class="string">'Color'</span>,round(clr(i,:)*0.8), <span class="string">'FontScale'</span>,0.5);
        <span class="comment">% contour</span>
        img = cv.drawContours(img, C{i}, <span class="string">'Color'</span>,clr(i,:));
        <span class="comment">% starting point</span>
        img = cv.circle(img, C{i}(1,:), 5, <span class="string">'Color'</span>,clr(i,:));
    <span class="keyword">end</span>
<span class="keyword">end</span>

<span class="keyword">function</span> onChange(~,~,h)
    <span class="comment">%ONCHANGE  Event handler for UI controls</span>

    <span class="comment">% retrieve current values from UI controls</span>
    p = struct();
    p.levelNoise = round(get(h.slid(6), <span class="string">'Value'</span>));
    p.angle = round(get(h.slid(5), <span class="string">'Value'</span>));
    p.scale = round(get(h.slid(4), <span class="string">'Value'</span>));
    p.origin = round(get(h.slid(3), <span class="string">'Value'</span>));
    p.xg = round(get(h.slid(2), <span class="string">'Value'</span>));
    p.yg = round(get(h.slid(1), <span class="string">'Value'</span>));
    set(h.txt(1), <span class="string">'String'</span>,sprintf(<span class="string">'Yg: %d'</span>,p.yg));
    set(h.txt(2), <span class="string">'String'</span>,sprintf(<span class="string">'Xg: %d'</span>,p.xg));
    set(h.txt(3), <span class="string">'String'</span>,sprintf(<span class="string">'Origin%%: %d'</span>,p.origin));
    set(h.txt(4), <span class="string">'String'</span>,sprintf(<span class="string">'Scale: %d'</span>,p.scale));
    set(h.txt(5), <span class="string">'String'</span>,sprintf(<span class="string">'Angle: %d'</span>,p.angle));
    set(h.txt(6), <span class="string">'String'</span>,sprintf(<span class="string">'Noise: %d'</span>,p.levelNoise));

    <span class="comment">% perform contour matching using Fourier descriptors</span>
    img = FDCurveMatching(p);

    <span class="comment">% show result</span>
    set(h.img, <span class="string">'CData'</span>,img);
    drawnow;
<span class="keyword">end</span>

<span class="keyword">function</span> h = buildGUI()
    <span class="comment">%BUILDGUI  Creates the UI</span>

    <span class="comment">% canvas</span>
    img = zeros([500 500 3], <span class="string">'uint8'</span>);
    sz = size(img);

    <span class="comment">% initial params</span>
    <span class="comment">% (a 45 degree rotation centered at [250,250] with a scaling of 5/10)</span>
    p = struct();
    p.levelNoise = 6;
    p.angle = 45;
    p.scale = 5;
    p.origin = 10;
    p.xg = 250;
    p.yg = 250;

    <span class="comment">% build the user interface (no resizing to keep it simple)</span>
    h = struct();
    h.fig = figure(<span class="string">'Name'</span>,<span class="string">'FD Curve matching'</span>, <span class="keyword">...</span>
        <span class="string">'NumberTitle'</span>,<span class="string">'off'</span>, <span class="string">'Menubar'</span>,<span class="string">'none'</span>, <span class="string">'Resize'</span>,<span class="string">'off'</span>, <span class="keyword">...</span>
        <span class="string">'Position'</span>,[200 200 sz(2) sz(1)+155-1]);
    <span class="keyword">if</span> ~mexopencv.isOctave()
        <span class="comment">%HACK: not implemented in Octave</span>
        movegui(h.fig, <span class="string">'center'</span>);
    <span class="keyword">end</span>
    h.ax = axes(<span class="string">'Parent'</span>,h.fig, <span class="string">'Units'</span>,<span class="string">'pixels'</span>, <span class="string">'Position'</span>,[1 155 sz(2) sz(1)]);
    <span class="keyword">if</span> ~mexopencv.isOctave()
        h.img = imshow(img, <span class="string">'Parent'</span>,h.ax);
    <span class="keyword">else</span>
        <span class="comment">%HACK: https://savannah.gnu.org/bugs/index.php?45473</span>
        axes(h.ax);
        h.img = imshow(img);
    <span class="keyword">end</span>
    h.txt(1) = uicontrol(<span class="string">'Parent'</span>,h.fig, <span class="string">'Style'</span>,<span class="string">'text'</span>, <span class="string">'FontSize'</span>,11, <span class="keyword">...</span>
        <span class="string">'Position'</span>,[5 5 100 20], <span class="string">'String'</span>,sprintf(<span class="string">'Yg: %d'</span>,p.yg));
    h.txt(2) = uicontrol(<span class="string">'Parent'</span>,h.fig, <span class="string">'Style'</span>,<span class="string">'text'</span>, <span class="string">'FontSize'</span>,11, <span class="keyword">...</span>
        <span class="string">'Position'</span>,[5 30 100 20], <span class="string">'String'</span>,sprintf(<span class="string">'Xg: %d'</span>,p.xg));
    h.txt(3) = uicontrol(<span class="string">'Parent'</span>,h.fig, <span class="string">'Style'</span>,<span class="string">'text'</span>, <span class="string">'FontSize'</span>,11, <span class="keyword">...</span>
        <span class="string">'Position'</span>,[5 55 100 20], <span class="string">'String'</span>,sprintf(<span class="string">'Origin%%: %d'</span>,p.origin));
    h.txt(4) = uicontrol(<span class="string">'Parent'</span>,h.fig, <span class="string">'Style'</span>,<span class="string">'text'</span>, <span class="string">'FontSize'</span>,11, <span class="keyword">...</span>
        <span class="string">'Position'</span>,[5 80 100 20], <span class="string">'String'</span>,sprintf(<span class="string">'Scale: %d'</span>,p.scale));
    h.txt(5) = uicontrol(<span class="string">'Parent'</span>,h.fig, <span class="string">'Style'</span>,<span class="string">'text'</span>, <span class="string">'FontSize'</span>,11, <span class="keyword">...</span>
        <span class="string">'Position'</span>,[5 105 100 20], <span class="string">'String'</span>,sprintf(<span class="string">'Angle: %d'</span>,p.angle));
    h.txt(6) = uicontrol(<span class="string">'Parent'</span>,h.fig, <span class="string">'Style'</span>,<span class="string">'text'</span>, <span class="string">'FontSize'</span>,11, <span class="keyword">...</span>
        <span class="string">'Position'</span>,[5 130 100 20], <span class="string">'String'</span>,sprintf(<span class="string">'Noise: %d'</span>,p.levelNoise));
    h.slid(1) = uicontrol(<span class="string">'Parent'</span>,h.fig, <span class="string">'Style'</span>,<span class="string">'slider'</span>, <span class="keyword">...</span>
        <span class="string">'Value'</span>,p.yg, <span class="string">'Min'</span>,150, <span class="string">'Max'</span>,350, <span class="string">'SliderStep'</span>,[2 20]./(350-150), <span class="keyword">...</span>
        <span class="string">'Position'</span>,[105 5 sz(2)-105-5 20]);
    h.slid(2) = uicontrol(<span class="string">'Parent'</span>,h.fig, <span class="string">'Style'</span>,<span class="string">'slider'</span>, <span class="keyword">...</span>
        <span class="string">'Value'</span>,p.xg, <span class="string">'Min'</span>,150, <span class="string">'Max'</span>,350, <span class="string">'SliderStep'</span>,[2 20]./(350-150), <span class="keyword">...</span>
        <span class="string">'Position'</span>,[105 30 sz(2)-105-5 20]);
    h.slid(3) = uicontrol(<span class="string">'Parent'</span>,h.fig, <span class="string">'Style'</span>,<span class="string">'slider'</span>, <span class="keyword">...</span>
        <span class="string">'Value'</span>,p.origin, <span class="string">'Min'</span>,0, <span class="string">'Max'</span>,100, <span class="string">'SliderStep'</span>,[1 10]./(100-0), <span class="keyword">...</span>
        <span class="string">'Position'</span>,[105 55 sz(2)-105-5 20]);
    h.slid(4) = uicontrol(<span class="string">'Parent'</span>,h.fig, <span class="string">'Style'</span>,<span class="string">'slider'</span>, <span class="keyword">...</span>
        <span class="string">'Value'</span>,p.scale, <span class="string">'Min'</span>,5, <span class="string">'Max'</span>,50, <span class="string">'SliderStep'</span>,[1 5]./(50-5), <span class="keyword">...</span>
        <span class="string">'Position'</span>,[105 80 sz(2)-105-5 20]);
    h.slid(5) = uicontrol(<span class="string">'Parent'</span>,h.fig, <span class="string">'Style'</span>,<span class="string">'slider'</span>, <span class="keyword">...</span>
        <span class="string">'Value'</span>,p.angle, <span class="string">'Min'</span>,0, <span class="string">'Max'</span>,360, <span class="string">'SliderStep'</span>,[2 20]./(360-0), <span class="keyword">...</span>
        <span class="string">'Position'</span>,[105 105 sz(2)-105-5 20]);
    h.slid(6) = uicontrol(<span class="string">'Parent'</span>,h.fig, <span class="string">'Style'</span>,<span class="string">'slider'</span>, <span class="keyword">...</span>
        <span class="string">'Value'</span>,p.levelNoise, <span class="string">'Min'</span>,0, <span class="string">'Max'</span>,20, <span class="string">'SliderStep'</span>,[1 5]./(20-0), <span class="keyword">...</span>
        <span class="string">'Position'</span>,[105 130 sz(2)-105-5 20]);

    <span class="comment">% hook event handlers, and trigger default start</span>
    opts = {<span class="string">'Interruptible'</span>,<span class="string">'off'</span>, <span class="string">'BusyAction'</span>,<span class="string">'cancel'</span>};
    set(h.slid, <span class="string">'Callback'</span>,{@onChange,h}, opts{:});
    onChange([],[],h);
<span class="keyword">end</span></pre><pre class="codeoutput">Transform: t=[0.0574 0.819 0.497 -55.6 60.9]
 Origin = 1.779683, expected 3 (31)
 Angle  = 46.904017, expected 45
 Scale  = 0.497066, expected 0.5
</pre><img src="fourier_descriptors_demo_gui_01.png"><div class="footer">
            <p><a href="https://www.mathworks.com/products/matlab.html">Published with MATLAB&reg; R2017a</a></p>
         </div>
      </div>
      <!--
##### SOURCE BEGIN #####
%% Fourier Descriptors Demo
% Demostrates using Fourier descriptors for contour matching.
%
% Sources
%
% * <https://github.com/opencv/opencv_contrib/blob/3.4.0/modules/ximgproc/samples/fourier_descriptors_demo.cpp>
%

function varargout = fourier_descriptors_demo_gui()
    % create the UI
    h = buildGUI();
    if nargout > 0, varargout{1} = h; end
end

function out = noisyPolygon(pts, noise)
    if noise == 0
        out = pts;
        return;
    end
    try
        % we want reproducible random numbers
        rng('default')
    end
    pts = pts + (rand(size(pts)) * 2*noise - noise);
    out = pts(1,:);
    for i=1:size(pts,1)
        next = i + 1;
        if next > size(pts,1), next = 1; end
        u = pts(next,:) - pts(i,:);
        d = norm(u);
        a = atan2(u(2), u(1));
        step = max(d/noise, 1);
        for j=1:step:d
            pAct = u * j/d;
            r = rand() * noise;
            theta = a + rand()*2*pi;
            pNew = r*[cos(theta), sin(theta)] + pAct + pts(i,:);
            out(end+1,:) = pNew;
        end
    end
    out = fix(out);
end

function img = FDCurveMatching(p)
    % reference shape with 5 vertices
    ctr0 = [250 250; 400 250; 400 300; 250 300; 180 270];

    % noisy shape, transformed (rotate and scale)
    M = cv.getRotationMatrix2D([p.xg, p.yg], p.angle, 10/p.scale);
    ctr1 = noisyPolygon(ctr0, p.levelNoise);
    ctr1 = permute(cv.transform(permute(ctr1, [1 3 2]), M), [1 3 2]);

    % phase-shift (i.e same order just different starting point)
    n = size(ctr1,1);
    orig = fix(p.origin/100 * n);
    ctr1 = circshift(ctr1, orig, 1);

    % estimate transformation
    if true
        obj = cv.ContourFitting('FDSize',16, 'CtrSize',256);
        t = obj.estimateTransformation(ctr1, ctr0, 'FD',false);
    else
        % explicit contour sampling with 256 points
        ctr0s = cv.ContourFitting.contourSampling(ctr0, 256);
        ctr1s = cv.ContourFitting.contourSampling(ctr1, 256);
        obj = cv.ContourFitting('FDSize',16);
        t = obj.estimateTransformation(ctr1s, ctr0s, 'FD',false);
    end

    % fix t values to same range as ours: origin in (0,1)*n, angle in (0,360)
    if t(1) < 0, t(1) = 1 + t(1); end
    if t(2) < 0, t(2) = 2*pi + t(2); end
    fprintf('Transform: t=%s\n', mat2str(t,3));
    fprintf(' Origin = %f, expected %d (%d)\n', t(1)*n, orig, n);
    fprintf(' Angle  = %f, expected %d\n', t(2)*180/pi, p.angle);
    fprintf(' Scale  = %f, expected %g\n', t(3), p.scale/10);

    % apply estimated transformation to bring noisy shape to reference shape
    ctr2 = cv.ContourFitting.transformFD(ctr1, t, 'FD',false);
    ctr2 = cat(1, ctr2{:});

    % draw the three contours
    C = {ctr0, ctr1, ctr2};
    clr = [255 0 0; 0 255 0; 0 255 255];
    txt = {'reference', 'noisy', 'recovered'};

    % output image size
    rect = [0 0 500 500];
    if false
        for i=1:numel(C)
            rect = cv.Rect.union(rect, cv.boundingRect(C{i}));
        end
    end

    img = zeros([rect(3:4) 3], 'uint8');
    for i=1:numel(C)
        % legend
        img = cv.putText(img, txt{i}, [10 20*i], ...
            'Color',round(clr(i,:)*0.8), 'FontScale',0.5);
        % contour
        img = cv.drawContours(img, C{i}, 'Color',clr(i,:));
        % starting point
        img = cv.circle(img, C{i}(1,:), 5, 'Color',clr(i,:));
    end
end

function onChange(~,~,h)
    %ONCHANGE  Event handler for UI controls

    % retrieve current values from UI controls
    p = struct();
    p.levelNoise = round(get(h.slid(6), 'Value'));
    p.angle = round(get(h.slid(5), 'Value'));
    p.scale = round(get(h.slid(4), 'Value'));
    p.origin = round(get(h.slid(3), 'Value'));
    p.xg = round(get(h.slid(2), 'Value'));
    p.yg = round(get(h.slid(1), 'Value'));
    set(h.txt(1), 'String',sprintf('Yg: %d',p.yg));
    set(h.txt(2), 'String',sprintf('Xg: %d',p.xg));
    set(h.txt(3), 'String',sprintf('Origin%%: %d',p.origin));
    set(h.txt(4), 'String',sprintf('Scale: %d',p.scale));
    set(h.txt(5), 'String',sprintf('Angle: %d',p.angle));
    set(h.txt(6), 'String',sprintf('Noise: %d',p.levelNoise));

    % perform contour matching using Fourier descriptors
    img = FDCurveMatching(p);

    % show result
    set(h.img, 'CData',img);
    drawnow;
end

function h = buildGUI()
    %BUILDGUI  Creates the UI

    % canvas
    img = zeros([500 500 3], 'uint8');
    sz = size(img);

    % initial params
    % (a 45 degree rotation centered at [250,250] with a scaling of 5/10)
    p = struct();
    p.levelNoise = 6;
    p.angle = 45;
    p.scale = 5;
    p.origin = 10;
    p.xg = 250;
    p.yg = 250;

    % build the user interface (no resizing to keep it simple)
    h = struct();
    h.fig = figure('Name','FD Curve matching', ...
        'NumberTitle','off', 'Menubar','none', 'Resize','off', ...
        'Position',[200 200 sz(2) sz(1)+155-1]);
    if ~mexopencv.isOctave()
        %HACK: not implemented in Octave
        movegui(h.fig, 'center');
    end
    h.ax = axes('Parent',h.fig, 'Units','pixels', 'Position',[1 155 sz(2) sz(1)]);
    if ~mexopencv.isOctave()
        h.img = imshow(img, 'Parent',h.ax);
    else
        %HACK: https://savannah.gnu.org/bugs/index.php?45473
        axes(h.ax);
        h.img = imshow(img);
    end
    h.txt(1) = uicontrol('Parent',h.fig, 'Style','text', 'FontSize',11, ...
        'Position',[5 5 100 20], 'String',sprintf('Yg: %d',p.yg));
    h.txt(2) = uicontrol('Parent',h.fig, 'Style','text', 'FontSize',11, ...
        'Position',[5 30 100 20], 'String',sprintf('Xg: %d',p.xg));
    h.txt(3) = uicontrol('Parent',h.fig, 'Style','text', 'FontSize',11, ...
        'Position',[5 55 100 20], 'String',sprintf('Origin%%: %d',p.origin));
    h.txt(4) = uicontrol('Parent',h.fig, 'Style','text', 'FontSize',11, ...
        'Position',[5 80 100 20], 'String',sprintf('Scale: %d',p.scale));
    h.txt(5) = uicontrol('Parent',h.fig, 'Style','text', 'FontSize',11, ...
        'Position',[5 105 100 20], 'String',sprintf('Angle: %d',p.angle));
    h.txt(6) = uicontrol('Parent',h.fig, 'Style','text', 'FontSize',11, ...
        'Position',[5 130 100 20], 'String',sprintf('Noise: %d',p.levelNoise));
    h.slid(1) = uicontrol('Parent',h.fig, 'Style','slider', ...
        'Value',p.yg, 'Min',150, 'Max',350, 'SliderStep',[2 20]./(350-150), ...
        'Position',[105 5 sz(2)-105-5 20]);
    h.slid(2) = uicontrol('Parent',h.fig, 'Style','slider', ...
        'Value',p.xg, 'Min',150, 'Max',350, 'SliderStep',[2 20]./(350-150), ...
        'Position',[105 30 sz(2)-105-5 20]);
    h.slid(3) = uicontrol('Parent',h.fig, 'Style','slider', ...
        'Value',p.origin, 'Min',0, 'Max',100, 'SliderStep',[1 10]./(100-0), ...
        'Position',[105 55 sz(2)-105-5 20]);
    h.slid(4) = uicontrol('Parent',h.fig, 'Style','slider', ...
        'Value',p.scale, 'Min',5, 'Max',50, 'SliderStep',[1 5]./(50-5), ...
        'Position',[105 80 sz(2)-105-5 20]);
    h.slid(5) = uicontrol('Parent',h.fig, 'Style','slider', ...
        'Value',p.angle, 'Min',0, 'Max',360, 'SliderStep',[2 20]./(360-0), ...
        'Position',[105 105 sz(2)-105-5 20]);
    h.slid(6) = uicontrol('Parent',h.fig, 'Style','slider', ...
        'Value',p.levelNoise, 'Min',0, 'Max',20, 'SliderStep',[1 5]./(20-0), ...
        'Position',[105 130 sz(2)-105-5 20]);

    % hook event handlers, and trigger default start
    opts = {'Interruptible','off', 'BusyAction','cancel'};
    set(h.slid, 'Callback',{@onChange,h}, opts{:});
    onChange([],[],h);
end

##### SOURCE END #####
-->
   </body>
</html>