<!DOCTYPE html>
<html>
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   
      <!--This HTML was auto-generated from published MATLAB code.-->
      <title>Optical flow evaluation demo</title>
      <meta name="generator" content="MATLAB 9.2">
      <link rel="schema.DC" href="http://purl.org/dc/elements/1.1/">
      <meta name="DC.date" content="2017-11-27">
      <meta name="DC.source" content="optical_flow_evaluation_demo.m">
      <link rel="stylesheet" type="text/css" href="publish_custom.css">
   </head>
   <body>
      <div class="content">
         <h1 id="1">Optical flow evaluation demo</h1>
         <!--introduction-->
         <p>Computes flow field between two images using various methods and display it (deepflow, simpleflow, sparsetodenseflow, Farneback,
            TV-L1).
         </p>
         <p>Sources:</p>
         <div>
            <ul>
               <li><a href="https://github.com/opencv/opencv_contrib/blob/3.1.0/modules/optflow/samples/optical_flow_evaluation.cpp">https://github.com/opencv/opencv_contrib/blob/3.1.0/modules/optflow/samples/optical_flow_evaluation.cpp</a></li>
            </ul>
         </div>
         <!--/introduction-->
         <h2 id="toc">Contents</h2>
         <div>
            <ul>
               <li><a href="#2">Input images</a></li>
               <li><a href="#3">Compare the different methods</a></li>
            </ul>
         </div>
         <h2 id="2">Input images</h2>
         <p>a pair of 8-bit color images</p><pre class="codeinput">im1 = imread(fullfile(mexopencv.root(),<span class="string">'test'</span>,<span class="string">'RubberWhale1.png'</span>));
im2 = imread(fullfile(mexopencv.root(),<span class="string">'test'</span>,<span class="string">'RubberWhale2.png'</span>));
assert(isequal(size(im1), size(im2)), <span class="keyword">...</span>
    <span class="string">'Dimension mismatch between input images'</span>);
<span class="keyword">if</span> ~mexopencv.isOctave() &amp;&amp; mexopencv.require(<span class="string">'images'</span>)
    <span class="comment">%HACK: IMSHOWPAIR not implemented in Octave</span>
    imshowpair(im1, im2);
<span class="keyword">end</span></pre><img src="optical_flow_evaluation_demo_01.png"><h2 id="3">Compare the different methods</h2><pre class="codeinput">algorithms = {<span class="string">'farneback'</span>, <span class="string">'simpleflow'</span>, <span class="string">'tvl1'</span>, <span class="string">'deepflow'</span>, <span class="keyword">...</span>
    <span class="string">'sparsetodenseflow'</span>, <span class="string">'pcaflow'</span>, <span class="keyword">...</span>
    <span class="string">'DISflow_ultrafast'</span>, <span class="string">'DISflow_fast'</span>, <span class="string">'DISflow_medium'</span>, <span class="string">'variational'</span>};
<span class="keyword">for</span> i=1:numel(algorithms)
    <span class="comment">% prepare images</span>
    <span class="keyword">if</span> any(strcmp(algorithms{i}, {<span class="string">'farneback'</span>, <span class="string">'tvl1'</span>, <span class="string">'deepflow'</span>, <span class="keyword">...</span>
            <span class="string">'DISflow_ultrafast'</span>, <span class="string">'DISflow_fast'</span>, <span class="string">'DISflow_medium'</span>, <span class="keyword">...</span>
            <span class="string">'variational'</span>})) &amp;&amp; size(im1,3)==3
        <span class="comment">% 1-channel images are expected</span>
        img1 = cv.cvtColor(im1, <span class="string">'RGB2GRAY'</span>);
        img2 = cv.cvtColor(im2, <span class="string">'RGB2GRAY'</span>);
    <span class="keyword">elseif</span> strcmp(algorithms{i}, <span class="string">'simpleflow'</span>) &amp;&amp; size(im1,3)==1
        <span class="comment">% 3-channel images expected</span>
        img1 = cv.cvtColor(im1, <span class="string">'GRAY2RGB'</span>);
        img2 = cv.cvtColor(im2, <span class="string">'GRAY2RGB'</span>);
    <span class="keyword">else</span>
        <span class="comment">% sparsetodenseflow/pcaflow handle both 1- or 3-channels</span>
        img1 = im1;
        img2 = im2;
    <span class="keyword">end</span>

    <span class="comment">% compute flow field between img1 and img2 using current method</span>
    tic
    <span class="keyword">switch</span> lower(algorithms{i})
        <span class="keyword">case</span> <span class="string">'farneback'</span>
<span class="comment">            %{
</span><span class="comment">            obj = cv.FarnebackOpticalFlow();
</span><span class="comment">            flow = obj.calc(img1, img2);
</span><span class="comment">            %}
</span>            flow = cv.calcOpticalFlowFarneback(img1, img2);
        <span class="keyword">case</span> <span class="string">'simpleflow'</span>
            flow = cv.calcOpticalFlowSF(img1, img2);
        <span class="keyword">case</span> <span class="string">'deepflow'</span>
            flow = cv.calcOpticalFlowDF(img1, img2);
        <span class="keyword">case</span> <span class="string">'sparsetodenseflow'</span>
            flow = cv.calcOpticalFlowSparseToDense(img1, img2);
        <span class="keyword">case</span> <span class="string">'tvl1'</span>
            obj = cv.DualTVL1OpticalFlow();
            flow = obj.calc(img1, img2);
        <span class="keyword">case</span> <span class="string">'pcaflow'</span>
            <span class="comment">%obj = cv.OpticalFlowPCAFlow(prior);  % path to a prior file for PCAFlow</span>
            obj = cv.OpticalFlowPCAFlow();
            flow = obj.calc(img1, img2);
        <span class="keyword">case</span> <span class="string">'disflow_ultrafast'</span>
            obj = cv.DISOpticalFlow(<span class="string">'Preset'</span>,<span class="string">'UltraFast'</span>);
            flow = obj.calc(img1, img2);
        <span class="keyword">case</span> <span class="string">'disflow_fast'</span>
            obj = cv.DISOpticalFlow(<span class="string">'Preset'</span>,<span class="string">'Fast'</span>);
            flow = obj.calc(img1, img2);
        <span class="keyword">case</span> <span class="string">'disflow_medium'</span>
            obj = cv.DISOpticalFlow(<span class="string">'Preset'</span>,<span class="string">'Medium'</span>);
            flow = obj.calc(img1, img2);
        <span class="keyword">case</span> <span class="string">'variational'</span>
            obj = cv.VariationalRefinement();
            flow = obj.calc(img1, img2);
    <span class="keyword">end</span>
    fprintf(<span class="string">'%18s: '</span>, algorithms{i});
    toc

    <span class="comment">% display the flow</span>
    <span class="keyword">if</span> true
        [mag, ang] = cv.cartToPolar(flow(:,:,1), flow(:,:,2), <span class="string">'Degrees'</span>,true);
    <span class="keyword">else</span>
        [ang, mag] = cart2pol(flow(:,:,1), flow(:,:,2));
        <span class="keyword">if</span> mexopencv.isOctave()
            <span class="comment">%HACK: RAD2DEG not implemented in Octave</span>
            ang = (ang + pi) * (180 / pi);
        <span class="keyword">else</span>
            ang = rad2deg(ang + pi);
        <span class="keyword">end</span>
    <span class="keyword">end</span>
    mag = cv.normalize(mag, <span class="string">'Alpha'</span>,0, <span class="string">'Beta'</span>,1, <span class="string">'NormType'</span>,<span class="string">'MinMax'</span>);
    hsv = cat(3, ang, ones(size(ang),class(ang)), mag); <span class="comment">% H=[0,360], S,V=[0,1]</span>
    rgb = cv.cvtColor(hsv, <span class="string">'HSV2RGB'</span>);                  <span class="comment">% R,G,B=[0,1]</span>
    figure, imshow(rgb)
    title(sprintf(<span class="string">'Computed flow: %s'</span>,algorithms{i}), <span class="string">'Interpreter'</span>,<span class="string">'none'</span>)
<span class="keyword">end</span></pre><pre class="codeoutput">         farneback: Elapsed time is 0.201330 seconds.
        simpleflow: Elapsed time is 1.529157 seconds.
              tvl1: Elapsed time is 1.269737 seconds.
          deepflow: Elapsed time is 0.849141 seconds.
 sparsetodenseflow: Elapsed time is 0.341761 seconds.
           pcaflow: Elapsed time is 0.625318 seconds.
 DISflow_ultrafast: Elapsed time is 0.124396 seconds.
      DISflow_fast: Elapsed time is 0.020869 seconds.
    DISflow_medium: Elapsed time is 0.046709 seconds.
       variational: Elapsed time is 0.149174 seconds.
</pre><img src="optical_flow_evaluation_demo_02.png"><img src="optical_flow_evaluation_demo_03.png"><img src="optical_flow_evaluation_demo_04.png"><img src="optical_flow_evaluation_demo_05.png"><img src="optical_flow_evaluation_demo_06.png"><img src="optical_flow_evaluation_demo_07.png"><img src="optical_flow_evaluation_demo_08.png"><img src="optical_flow_evaluation_demo_09.png"><img src="optical_flow_evaluation_demo_10.png"><img src="optical_flow_evaluation_demo_11.png"><div class="footer">
            <p><a href="https://www.mathworks.com/products/matlab.html">Published with MATLAB&reg; R2017a</a></p>
         </div>
      </div>
      <!--
##### SOURCE BEGIN #####
%% Optical flow evaluation demo
%
% Computes flow field between two images using various methods and display it
% (deepflow, simpleflow, sparsetodenseflow, Farneback, TV-L1).
%
% Sources:
%
% * <https://github.com/opencv/opencv_contrib/blob/3.1.0/modules/optflow/samples/optical_flow_evaluation.cpp>
%

%% Input images
% a pair of 8-bit color images
im1 = imread(fullfile(mexopencv.root(),'test','RubberWhale1.png'));
im2 = imread(fullfile(mexopencv.root(),'test','RubberWhale2.png'));
assert(isequal(size(im1), size(im2)), ...
    'Dimension mismatch between input images');
if ~mexopencv.isOctave() && mexopencv.require('images')
    %HACK: IMSHOWPAIR not implemented in Octave
    imshowpair(im1, im2);
end

%% Compare the different methods
algorithms = {'farneback', 'simpleflow', 'tvl1', 'deepflow', ...
    'sparsetodenseflow', 'pcaflow', ...
    'DISflow_ultrafast', 'DISflow_fast', 'DISflow_medium', 'variational'};
for i=1:numel(algorithms)
    % prepare images
    if any(strcmp(algorithms{i}, {'farneback', 'tvl1', 'deepflow', ...
            'DISflow_ultrafast', 'DISflow_fast', 'DISflow_medium', ...
            'variational'})) && size(im1,3)==3
        % 1-channel images are expected
        img1 = cv.cvtColor(im1, 'RGB2GRAY');
        img2 = cv.cvtColor(im2, 'RGB2GRAY');
    elseif strcmp(algorithms{i}, 'simpleflow') && size(im1,3)==1
        % 3-channel images expected
        img1 = cv.cvtColor(im1, 'GRAY2RGB');
        img2 = cv.cvtColor(im2, 'GRAY2RGB');
    else
        % sparsetodenseflow/pcaflow handle both 1- or 3-channels
        img1 = im1;
        img2 = im2;
    end

    % compute flow field between img1 and img2 using current method
    tic
    switch lower(algorithms{i})
        case 'farneback'
            %{
            obj = cv.FarnebackOpticalFlow();
            flow = obj.calc(img1, img2);
            %}
            flow = cv.calcOpticalFlowFarneback(img1, img2);
        case 'simpleflow'
            flow = cv.calcOpticalFlowSF(img1, img2);
        case 'deepflow'
            flow = cv.calcOpticalFlowDF(img1, img2);
        case 'sparsetodenseflow'
            flow = cv.calcOpticalFlowSparseToDense(img1, img2);
        case 'tvl1'
            obj = cv.DualTVL1OpticalFlow();
            flow = obj.calc(img1, img2);
        case 'pcaflow'
            %obj = cv.OpticalFlowPCAFlow(prior);  % path to a prior file for PCAFlow
            obj = cv.OpticalFlowPCAFlow();
            flow = obj.calc(img1, img2);
        case 'disflow_ultrafast'
            obj = cv.DISOpticalFlow('Preset','UltraFast');
            flow = obj.calc(img1, img2);
        case 'disflow_fast'
            obj = cv.DISOpticalFlow('Preset','Fast');
            flow = obj.calc(img1, img2);
        case 'disflow_medium'
            obj = cv.DISOpticalFlow('Preset','Medium');
            flow = obj.calc(img1, img2);
        case 'variational'
            obj = cv.VariationalRefinement();
            flow = obj.calc(img1, img2);
    end
    fprintf('%18s: ', algorithms{i});
    toc

    % display the flow
    if true
        [mag, ang] = cv.cartToPolar(flow(:,:,1), flow(:,:,2), 'Degrees',true);
    else
        [ang, mag] = cart2pol(flow(:,:,1), flow(:,:,2));
        if mexopencv.isOctave()
            %HACK: RAD2DEG not implemented in Octave
            ang = (ang + pi) * (180 / pi);
        else
            ang = rad2deg(ang + pi);
        end
    end
    mag = cv.normalize(mag, 'Alpha',0, 'Beta',1, 'NormType','MinMax');
    hsv = cat(3, ang, ones(size(ang),class(ang)), mag); % H=[0,360], S,V=[0,1]
    rgb = cv.cvtColor(hsv, 'HSV2RGB');                  % R,G,B=[0,1]
    figure, imshow(rgb)
    title(sprintf('Computed flow: %s',algorithms{i}), 'Interpreter','none')
end

##### SOURCE END #####
-->
   </body>
</html>