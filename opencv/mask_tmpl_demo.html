<!DOCTYPE html>
<html>
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   
      <!--This HTML was auto-generated from published MATLAB code.-->
      <title>Template Matching</title>
      <meta name="generator" content="MATLAB 9.2">
      <link rel="schema.DC" href="http://purl.org/dc/elements/1.1/">
      <meta name="DC.date" content="2017-11-27">
      <meta name="DC.source" content="mask_tmpl_demo.m">
      <link rel="stylesheet" type="text/css" href="publish_custom.css">
   </head>
   <body>
      <div class="content">
         <h1 id="1">Template Matching</h1>
         <!--introduction-->
         <p>This program demonstrates template match with mask.</p>
         <p>In this demo, we show how to:</p>
         <div>
            <ul>
               <li>Use the OpenCV function <tt>cv.matchTemplate</tt> to search for matches between   an image patch and an input image
               </li>
               <li>Find the maximum and minimum values (as well as their positions) in a   given array.</li>
            </ul>
         </div>
         <p>Sources:</p>
         <div>
            <ul>
               <li><a href="https://github.com/opencv/opencv/blob/3.2.0/samples/cpp/mask_tmpl.cpp">https://github.com/opencv/opencv/blob/3.2.0/samples/cpp/mask_tmpl.cpp</a></li>
               <li><a href="https://docs.opencv.org/3.2.0/d4/dc6/tutorial_py_template_matching.html">https://docs.opencv.org/3.2.0/d4/dc6/tutorial_py_template_matching.html</a></li>
               <li><a href="https://docs.opencv.org/3.2.0/de/da9/tutorial_template_matching.html">https://docs.opencv.org/3.2.0/de/da9/tutorial_template_matching.html</a></li>
               <li><a href="https://github.com/opencv/opencv/blob/3.2.0/samples/cpp/tutorial_code/Histograms_Matching/MatchTemplate_Demo.cpp">https://github.com/opencv/opencv/blob/3.2.0/samples/cpp/tutorial_code/Histograms_Matching/MatchTemplate_Demo.cpp</a></li>
            </ul>
         </div>
         <!--/introduction-->
         <h2 id="toc">Contents</h2>
         <div>
            <ul>
               <li><a href="#2">Theory</a></li>
               <li><a href="#3">Code</a></li>
            </ul>
         </div>
         <h2 id="2">Theory</h2>
         <p>Template matching is a technique for finding areas of an image that match (are similar) to a template image (patch).</p>
         <p>While the patch must be a rectangle it may be that not all of the rectangle is relevant. In such a case, a mask can be used
            to isolate the portion of the patch that should be used to find the match.
         </p>
         <p>For template matching to work, we need two primary components:</p>
         <div>
            <ul>
               <li><b>Source image (<tt>I</tt>):</b> The image in which we expect to find a match to the   template image
               </li>
               <li><b>Template image (<tt>T</tt>):</b> The patch image which will be compared to the   template image
               </li>
            </ul>
         </div>
         <p>our goal is to detect the highest matching area:</p>
         <p><img src="https://docs.opencv.org/3.2.0/Template_Matching_Template_Theory_Summary.jpg"></p>
         <p>To identify the matching area, we have to <i>compare</i> the template image against the source image by sliding it:
         </p>
         <p><img src="https://docs.opencv.org/3.2.0/Template_Matching_Template_Theory_Sliding.jpg"></p>
         <p>By <b>sliding</b>, we mean moving the patch one pixel at a time (left to right, up to down). At each location, a metric is calculated so it
            represents how "good" or "bad" the match at that location is (or how similar the patch is to that particular area of the source
            image). For each location of <tt>T</tt> over <tt>I</tt>, you <i>store</i> the metric in the <i>result matrix</i><tt>R</tt>. Each location <img src="mask_tmpl_demo_eq18047527249248817779.png" alt="$(x,y)$" class="equation" width="32" height="15"> in <tt>R</tt> contains the match metric:
         </p>
         <p><img src="https://docs.opencv.org/3.2.0/Template_Matching_Template_Theory_Result.jpg"></p>
         <p>the image above is the result <tt>R</tt> of sliding the patch with a metric <tt>CCorrNormed</tt>. The brightest locations indicate the highest matches. As you can see, the location marked by the red circle is probably
            the one with the highest value, so that location (the rectangle formed by that point as a corner and width and height equal
            to the patch image) is considered the match.
         </p>
         <p>In practice, we locate the highest value (or lower, depending of the type of matching method) in the <i>R</i> matrix, using the <tt>min</tt>, <tt>max</tt>, and <tt>find</tt> functions.
         </p>
         <p>If masking is needed for the match, three components are required:</p>
         <div>
            <ul>
               <li><b>Source image (<tt>I</tt>):</b> The image in which we expect to find a match to the   template image
               </li>
               <li><b>Template image (<tt>T</tt>):</b> The patch image which will be compared to the   template image
               </li>
               <li><b>Mask image (<tt>M</tt>):</b> The mask, a grayscale image that masks the template
               </li>
            </ul>
         </div>
         <p>Only two matching methods currently accept a mask: <tt>SqDiff</tt> and <tt>CCorrNormed</tt> (see below for explanation of all the matching methods available in opencv).
         </p>
         <p>The mask must have the same dimensions as the template. The mask should have a <tt>uint8</tt> or <tt>single</tt> depth and the same number of channels as the template image. In <tt>uint8</tt> case, the mask values are treated as binary, i.e. zero and non-zero. In <tt>single</tt> case, the values should fall into [0..1] range and the template pixels will be multiplied by the corresponding mask pixel
            values. Since the input images in the sample are 3-channels, the mask is also read as color image.
         </p>
         <p><img src="https://docs.opencv.org/3.2.0/Template_Matching_Mask_Example.jpg"></p>
         <p>OpenCV implements template matching in the function <tt>cv.matchTemplate</tt>. There are six available methods:
         </p>
         <div>
            <ul>
               <li>Method = <tt>SqDiff</tt></li>
            </ul>
         </div>
         <p><img src="mask_tmpl_demo_eq04476806810723057735.png" alt="$$R(x,y) = \sum_{x',y'} (T(x',y')-I(x+x',y+y'))^2$$" class="equation" width="273" height="34"></p>
         <div>
            <ul>
               <li>Method = <tt>SqDiffNormed</tt></li>
            </ul>
         </div>
         <p><img src="mask_tmpl_demo_eq13173116149047383554.png" alt="$$R(x,y) = \frac{\sum_{x',y'} (T(x',y')-I(x+x',y+y'))^2}&#xA;  {\sqrt{\sum_{x',y'}T(x',y')^2 \cdot \sum_{x',y'} I(x+x',y+y')^2}}$$" class="equation" width="332" height="50"></p>
         <div>
            <ul>
               <li>Method = <tt>CCorr</tt></li>
            </ul>
         </div>
         <p><img src="mask_tmpl_demo_eq15853152117924923578.png" alt="$$R(x,y) = \sum_{x',y'} (T(x',y') \cdot I(x+x',y+y'))$$" class="equation" width="259" height="34"></p>
         <div>
            <ul>
               <li>Method = <tt>CCorrNormed</tt></li>
            </ul>
         </div>
         <p><img src="mask_tmpl_demo_eq07796196475765015114.png" alt="$$R(x,y) = \frac{\sum_{x',y'} (T(x',y') \cdot I(x+x',y+y'))}&#xA;  {\sqrt{\sum_{x',y'}T(x',y')^2 \cdot \sum_{x',y'} I(x+x',y+y')^2}}$$" class="equation" width="332" height="49"></p>
         <div>
            <ul>
               <li>Method = <tt>CCoeff</tt></li>
            </ul>
         </div>
         <p><img src="mask_tmpl_demo_eq09592043061891298683.png" alt="$$R(x,y) = \sum_{x',y'} (T'(x',y') \cdot I'(x+x',y+y'))$$" class="equation" width="266" height="34"></p>
         <p>where</p>
         <p><img src="mask_tmpl_demo_eq01549751497532272504.png" alt="$$T'(x',y') = T(x',y') - 1/(w \cdot h) \cdot \sum_{x'',y''} T(x'',y'')$$" class="equation" width="294" height="34"></p>
         <p>and</p>
         <p><img src="mask_tmpl_demo_eq01717272573545239291.png" alt="$$I'(x+x',y+y') = I(x+x',y+y') - 1/(w \cdot h) \cdot \sum_{x'',y''} I(x+x'',y+y'')$$" class="equation" width="440" height="34"></p>
         <div>
            <ul>
               <li>Method = <tt>CCoeffNormed</tt></li>
            </ul>
         </div>
         <p><img src="mask_tmpl_demo_eq08249905199835758747.png" alt="$$R(x,y) = \frac{ \sum_{x',y'} (T'(x',y') \cdot I'(x+x',y+y')) }&#xA;  { \sqrt{\sum_{x',y'}T'(x',y')^2 \cdot \sum_{x',y'} I'(x+x',y+y')^2} }$$" class="equation" width="339" height="49"></p>
         <h2 id="3">Code</h2>
         <p>This program:</p>
         <div>
            <ul>
               <li>Loads an input image, an image patch (<i>template</i>), and optionally a mask
               </li>
               <li>Perform a template matching procedure by using the OpenCV function   <tt>cv.matchTemplate</tt> with any of the 6 matching methods described before.   The user can choose the desired method. If a mask is supplied, it
                  will   only be used for the methods that support masking
               </li>
               <li>Localize the location with higher matching probability</li>
               <li>Draw a rectangle around the area corresponding to the highest match</li>
            </ul>
         </div>
         <p>Load Images</p><pre class="codeinput"><span class="keyword">if</span> mexopencv.isOctave()
    img = cv.imread(fullfile(mexopencv.root(),<span class="string">'test'</span>,<span class="string">'lena_tmpl.jpg'</span>));
    tmpl = cv.imread(fullfile(mexopencv.root(),<span class="string">'test'</span>,<span class="string">'tmpl.png'</span>));
    mask = cv.imread(fullfile(mexopencv.root(),<span class="string">'test'</span>,<span class="string">'mask.png'</span>), <span class="string">'Color'</span>,true);
    assert(isequal(size(tmpl), size(mask)));
    opts = {<span class="string">'Mask'</span>,mask};
<span class="keyword">else</span>
    img = imread(which(<span class="string">'peppers.png'</span>));
    tmpl = imread(which(<span class="string">'onion.png'</span>));
    opts = {};
<span class="keyword">end</span></pre><p>Template Matching</p><pre class="codeinput">method = <span class="string">'CCorrNormed'</span>;  <span class="comment">% 'SqDiff'</span>
res = cv.matchTemplate(img, tmpl, <span class="string">'Method'</span>,method, opts{:});
surf(res), shading <span class="string">flat</span>
title(<span class="string">'normalized cross correlation'</span>)</pre><img src="mask_tmpl_demo_01.png"><p>Find global optimum in result</p><pre class="codeinput"><span class="keyword">switch</span> method
    <span class="keyword">case</span> {<span class="string">'SqDiff'</span>, <span class="string">'SqDiffNormed'</span>}
        [val,idx] = min(res(:));
    <span class="keyword">otherwise</span>
        [val,idx] = max(res(:));
<span class="keyword">end</span>
<span class="keyword">if</span> true
    [y,x] = ind2sub(size(res), idx);
<span class="keyword">else</span>
    [y,x] = find(res == val);
<span class="keyword">end</span>
[h,w,~] = size(tmpl);
rect = [x y w h];</pre><p>Display matched area</p><pre class="codeinput">out = cv.rectangle(img, rect, <span class="string">'Color'</span>,[0 255 0], <span class="string">'Thickness'</span>,2);

figure
subplot(221), imshow(img), title(<span class="string">'image'</span>)
subplot(222), imshow(tmpl), title(<span class="string">'template'</span>)
subplot(223), imshow(res,[]), title({<span class="string">'matching result'</span>, method})
subplot(224), imshow(out), title(<span class="string">'detected template'</span>)</pre><img src="mask_tmpl_demo_02.png"><div class="footer">
            <p><a href="https://www.mathworks.com/products/matlab.html">Published with MATLAB&reg; R2017a</a></p>
         </div>
      </div><script type="text/x-mathjax-config">
  // https://stackoverflow.com/a/14631703/97160
  MathJax.Extension.myImg2jax = {
    version: "1.0",
    PreProcess: function (element) {
      var images = element.getElementsByTagName("img");
      for (var i = images.length - 1; i >= 0; i--) {
        var img = images[i];
        if (img.className === "equation") {
          var match = img.alt.match(/^(\$\$?)([\s\S]*)\1$/m);
          if (!match) continue;
          var script = document.createElement("script");
          script.type = "math/tex";
          if (match[1] === "$$") {script.type += ";mode=display"}
          MathJax.HTML.setScript(script, match[2]);
          img.parentNode.replaceChild(script, img);
        }
      }
    }
  };
  MathJax.Hub.Register.PreProcessor(["PreProcess", MathJax.Extension.myImg2jax]);
  </script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-AMS_CHTML"></script>
      <!--
##### SOURCE BEGIN #####
%% Template Matching
% This program demonstrates template match with mask.
%
% In this demo, we show how to:
%
% * Use the OpenCV function |cv.matchTemplate| to search for matches between
%   an image patch and an input image
% * Find the maximum and minimum values (as well as their positions) in a
%   given array.
%
% Sources:
%
% * <https://github.com/opencv/opencv/blob/3.2.0/samples/cpp/mask_tmpl.cpp>
% * <https://docs.opencv.org/3.2.0/d4/dc6/tutorial_py_template_matching.html>
% * <https://docs.opencv.org/3.2.0/de/da9/tutorial_template_matching.html>
% * <https://github.com/opencv/opencv/blob/3.2.0/samples/cpp/tutorial_code/Histograms_Matching/MatchTemplate_Demo.cpp>
%

%% Theory
%
% Template matching is a technique for finding areas of an image that match
% (are similar) to a template image (patch).
%
% While the patch must be a rectangle it may be that not all of the rectangle
% is relevant. In such a case, a mask can be used to isolate the portion of
% the patch that should be used to find the match.
%
% For template matching to work, we need two primary components:
%
% * *Source image (|I|):* The image in which we expect to find a match to the
%   template image
% * *Template image (|T|):* The patch image which will be compared to the
%   template image
%
% our goal is to detect the highest matching area:
%
% <<https://docs.opencv.org/3.2.0/Template_Matching_Template_Theory_Summary.jpg>>
%
% To identify the matching area, we have to _compare_ the template image
% against the source image by sliding it:
%
% <<https://docs.opencv.org/3.2.0/Template_Matching_Template_Theory_Sliding.jpg>>
%
% By *sliding*, we mean moving the patch one pixel at a time (left to right,
% up to down). At each location, a metric is calculated so it represents how
% "good" or "bad" the match at that location is (or how similar the patch is
% to that particular area of the source image).
% For each location of |T| over |I|, you _store_ the metric in the
% _result matrix_ |R|. Each location $(x,y)$ in |R| contains the match metric:
%
% <<https://docs.opencv.org/3.2.0/Template_Matching_Template_Theory_Result.jpg>>
%
% the image above is the result |R| of sliding the patch with a metric
% |CCorrNormed|. The brightest locations indicate the highest matches. As you
% can see, the location marked by the red circle is probably the one with the
% highest value, so that location (the rectangle formed by that point as a
% corner and width and height equal to the patch image) is considered the
% match.
%
% In practice, we locate the highest value (or lower, depending of the type of
% matching method) in the _R_ matrix, using the |min|, |max|, and |find|
% functions.
%
% If masking is needed for the match, three components are required:
%
% * *Source image (|I|):* The image in which we expect to find a match to the
%   template image
% * *Template image (|T|):* The patch image which will be compared to the
%   template image
% * *Mask image (|M|):* The mask, a grayscale image that masks the template
%
% Only two matching methods currently accept a mask: |SqDiff| and
% |CCorrNormed| (see below for explanation of all the matching methods
% available in opencv).
%
% The mask must have the same dimensions as the template. The mask should have
% a |uint8| or |single| depth and the same number of channels as the template
% image. In |uint8| case, the mask values are treated as binary, i.e. zero and
% non-zero. In |single| case, the values should fall into [0..1] range and the
% template pixels will be multiplied by the corresponding mask pixel values.
% Since the input images in the sample are 3-channels, the mask is also read
% as color image.
%
% <<https://docs.opencv.org/3.2.0/Template_Matching_Mask_Example.jpg>>
%
% OpenCV implements template matching in the function |cv.matchTemplate|.
% There are six available methods:
%
% * Method = |SqDiff|
%
% $$R(x,y) = \sum_{x',y'} (T(x',y')-I(x+x',y+y'))^2$$
%
% * Method = |SqDiffNormed|
%
% $$R(x,y) = \frac{\sum_{x',y'} (T(x',y')-I(x+x',y+y'))^2}
%   {\sqrt{\sum_{x',y'}T(x',y')^2 \cdot \sum_{x',y'} I(x+x',y+y')^2}}$$
%
% * Method = |CCorr|
%
% $$R(x,y) = \sum_{x',y'} (T(x',y') \cdot I(x+x',y+y'))$$
%
% * Method = |CCorrNormed|
%
% $$R(x,y) = \frac{\sum_{x',y'} (T(x',y') \cdot I(x+x',y+y'))}
%   {\sqrt{\sum_{x',y'}T(x',y')^2 \cdot \sum_{x',y'} I(x+x',y+y')^2}}$$
%
% * Method = |CCoeff|
%
% $$R(x,y) = \sum_{x',y'} (T'(x',y') \cdot I'(x+x',y+y'))$$
%
% where
%
% $$T'(x',y') = T(x',y') - 1/(w \cdot h) \cdot \sum_{x'',y''} T(x'',y'')$$
%
% and
%
% $$I'(x+x',y+y') = I(x+x',y+y') - 1/(w \cdot h) \cdot \sum_{x'',y''} I(x+x'',y+y'')$$
%
% * Method = |CCoeffNormed|
%
% $$R(x,y) = \frac{ \sum_{x',y'} (T'(x',y') \cdot I'(x+x',y+y')) }
%   { \sqrt{\sum_{x',y'}T'(x',y')^2 \cdot \sum_{x',y'} I'(x+x',y+y')^2} }$$
%

%% Code
%
% This program:
%
% * Loads an input image, an image patch (_template_), and optionally a mask
% * Perform a template matching procedure by using the OpenCV function
%   |cv.matchTemplate| with any of the 6 matching methods described before.
%   The user can choose the desired method. If a mask is supplied, it will
%   only be used for the methods that support masking
% * Localize the location with higher matching probability
% * Draw a rectangle around the area corresponding to the highest match
%

%%
% Load Images
if mexopencv.isOctave()
    img = cv.imread(fullfile(mexopencv.root(),'test','lena_tmpl.jpg'));
    tmpl = cv.imread(fullfile(mexopencv.root(),'test','tmpl.png'));
    mask = cv.imread(fullfile(mexopencv.root(),'test','mask.png'), 'Color',true);
    assert(isequal(size(tmpl), size(mask)));
    opts = {'Mask',mask};
else
    img = imread(which('peppers.png'));
    tmpl = imread(which('onion.png'));
    opts = {};
end

%%
% Template Matching
method = 'CCorrNormed';  % 'SqDiff'
res = cv.matchTemplate(img, tmpl, 'Method',method, opts{:});
surf(res), shading flat
title('normalized cross correlation')

%%
% Find global optimum in result
switch method
    case {'SqDiff', 'SqDiffNormed'}
        [val,idx] = min(res(:));
    otherwise
        [val,idx] = max(res(:));
end
if true
    [y,x] = ind2sub(size(res), idx);
else
    [y,x] = find(res == val);
end
[h,w,~] = size(tmpl);
rect = [x y w h];

%%
% Display matched area
out = cv.rectangle(img, rect, 'Color',[0 255 0], 'Thickness',2);

figure
subplot(221), imshow(img), title('image')
subplot(222), imshow(tmpl), title('template')
subplot(223), imshow(res,[]), title({'matching result', method})
subplot(224), imshow(out), title('detected template')

##### SOURCE END #####
--></body>
</html>