<!DOCTYPE html>
<html>
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   
      <!--This HTML was auto-generated from published MATLAB code.-->
      <title>SVMSGD Interactive Classification</title>
      <meta name="generator" content="MATLAB 9.2">
      <link rel="schema.DC" href="http://purl.org/dc/elements/1.1/">
      <meta name="DC.date" content="2017-11-27">
      <meta name="DC.source" content="train_svmsgd_demo_gui.m">
      <link rel="stylesheet" type="text/css" href="publish_custom.css">
   </head>
   <body>
      <div class="content">
         <h1 id="1">SVMSGD Interactive Classification</h1>
         <p>Train with SVMSGD algorithm. The classifier can handle linearly separable 2-class dataset.</p>
         <p>Sources:</p>
         <div>
            <ul>
               <li><a href="https://github.com/opencv/opencv/blob/3.2.0/samples/cpp/train_svmsgd.cpp">https://github.com/opencv/opencv/blob/3.2.0/samples/cpp/train_svmsgd.cpp</a></li>
            </ul>
         </div><pre class="codeinput"><span class="keyword">function</span> varargout = train_svmsgd_demo_gui()
    <span class="comment">% data</span>
    sz = [594 841];  <span class="comment">% [height width]</span>
    samples = [];    <span class="comment">% Set of train samples. Contains points on image</span>
    responses = [];  <span class="comment">% Set of responses for train samples</span>

    <span class="comment">% create the UI</span>
    h = buildGUI();
    onHelp([],[]);   <span class="comment">% display instructions</span>
    <span class="keyword">if</span> nargout &gt; 0, varargout{1} = h; <span class="keyword">end</span>


    <span class="keyword">function</span> h = buildGUI()
        <span class="comment">%BUILDGUI  Creates the UI</span>

        h = struct();
        h.fig = figure(<span class="string">'Name'</span>,<span class="string">'Train SVMSGD'</span>, <span class="string">'Menubar'</span>,<span class="string">'none'</span>, <span class="keyword">...</span>
            <span class="string">'Position'</span>,[200 200 sz(2) sz(1)]);
        <span class="keyword">if</span> ~mexopencv.isOctave()
            <span class="comment">%HACK: not implemented in Octave</span>
            movegui(h.fig, <span class="string">'center'</span>);
        <span class="keyword">end</span>
        h.ax = axes(<span class="string">'Parent'</span>,h.fig, <span class="string">'Units'</span>,<span class="string">'normalized'</span>, <span class="string">'Position'</span>,[0 0 1 1]);
        img = zeros([sz 3], <span class="string">'uint8'</span>);
        <span class="keyword">if</span> ~mexopencv.isOctave()
            h.img = imshow(img, <span class="string">'Parent'</span>,h.ax);
        <span class="keyword">else</span>
            <span class="comment">%HACK: https://savannah.gnu.org/bugs/index.php?45473</span>
            axes(h.ax);
            h.img = imshow(img);
        <span class="keyword">end</span>

        <span class="comment">% register mouse button handlers and change cursor</span>
        set(h.fig, <span class="string">'Pointer'</span>,<span class="string">'cross'</span>, <span class="string">'WindowKeyPressFcn'</span>,@onType, <span class="keyword">...</span>
            <span class="string">'WindowButtonDownFcn'</span>,@onMouseDown);
    <span class="keyword">end</span>

    <span class="keyword">function</span> onHelp(~,~)
        <span class="comment">%ONHELP  Display usage help dialog</span>

        hd = helpdlg({
            <span class="string">'Left-click the mouse to add a positive sample.'</span>
            <span class="string">'Right-click the mouse to add a negative sample.'</span>
            <span class="string">'Hot keys:'</span>
            <span class="string">'  h: usage dialog'</span>
            <span class="string">'  r: reset'</span>
            <span class="string">'  s: save current output image as PNG image'</span>
            <span class="string">'  e: export current data as MAT-file'</span>
            <span class="string">'  q: quit the program'</span>
        }, <span class="string">'Interactive SVMSGD demo'</span>);
        set(hd, <span class="string">'WindowStyle'</span>,<span class="string">'modal'</span>);
    <span class="keyword">end</span>

    <span class="keyword">function</span> onReset(~,~)
        <span class="comment">%ONRESET  Restart from scratch</span>

        <span class="comment">% reset data</span>
        samples = [];
        responses = [];

        <span class="comment">% update plot</span>
        img = zeros([sz 3], <span class="string">'uint8'</span>);
        set(h.img, <span class="string">'CData'</span>,img);
        drawnow;
    <span class="keyword">end</span>

    <span class="keyword">function</span> onType(~,e)
        <span class="comment">%ONTYPE  Event handler for key press on figure</span>

        <span class="comment">% handle keys</span>
        <span class="keyword">switch</span> e.Key
            <span class="keyword">case</span> <span class="string">'r'</span>
                onReset([],[]);
            <span class="keyword">case</span> <span class="string">'h'</span>
                onHelp([],[]);
            <span class="keyword">case</span> <span class="string">'s'</span>
                fname = [tempname() <span class="string">'.png'</span>];
                imwrite(img, fname);
                fprintf(<span class="string">'Output saved as "%s"\n'</span>, fname);
            <span class="keyword">case</span> <span class="string">'e'</span>
                uisave({<span class="string">'samples'</span>, <span class="string">'responses'</span>}, <span class="string">'data.mat'</span>);
            <span class="keyword">case</span> {<span class="string">'q'</span>, <span class="string">'escape'</span>}
                close(h.fig);
        <span class="keyword">end</span>
    <span class="keyword">end</span>

    <span class="keyword">function</span> onMouseDown(~,~)
        <span class="comment">%ONMOUSEDOWN  Event handler for mouse down on figure</span>

        <span class="comment">% get current location of mouse pointer</span>
        p = get(h.ax, <span class="string">'CurrentPoint'</span>);
        p = round(p(1,1:2));

        <span class="comment">% add point to train set with corresponding positive/negative class</span>
        samples(end+1,:) = p;
        <span class="keyword">if</span> strcmp(get(h.fig,<span class="string">'SelectionType'</span>), <span class="string">'normal'</span>)
            responses(end+1) = +1;
        <span class="keyword">else</span>
            responses(end+1) = -1;
        <span class="keyword">end</span>

        <span class="comment">% process (train model and draw results on image)</span>
        [weights, shift] = doTrain(samples, responses(:));
        pts = doFindPointsForLine(sz, weights, shift);
        img = doRedraw(sz, samples, responses, pts);

        <span class="comment">% update plot</span>
        set(h.img, <span class="string">'CData'</span>,img);
        drawnow;
    <span class="keyword">end</span>
<span class="keyword">end</span>

<span class="keyword">function</span> [weights, shift] = doTrain(samples, responses)
    <span class="comment">%DOTRAIN  Train with SVMSGD algorithm</span>
    <span class="comment">%</span>
    <span class="comment">%     [weights, shift] = doTrain(samples, responses)</span>
    <span class="comment">%</span>
    <span class="comment">% ## Input</span>
    <span class="comment">% * __samples__, __responses__ train set</span>
    <span class="comment">%</span>
    <span class="comment">% ## Output</span>
    <span class="comment">% * __weights__, __shift__ vector of decision function of SVMSGD algorithm</span>
    <span class="comment">%</span>

    weights = [];
    shift = [];
    <span class="keyword">if</span> numel(unique(responses)) &lt; 2
        <span class="comment">% ensure we have at least one point from each class</span>
        <span class="keyword">return</span>;
    <span class="keyword">end</span>

    model = cv.SVMSGD();
    model.train(samples, responses);

    <span class="keyword">if</span> model.isTrained()
        weights = model.getWeights();
        shift = model.getShift();

        display(model)
        fprintf(<span class="string">'%f*x + %f*y + %f = 0\n'</span>, weights(1), weights(2), shift);
    <span class="keyword">end</span>
<span class="keyword">end</span>

<span class="keyword">function</span> pts = doFindPointsForLine(sz, weights, shift)
    <span class="comment">%DOFINDPOINTSFORLINE  Find two points for drawing decision function line (w*x = 0)</span>

    pts = [];
    <span class="keyword">if</span> isempty(weights)
        <span class="keyword">return</span>;
    <span class="keyword">end</span>

    <span class="comment">% axis-aligned border segments</span>
    segments = {
        [sz(2) 0; sz(2) sz(1)];  <span class="comment">% right</span>
        [0 sz(1); sz(2) sz(1)];  <span class="comment">% top</span>
        [0 0; sz(2) 0];          <span class="comment">% bottom</span>
        [0 0; 0 sz(1)]           <span class="comment">% left</span>
    };

    <span class="comment">% test intersection against each segment until we collect two points</span>
    <span class="keyword">for</span> i=1:numel(segments)
        pt = doFindCrossPointWithBorders(weights, shift, segments{i});
        <span class="keyword">if</span> ~isempty(pt)
            pts(end+1,:) = pt;
            <span class="keyword">if</span> size(pts,1) &gt;= 2
                <span class="keyword">return</span>;
            <span class="keyword">end</span>
        <span class="keyword">end</span>
    <span class="keyword">end</span>
<span class="keyword">end</span>

<span class="keyword">function</span> pt = doFindCrossPointWithBorders(weights, shift, seg)
    <span class="comment">%DOFINDCROSSPOINTWITHBORDERS  Find intersection of line (w*x = 0) and segment</span>
    <span class="comment">%</span>
    <span class="comment">% (y = HEIGHT, 0 &lt;= x &lt;= WIDTH) or (x = WIDTH, 0 &lt;= y &lt;= HEIGHT)</span>
    <span class="comment">%</span>
    <span class="comment">% decision function line equation: w(1)*x + w(2)*y + s = 0</span>
    <span class="comment">% border equations either x=c or y=c</span>
    <span class="comment">%</span>

    xmn = min(seg(:,1));
    xmx = max(seg(:,1));
    ymn = min(seg(:,2));
    ymx = max(seg(:,2));
    pt = [];
    <span class="keyword">if</span> xmn == xmx &amp;&amp; weights(2) ~= 0
        <span class="comment">% intersect with vertical border</span>
        x = xmn;
        y = floor(-(weights(1) * x + shift) / weights(2));
        <span class="keyword">if</span> ymn &lt;= y &amp;&amp; y &lt;= ymx
            pt = [x y];
        <span class="keyword">end</span>
    <span class="keyword">elseif</span> ymn == ymx &amp;&amp; weights(1) ~= 0
        <span class="comment">% intersect with horizontal border</span>
        y = ymn;
        x = floor(-(weights(2) * y + shift) / weights(1));
        <span class="keyword">if</span> xmn &lt;= x &amp;&amp; x &lt;= xmx
            pt = [x y];
        <span class="keyword">end</span>
    <span class="keyword">end</span>
<span class="keyword">end</span>

<span class="keyword">function</span> img = doRedraw(sz, samples, responses, pts)
    <span class="comment">%DOREDRAW  Redraw point set and decision function line (w*x = 0)</span>

    img = zeros([sz 3], <span class="string">'uint8'</span>);

    <span class="keyword">if</span> ~isempty(samples)
        img = cv.circle(img, samples(responses==+1,:), 6, <span class="keyword">...</span>
            <span class="string">'Color'</span>,[255 0 0], <span class="string">'Thickness'</span>,<span class="string">'Filled'</span>);
        img = cv.circle(img, samples(responses==-1,:), 6, <span class="keyword">...</span>
            <span class="string">'Color'</span>,[0 0 255], <span class="string">'Thickness'</span>,<span class="string">'Filled'</span>);
    <span class="keyword">end</span>

    <span class="keyword">if</span> ~isempty(pts)
        img = cv.line(img, pts(1,:), pts(2,:), <span class="string">'Color'</span>,[0 255 0]);
    <span class="keyword">end</span>
<span class="keyword">end</span></pre><img src="train_svmsgd_demo_gui_01.png"><img src="train_svmsgd_demo_gui_02.png"><div class="footer">
            <p><a href="https://www.mathworks.com/products/matlab.html">Published with MATLAB&reg; R2017a</a></p>
         </div>
      </div>
      <!--
##### SOURCE BEGIN #####
%% SVMSGD Interactive Classification
% Train with SVMSGD algorithm.
% The classifier can handle linearly separable 2-class dataset.
%
% Sources:
%
% * <https://github.com/opencv/opencv/blob/3.2.0/samples/cpp/train_svmsgd.cpp>
%

function varargout = train_svmsgd_demo_gui()
    % data
    sz = [594 841];  % [height width]
    samples = [];    % Set of train samples. Contains points on image
    responses = [];  % Set of responses for train samples

    % create the UI
    h = buildGUI();
    onHelp([],[]);   % display instructions
    if nargout > 0, varargout{1} = h; end


    function h = buildGUI()
        %BUILDGUI  Creates the UI

        h = struct();
        h.fig = figure('Name','Train SVMSGD', 'Menubar','none', ...
            'Position',[200 200 sz(2) sz(1)]);
        if ~mexopencv.isOctave()
            %HACK: not implemented in Octave
            movegui(h.fig, 'center');
        end
        h.ax = axes('Parent',h.fig, 'Units','normalized', 'Position',[0 0 1 1]);
        img = zeros([sz 3], 'uint8');
        if ~mexopencv.isOctave()
            h.img = imshow(img, 'Parent',h.ax);
        else
            %HACK: https://savannah.gnu.org/bugs/index.php?45473
            axes(h.ax);
            h.img = imshow(img);
        end

        % register mouse button handlers and change cursor
        set(h.fig, 'Pointer','cross', 'WindowKeyPressFcn',@onType, ...
            'WindowButtonDownFcn',@onMouseDown);
    end

    function onHelp(~,~)
        %ONHELP  Display usage help dialog

        hd = helpdlg({
            'Left-click the mouse to add a positive sample.'
            'Right-click the mouse to add a negative sample.'
            'Hot keys:'
            '  h: usage dialog'
            '  r: reset'
            '  s: save current output image as PNG image'
            '  e: export current data as MAT-file'
            '  q: quit the program'
        }, 'Interactive SVMSGD demo');
        set(hd, 'WindowStyle','modal');
    end

    function onReset(~,~)
        %ONRESET  Restart from scratch

        % reset data
        samples = [];
        responses = [];

        % update plot
        img = zeros([sz 3], 'uint8');
        set(h.img, 'CData',img);
        drawnow;
    end

    function onType(~,e)
        %ONTYPE  Event handler for key press on figure

        % handle keys
        switch e.Key
            case 'r'
                onReset([],[]);
            case 'h'
                onHelp([],[]);
            case 's'
                fname = [tempname() '.png'];
                imwrite(img, fname);
                fprintf('Output saved as "%s"\n', fname);
            case 'e'
                uisave({'samples', 'responses'}, 'data.mat');
            case {'q', 'escape'}
                close(h.fig);
        end
    end

    function onMouseDown(~,~)
        %ONMOUSEDOWN  Event handler for mouse down on figure

        % get current location of mouse pointer
        p = get(h.ax, 'CurrentPoint');
        p = round(p(1,1:2));

        % add point to train set with corresponding positive/negative class
        samples(end+1,:) = p;
        if strcmp(get(h.fig,'SelectionType'), 'normal')
            responses(end+1) = +1;
        else
            responses(end+1) = -1;
        end

        % process (train model and draw results on image)
        [weights, shift] = doTrain(samples, responses(:));
        pts = doFindPointsForLine(sz, weights, shift);
        img = doRedraw(sz, samples, responses, pts);

        % update plot
        set(h.img, 'CData',img);
        drawnow;
    end
end

function [weights, shift] = doTrain(samples, responses)
    %DOTRAIN  Train with SVMSGD algorithm
    %
    %     [weights, shift] = doTrain(samples, responses)
    %
    % ## Input
    % * __samples__, __responses__ train set
    %
    % ## Output
    % * __weights__, __shift__ vector of decision function of SVMSGD algorithm
    %

    weights = [];
    shift = [];
    if numel(unique(responses)) < 2
        % ensure we have at least one point from each class
        return;
    end

    model = cv.SVMSGD();
    model.train(samples, responses);

    if model.isTrained()
        weights = model.getWeights();
        shift = model.getShift();

        display(model)
        fprintf('%f*x + %f*y + %f = 0\n', weights(1), weights(2), shift);
    end
end

function pts = doFindPointsForLine(sz, weights, shift)
    %DOFINDPOINTSFORLINE  Find two points for drawing decision function line (w*x = 0)

    pts = [];
    if isempty(weights)
        return;
    end

    % axis-aligned border segments
    segments = {
        [sz(2) 0; sz(2) sz(1)];  % right
        [0 sz(1); sz(2) sz(1)];  % top
        [0 0; sz(2) 0];          % bottom
        [0 0; 0 sz(1)]           % left
    };

    % test intersection against each segment until we collect two points
    for i=1:numel(segments)
        pt = doFindCrossPointWithBorders(weights, shift, segments{i});
        if ~isempty(pt)
            pts(end+1,:) = pt;
            if size(pts,1) >= 2
                return;
            end
        end
    end
end

function pt = doFindCrossPointWithBorders(weights, shift, seg)
    %DOFINDCROSSPOINTWITHBORDERS  Find intersection of line (w*x = 0) and segment
    %
    % (y = HEIGHT, 0 <= x <= WIDTH) or (x = WIDTH, 0 <= y <= HEIGHT)
    %
    % decision function line equation: w(1)*x + w(2)*y + s = 0
    % border equations either x=c or y=c
    %

    xmn = min(seg(:,1));
    xmx = max(seg(:,1));
    ymn = min(seg(:,2));
    ymx = max(seg(:,2));
    pt = [];
    if xmn == xmx && weights(2) ~= 0
        % intersect with vertical border
        x = xmn;
        y = floor(-(weights(1) * x + shift) / weights(2));
        if ymn <= y && y <= ymx
            pt = [x y];
        end
    elseif ymn == ymx && weights(1) ~= 0
        % intersect with horizontal border
        y = ymn;
        x = floor(-(weights(2) * y + shift) / weights(1));
        if xmn <= x && x <= xmx
            pt = [x y];
        end
    end
end

function img = doRedraw(sz, samples, responses, pts)
    %DOREDRAW  Redraw point set and decision function line (w*x = 0)

    img = zeros([sz 3], 'uint8');

    if ~isempty(samples)
        img = cv.circle(img, samples(responses==+1,:), 6, ...
            'Color',[255 0 0], 'Thickness','Filled');
        img = cv.circle(img, samples(responses==-1,:), 6, ...
            'Color',[0 0 255], 'Thickness','Filled');
    end

    if ~isempty(pts)
        img = cv.line(img, pts(1,:), pts(2,:), 'Color',[0 255 0]);
    end
end

##### SOURCE END #####
-->
   </body>
</html>