<!DOCTYPE html>
<html>
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   
      <!--This HTML was auto-generated from published MATLAB code.-->
      <title>squares_detector_demo</title>
      <meta name="generator" content="MATLAB 9.2">
      <link rel="schema.DC" href="http://purl.org/dc/elements/1.1/">
      <meta name="DC.date" content="2017-11-27">
      <meta name="DC.source" content="squares_detector_demo.m">
      <link rel="stylesheet" type="text/css" href="publish_custom.css">
   </head>
   <body>
      <div class="content">
         <h2 id="toc">Contents</h2>
         <div>
            <ul>
               <li><a href="#1">Squares Detector</a></li>
               <li><a href="#8">Helper functions</a></li>
            </ul>
         </div>
         <h2 id="1">Squares Detector</h2>
         <p>It loads several images sequentially and tries to find squares in each image.</p>
         <p>A program using pyramid scaling, Canny, contours, and contour simpification (it's got it all folks) to find squares in a list
            of images <tt>pic*.png</tt>. Returns sequence of squares detected on the image.
         </p>
         <p>Sources:</p>
         <div>
            <ul>
               <li><a href="https://github.com/opencv/opencv/blob/3.2.0/samples/cpp/squares.cpp">https://github.com/opencv/opencv/blob/3.2.0/samples/cpp/squares.cpp</a></li>
               <li><a href="https://github.com/opencv/opencv/blob/3.2.0/samples/tapi/squares.cpp">https://github.com/opencv/opencv/blob/3.2.0/samples/tapi/squares.cpp</a></li>
               <li><a href="https://github.com/opencv/opencv/blob/3.2.0/samples/python/squares.py">https://github.com/opencv/opencv/blob/3.2.0/samples/python/squares.py</a></li>
            </ul>
         </div><pre class="codeinput"><span class="keyword">function</span> squares_detector_demo()</pre><p>loop over sequence of images</p><pre class="codeinput">    names = cv.glob(fullfile(mexopencv.root(), <span class="string">'test'</span>, <span class="string">'pic*.png'</span>));
    <span class="keyword">for</span> i=1:numel(names)</pre><p>load image</p><pre class="codeinput">        img = cv.imread(names{i}, <span class="string">'Color'</span>,true);</pre><p>find and draw squares (TODO: apply something like groupRectangles)</p><pre class="codeinput">        squares = findSquares(img);
        <span class="keyword">if</span> true
            img = cv.polylines(img, squares, <span class="string">'Closed'</span>,true, <span class="keyword">...</span>
                <span class="string">'Color'</span>,[255 0 255], <span class="string">'Thickness'</span>,2, <span class="string">'LineType'</span>,<span class="string">'AA'</span>);
        <span class="keyword">else</span>
            img = cv.drawContours(img, squares, <span class="keyword">...</span>
                <span class="string">'Color'</span>,[255 0 255], <span class="string">'Thickness'</span>,2, <span class="string">'LineType'</span>,<span class="string">'AA'</span>);
        <span class="keyword">end</span></pre><p>show result</p><pre class="codeinput">        [~,fname,ext] = fileparts(names{i});
        figure, imshow(img), title([fname ext])</pre><img src="squares_detector_demo_01.png"><img src="squares_detector_demo_02.png"><img src="squares_detector_demo_03.png"><img src="squares_detector_demo_04.png"><img src="squares_detector_demo_05.png"><img src="squares_detector_demo_06.png"><pre class="codeinput">    <span class="keyword">end</span></pre><pre class="codeinput"><span class="keyword">end</span></pre><h2 id="8">Helper functions</h2><pre class="codeinput"><span class="keyword">function</span> squares = findSquares(img)
    <span class="keyword">if</span> true
        <span class="comment">% down-scale and upscale the image to filter out the noise</span>
        sz = size(img);
        img = cv.pyrDown(img, <span class="string">'DstSize'</span>,fix(sz([2 1])/2));
        img = cv.pyrUp(img, <span class="string">'DstSize'</span>,sz([2 1]));
    <span class="keyword">else</span>
        img = cv.GaussianBlur(img, <span class="string">'KSize'</span>,[5 5]);
    <span class="keyword">end</span>

    <span class="comment">% find squares in every color plane of the image</span>
    squares = {};
    <span class="keyword">for</span> ch=1:size(img,3)
        <span class="comment">% try several threshold levels</span>
        N = 11;
        thresh = 50;
        <span class="keyword">for</span> t=1:N
            <span class="keyword">if</span> t == 1
                <span class="comment">% apply Canny (helps to catch squares with gradient shading).</span>
                <span class="comment">% Take the upper threshold from slider and set the lower to 0</span>
                <span class="comment">% (which forces edges merging)</span>
                gray = cv.Canny(img(:,:,ch), [0 thresh], <span class="string">'ApertureSize'</span>,5);
                <span class="comment">% dilate to remove potential holes between edge segments</span>
                gray = cv.dilate(gray);
            <span class="keyword">else</span>
                <span class="comment">% apply threshold if not first threshold level</span>
                gray = cv.threshold(img(:,:,ch), t*255/N, <span class="string">'Type'</span>,<span class="string">'Binary'</span>);
            <span class="keyword">end</span>

            <span class="comment">% find and test each contour</span>
            contours = cv.findContours(gray, <span class="string">'Mode'</span>,<span class="string">'List'</span>, <span class="string">'Method'</span>,<span class="string">'Simple'</span>);
            <span class="keyword">for</span> i=1:numel(contours)
                <span class="comment">% approximate contour with accuracy proportional to its perimeter</span>
                alen = cv.arcLength(contours{i}, <span class="string">'Closed'</span>,true);
                approx = cv.approxPolyDP(contours{i}, <span class="keyword">...</span>
                    <span class="string">'Epsilon'</span>,alen*0.02, <span class="string">'Closed'</span>,true);

                <span class="comment">% to be a square/rectangle, a contour should have:</span>
                <span class="comment">%</span>
                <span class="comment">% * 4 vertices after approximation,</span>
                <span class="comment">% * relatively large area (to filter out noisy contours),</span>
                <span class="comment">% * be convex.</span>
                <span class="comment">%</span>
                <span class="comment">% Note: we take absolute value of area because it can be</span>
                <span class="comment">% positive or negative, according to contour orientation</span>
                <span class="keyword">if</span> numel(approx) == 4 &amp;&amp; <span class="keyword">...</span>
                    abs(cv.contourArea(approx)) &gt; 1000 &amp;&amp; <span class="keyword">...</span>
                    cv.isContourConvex(approx)
                    <span class="comment">% find the maximum cosine of angles between joint edges</span>
                    idx0 = 2:4;                <span class="comment">% current</span>
                    idx1 = modulu4(idx0 + 1);  <span class="comment">% next</span>
                    idx2 = modulu4(idx0 - 1);  <span class="comment">% previous</span>
                    maxCosine = max(abs(cellfun(@cosineAngle, <span class="keyword">...</span>
                        approx(idx0), approx(idx1), approx(idx2))));

                    <span class="comment">% if cosines of all angles are small (~90 degree angles),</span>
                    <span class="comment">% then write quandrange vertices to resultant sequence</span>
                    <span class="keyword">if</span> maxCosine &lt; 0.3  <span class="comment">% acosd(0.3) ~ 72.5 degrees</span>
                        squares{end+1} = approx;
                    <span class="keyword">end</span>
                <span class="keyword">end</span>
            <span class="keyword">end</span>
        <span class="keyword">end</span>
    <span class="keyword">end</span>
<span class="keyword">end</span></pre><pre class="codeinput"><span class="keyword">function</span> cosine = cosineAngle(pt0, pt1, pt2)
    <span class="comment">% find cosine of angle between vectors from pt0-&gt;pt1 and from pt0-&gt;pt2</span>
    <span class="comment">% cos(theta) = a.b / ||a|| * ||b||</span>
    vec1 = (pt1 - pt0);
    vec2 = (pt2 - pt0);
    cosine = dot(vec1, vec2) / (norm(vec1) * norm(vec2));
<span class="keyword">end</span></pre><pre class="codeinput"><span class="keyword">function</span> idx = modulu4(idx)
    idx = mod(idx - 1, 4) + 1;
<span class="keyword">end</span></pre><div class="footer">
            <p><a href="https://www.mathworks.com/products/matlab.html">Published with MATLAB&reg; R2017a</a></p>
         </div>
      </div>
      <!--
##### SOURCE BEGIN #####
%% Squares Detector
% It loads several images sequentially and tries to find squares in each
% image.
%
% A program using pyramid scaling, Canny, contours, and contour simpification
% (it's got it all folks) to find squares in a list of images |pic*.png|.
% Returns sequence of squares detected on the image.
%
% Sources:
%
% * <https://github.com/opencv/opencv/blob/3.2.0/samples/cpp/squares.cpp>
% * <https://github.com/opencv/opencv/blob/3.2.0/samples/tapi/squares.cpp>
% * <https://github.com/opencv/opencv/blob/3.2.0/samples/python/squares.py>
%

function squares_detector_demo()
    %%
    % loop over sequence of images
    names = cv.glob(fullfile(mexopencv.root(), 'test', 'pic*.png'));
    for i=1:numel(names)
        %%
        % load image
        img = cv.imread(names{i}, 'Color',true);

        %%
        % find and draw squares
        % (TODO: apply something like groupRectangles)
        squares = findSquares(img);
        if true
            img = cv.polylines(img, squares, 'Closed',true, ...
                'Color',[255 0 255], 'Thickness',2, 'LineType','AA');
        else
            img = cv.drawContours(img, squares, ...
                'Color',[255 0 255], 'Thickness',2, 'LineType','AA');
        end

        %%
        % show result
        [~,fname,ext] = fileparts(names{i});
        figure, imshow(img), title([fname ext])
    end
end

%% Helper functions

function squares = findSquares(img)
    if true
        % down-scale and upscale the image to filter out the noise
        sz = size(img);
        img = cv.pyrDown(img, 'DstSize',fix(sz([2 1])/2));
        img = cv.pyrUp(img, 'DstSize',sz([2 1]));
    else
        img = cv.GaussianBlur(img, 'KSize',[5 5]);
    end

    % find squares in every color plane of the image
    squares = {};
    for ch=1:size(img,3)
        % try several threshold levels
        N = 11;
        thresh = 50;
        for t=1:N
            if t == 1
                % apply Canny (helps to catch squares with gradient shading).
                % Take the upper threshold from slider and set the lower to 0
                % (which forces edges merging)
                gray = cv.Canny(img(:,:,ch), [0 thresh], 'ApertureSize',5);
                % dilate to remove potential holes between edge segments
                gray = cv.dilate(gray);
            else
                % apply threshold if not first threshold level
                gray = cv.threshold(img(:,:,ch), t*255/N, 'Type','Binary');
            end

            % find and test each contour
            contours = cv.findContours(gray, 'Mode','List', 'Method','Simple');
            for i=1:numel(contours)
                % approximate contour with accuracy proportional to its perimeter
                alen = cv.arcLength(contours{i}, 'Closed',true);
                approx = cv.approxPolyDP(contours{i}, ...
                    'Epsilon',alen*0.02, 'Closed',true);

                % to be a square/rectangle, a contour should have:
                %
                % * 4 vertices after approximation,
                % * relatively large area (to filter out noisy contours),
                % * be convex.
                %
                % Note: we take absolute value of area because it can be
                % positive or negative, according to contour orientation
                if numel(approx) == 4 && ...
                    abs(cv.contourArea(approx)) > 1000 && ...
                    cv.isContourConvex(approx)
                    % find the maximum cosine of angles between joint edges
                    idx0 = 2:4;                % current
                    idx1 = modulu4(idx0 + 1);  % next
                    idx2 = modulu4(idx0 - 1);  % previous
                    maxCosine = max(abs(cellfun(@cosineAngle, ...
                        approx(idx0), approx(idx1), approx(idx2))));

                    % if cosines of all angles are small (~90 degree angles),
                    % then write quandrange vertices to resultant sequence
                    if maxCosine < 0.3  % acosd(0.3) ~ 72.5 degrees
                        squares{end+1} = approx;
                    end
                end
            end
        end
    end
end

%%

function cosine = cosineAngle(pt0, pt1, pt2)
    % find cosine of angle between vectors from pt0->pt1 and from pt0->pt2
    % cos(theta) = a.b / ||a|| * ||b||
    vec1 = (pt1 - pt0);
    vec2 = (pt2 - pt0);
    cosine = dot(vec1, vec2) / (norm(vec1) * norm(vec2));
end

%%

function idx = modulu4(idx)
    idx = mod(idx - 1, 4) + 1;
end

##### SOURCE END #####
-->
   </body>
</html>