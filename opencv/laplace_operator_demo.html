<!DOCTYPE html>
<html>
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   
      <!--This HTML was auto-generated from published MATLAB code.-->
      <title>Laplace Operator</title>
      <meta name="generator" content="MATLAB 9.2">
      <link rel="schema.DC" href="http://purl.org/dc/elements/1.1/">
      <meta name="DC.date" content="2017-11-27">
      <meta name="DC.source" content="laplace_operator_demo.m">
      <link rel="stylesheet" type="text/css" href="publish_custom.css">
   </head>
   <body>
      <div class="content">
         <h1 id="1">Laplace Operator</h1>
         <!--introduction-->
         <p>In this demo, we show how to use the OpenCV function <tt>cv.Laplacian</tt> to implement a discrete analog of the <i>Laplacian operator</i>.
         </p>
         <p>Sources:</p>
         <div>
            <ul>
               <li><a href="https://docs.opencv.org/3.2.0/d5/db5/tutorial_laplace_operator.html">https://docs.opencv.org/3.2.0/d5/db5/tutorial_laplace_operator.html</a></li>
               <li><a href="https://github.com/opencv/opencv/blob/3.2.0/samples/cpp/tutorial_code/ImgTrans/Laplace_Demo.cpp">https://github.com/opencv/opencv/blob/3.2.0/samples/cpp/tutorial_code/ImgTrans/Laplace_Demo.cpp</a></li>
            </ul>
         </div>
         <!--/introduction-->
         <h2 id="toc">Contents</h2>
         <div>
            <ul>
               <li><a href="#2">Theory</a></li>
               <li><a href="#3">Laplacian Operator</a></li>
               <li><a href="#4">Code</a></li>
            </ul>
         </div>
         <h2 id="2">Theory</h2>
         <p>In a previous demo, we learned how to use the <i>Sobel Operator</i>. It was based on the fact that in the edge area, the pixel intensity shows a "jump" or a high variation of intensity. Getting
            the first derivative of the intensity, we observed that an edge is characterized by a maximum, as it can be seen in the figure:
         </p>
         <p><img src="https://docs.opencv.org/3.2.0/Laplace_Operator_Tutorial_Theory_Previous.jpg"></p>
         <p>And what happens if we take the second derivative?</p>
         <p><img src="https://docs.opencv.org/3.2.0/Laplace_Operator_Tutorial_Theory_ddIntensity.jpg"></p>
         <p>You can observe that the second derivative is zero! So, we can also use this criterion to attempt to detect edges in an image.
            However, note that zeros will not only appear in edges (they can actually appear in other meaningless locations); this can
            be solved by applying filtering where needed.
         </p>
         <h2 id="3">Laplacian Operator</h2>
         <p>From the explanation above, we deduce that the second derivative can be used to <i>detect edges</i>. Since images are "2D", we would need to take the derivative in both dimensions. Here, the Laplacian operator comes handy.
         </p>
         <p>The <i>Laplacian operator</i> is defined by:
         </p>
         <p><img src="laplace_operator_demo_eq12645394294117653565.png" alt="$$Laplace(f) = \frac{\partial^{2} f}{\partial x^{2}} +&#xA;               \frac{\partial^{2} f}{\partial y^{2}}$$" class="equation" width="160" height="36"></p>
         <p>The Laplacian operator is implemented in OpenCV by the function <tt>cv.Laplacian</tt>. In fact, since the Laplacian uses the gradient of images, it calls internally the <i>Sobel</i> operator to perform its computation.
         </p>
         <h2 id="4">Code</h2>
         <p>The program:</p>
         <div>
            <ul>
               <li>Loads an image</li>
               <li>Remove noise by applying a Gaussian blur and then convert the original   image to grayscale</li>
               <li>Applies a Laplacian operator to the grayscale image and stores the output   image</li>
               <li>Display the result in a window</li>
            </ul>
         </div>
         <p>load source image</p><pre class="codeinput">src = cv.imread(fullfile(mexopencv.root(),<span class="string">'test'</span>,<span class="string">'butterfly.jpg'</span>), <span class="string">'Color'</span>,true);</pre><p>apply a Gaussian blur to reduce the noise</p><pre class="codeinput">src = cv.GaussianBlur(src, <span class="string">'KSize'</span>,[3 3]);</pre><p>convert filtered image to grayscale</p><pre class="codeinput">gray = cv.cvtColor(src, <span class="string">'RGB2GRAY'</span>);</pre><p>apply the Laplacian operator to the grayscale image (input is 8-bit, we set the output image depth to 16-bit to avoid overflow)</p><pre class="codeinput">dst = cv.Laplacian(gray, <span class="string">'KSize'</span>,3, <span class="string">'DDepth'</span>,<span class="string">'int16'</span>);</pre><p>take absolute value and convert results back to 8-bit</p><pre class="codeinput">dstabs = cv.convertScaleAbs(dst);</pre><p>show result</p><pre class="codeinput">imshow(dstabs)
title(<span class="string">'Laplace Demo'</span>)</pre><img src="laplace_operator_demo_01.png"><div class="footer">
            <p><a href="https://www.mathworks.com/products/matlab.html">Published with MATLAB&reg; R2017a</a></p>
         </div>
      </div><script type="text/x-mathjax-config">
  // https://stackoverflow.com/a/14631703/97160
  MathJax.Extension.myImg2jax = {
    version: "1.0",
    PreProcess: function (element) {
      var images = element.getElementsByTagName("img");
      for (var i = images.length - 1; i >= 0; i--) {
        var img = images[i];
        if (img.className === "equation") {
          var match = img.alt.match(/^(\$\$?)([\s\S]*)\1$/m);
          if (!match) continue;
          var script = document.createElement("script");
          script.type = "math/tex";
          if (match[1] === "$$") {script.type += ";mode=display"}
          MathJax.HTML.setScript(script, match[2]);
          img.parentNode.replaceChild(script, img);
        }
      }
    }
  };
  MathJax.Hub.Register.PreProcessor(["PreProcess", MathJax.Extension.myImg2jax]);
  </script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-AMS_CHTML"></script>
      <!--
##### SOURCE BEGIN #####
%% Laplace Operator
%
% In this demo, we show how to use the OpenCV function |cv.Laplacian| to
% implement a discrete analog of the _Laplacian operator_.
%
% Sources:
%
% * <https://docs.opencv.org/3.2.0/d5/db5/tutorial_laplace_operator.html>
% * <https://github.com/opencv/opencv/blob/3.2.0/samples/cpp/tutorial_code/ImgTrans/Laplace_Demo.cpp>
%

%% Theory
%
% In a previous demo, we learned how to use the _Sobel Operator_. It was based
% on the fact that in the edge area, the pixel intensity shows a "jump" or a
% high variation of intensity. Getting the first derivative of the intensity,
% we observed that an edge is characterized by a maximum, as it can be seen in
% the figure:
%
% <<https://docs.opencv.org/3.2.0/Laplace_Operator_Tutorial_Theory_Previous.jpg>>
%
% And what happens if we take the second derivative?
%
% <<https://docs.opencv.org/3.2.0/Laplace_Operator_Tutorial_Theory_ddIntensity.jpg>>
%
% You can observe that the second derivative is zero! So, we can also use this
% criterion to attempt to detect edges in an image. However, note that zeros
% will not only appear in edges (they can actually appear in other meaningless
% locations); this can be solved by applying filtering where needed.
%
%% Laplacian Operator
%
% From the explanation above, we deduce that the second derivative can be used
% to _detect edges_. Since images are "2D", we would need to take the
% derivative in both dimensions. Here, the Laplacian operator comes handy.
%
% The _Laplacian operator_ is defined by:
%
% $$Laplace(f) = \frac{\partial^{2} f}{\partial x^{2}} +
%                \frac{\partial^{2} f}{\partial y^{2}}$$
%
% The Laplacian operator is implemented in OpenCV by the function
% |cv.Laplacian|. In fact, since the Laplacian uses the gradient of images, it
% calls internally the _Sobel_ operator to perform its computation.
%

%% Code
%
% The program:
%
% * Loads an image
% * Remove noise by applying a Gaussian blur and then convert the original
%   image to grayscale
% * Applies a Laplacian operator to the grayscale image and stores the output
%   image
% * Display the result in a window
%

%%
% load source image
src = cv.imread(fullfile(mexopencv.root(),'test','butterfly.jpg'), 'Color',true);

%%
% apply a Gaussian blur to reduce the noise
src = cv.GaussianBlur(src, 'KSize',[3 3]);

%%
% convert filtered image to grayscale
gray = cv.cvtColor(src, 'RGB2GRAY');

%%
% apply the Laplacian operator to the grayscale image
% (input is 8-bit, we set the output image depth to 16-bit to avoid overflow)
dst = cv.Laplacian(gray, 'KSize',3, 'DDepth','int16');

%%
% take absolute value and convert results back to 8-bit
dstabs = cv.convertScaleAbs(dst);

%%
% show result
imshow(dstabs)
title('Laplace Demo')

##### SOURCE END #####
--></body>
</html>