<!DOCTYPE html>
<html>
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   
      <!--This HTML was auto-generated from published MATLAB code.-->
      <title>Smoothing Images</title>
      <meta name="generator" content="MATLAB 9.2">
      <link rel="schema.DC" href="http://purl.org/dc/elements/1.1/">
      <meta name="DC.date" content="2017-11-27">
      <meta name="DC.source" content="gausian_median_blur_bilateral_filter.m">
      <link rel="stylesheet" type="text/css" href="publish_custom.css">
   </head>
   <body>
      <div class="content">
         <h1 id="1">Smoothing Images</h1>
         <!--introduction-->
         <p>In this tutorial you will learn how to apply diverse linear filters to smooth images using OpenCV functions such as:</p>
         <div>
            <ul>
               <li><a href="matlab:doc('cv.blur')">cv.blur</a></li>
               <li><a href="matlab:doc('cv.GaussianBlur')">cv.GaussianBlur</a></li>
               <li><a href="matlab:doc('cv.medianBlur')">cv.medianBlur</a></li>
               <li><a href="matlab:doc('cv.bilateralFilter')">cv.bilateralFilter</a></li>
            </ul>
         </div>
         <p>Sources:</p>
         <div>
            <ul>
               <li><a href="https://docs.opencv.org/3.1.0/dc/dd3/tutorial_gausian_median_blur_bilateral_filter.html">https://docs.opencv.org/3.1.0/dc/dd3/tutorial_gausian_median_blur_bilateral_filter.html</a></li>
            </ul>
         </div>
         <!--/introduction-->
         <h2 id="toc">Contents</h2>
         <div>
            <ul>
               <li><a href="#2">Theory</a></li>
               <li><a href="#7">1. Normalized Box Filter</a></li>
               <li><a href="#8">2. Gaussian Filter</a></li>
               <li><a href="#10">3. Median Filter</a></li>
               <li><a href="#11">4. Bilateral Filter</a></li>
               <li><a href="#12">Code</a></li>
               <li><a href="#14">Explanation</a></li>
               <li><a href="#27">Results</a></li>
            </ul>
         </div>
         <h2 id="2">Theory</h2>
         <p>Note: The explanation below belongs to the book <a href="http://szeliski.org/Book/">Computer Vision: Algorithms and Applications</a> by Richard Szeliski and <i>Learning OpenCV</i>.
         </p>
         <p><i>Smoothing</i>, also called <i>blurring</i>, is a simple and frequently used image processing operation.
         </p>
         <p>There are many reasons for smoothing. In this tutorial we will focus on smoothing in order to reduce noise (other uses will
            be seen in the following tutorials).
         </p>
         <p>To perform a smoothing operation we will apply a <i>filter</i> to our image. The most common type of filters are <i>linear</i>, in which an output pixel's value (i.e. <img src="gausian_median_blur_bilateral_filter_eq04979836882338782479.png" alt="$g(i,j)$" class="equation" width="36" height="15">) is determined as a weighted sum of input pixel values (i.e. <img src="gausian_median_blur_bilateral_filter_eq16718080612892853225.png" alt="$f(i+k,j+l)$" class="equation" width="86" height="15">):
         </p>
         <p><img src="gausian_median_blur_bilateral_filter_eq05206158905103817050.png" alt="$$ g(i,j) = \sum_{k,l} f(i+k, j+l) h(k,l) $$" class="equation" width="206" height="34"></p>
         <p><img src="gausian_median_blur_bilateral_filter_eq00006570404466520437.png" alt="$h(k,l)$" class="equation" width="38" height="15"> is called the <i>kernel</i>, which is nothing more than the coefficients of the filter.
         </p>
         <p>It helps to visualize a <i>filter</i> as a window of coefficients sliding across the image.
         </p>
         <p>There are many kind of filters, here we will mention the most used.</p>
         <h2 id="7">1. Normalized Box Filter</h2>
         <div>
            <ul>
               <li>This filter is the simplest of all! Each output pixel is the <i>mean</i> of   its kernel neighbors (all of them contribute with equal weights)
               </li>
               <li>The kernel is below:</li>
            </ul>
         </div>
         <p><img src="gausian_median_blur_bilateral_filter_eq13631628202685950672.png" alt="$$ K = \frac{1}{K_{width} \cdot K_{height}}&#xA;    \left[ {\matrix{&#xA;      1 &amp; 1 &amp; 1 &amp; ... &amp; 1 \cr&#xA;      1 &amp; 1 &amp; 1 &amp; ... &amp; 1 \cr&#xA;      . &amp; . &amp; . &amp; ... &amp; 1 \cr&#xA;      . &amp; . &amp; . &amp; ... &amp; 1 \cr&#xA;      1 &amp; 1 &amp; 1 &amp; ... &amp; 1&#xA;    } } \right] $$" class="equation" width="251" height="81"></p>
         <h2 id="8">2. Gaussian Filter</h2>
         <div>
            <ul>
               <li>Probably the most useful filter (although not the fastest). Gaussian   filtering is done by convolving each point in the input
                  array with a   <i>Gaussian kernel</i> and then summing them all to produce the output array.
               </li>
            </ul>
         </div>
         <div>
            <ul>
               <li>Just to make the picture clearer, remember how a 1D Gaussian kernel look   like?</li>
            </ul>
         </div><pre class="codeinput">pos = get(0, <span class="string">'DefaultFigurePosition'</span>);
set(gcf, <span class="string">'Position'</span>,pos.*[1 1 0.5 0.5])

x = linspace(-4,4,100);
plot(x, normpdf(x,0,1))
xlabel(<span class="string">'x'</span>), ylabel(<span class="string">'G(x)'</span>), grid <span class="string">on</span></pre><img src="gausian_median_blur_bilateral_filter_01.png"><p>Assuming that an image is 1D, you can notice that the pixel located in the middle would have the biggest weight. The weight
            of its neighbors decreases as the spatial distance between them and the center pixel increases.
         </p>
         <p>Note: Remember that a 2D Gaussian can be represented as:</p>
         <p><img src="gausian_median_blur_bilateral_filter_eq13131363217011706941.png" alt="$$ G_{0}(x, y) = A e^{ \frac{ -(x - \mu_{x})^{2} }{ 2\sigma^{2}_{x} } +&#xA;                       \frac{ -(y - \mu_{y})^{2} }{ 2\sigma^{2}_{y} } } $$" class="equation" width="172" height="30"></p>
         <p>where <img src="gausian_median_blur_bilateral_filter_eq05371638286043275527.png" alt="$\mu$" class="equation" width="9" height="10"> is the mean (the peak) and <img src="gausian_median_blur_bilateral_filter_eq11373214381793991308.png" alt="$\sigma$" class="equation" width="8" height="7"> represents the variance (per each of the variables <img src="gausian_median_blur_bilateral_filter_eq12428413953531653171.png" alt="$x$" class="equation" width="8" height="7"> and <img src="gausian_median_blur_bilateral_filter_eq08830444604280721118.png" alt="$y$" class="equation" width="8" height="10">).
         </p>
         <h2 id="10">3. Median Filter</h2>
         <p>The median filter run through each element of the signal (in this case the image) and replace each pixel with the <b>median</b> of its neighboring pixels (located in a square neighborhood around the evaluated pixel).
         </p>
         <h2 id="11">4. Bilateral Filter</h2>
         <div>
            <ul>
               <li>So far, we have explained some filters which main goal is to <i>smooth</i> an   input image. However, sometimes the filters do not only dissolve the   noise, but also smooth away the <i>edges</i>. To avoid this (at certain extent   at least), we can use a bilateral filter.
               </li>
               <li>In an analogous way as the Gaussian filter, the bilateral filter also   considers the neighboring pixels with weights assigned
                  to each of them.   These weights have two components, the first of which is the same   weighting used by the Gaussian filter.
                  The second component takes into   account the difference in intensity between the neighboring pixels and   the evaluated one.
               </li>
               <li>For a more detailed explanation you can check   <a href="http://homepages.inf.ed.ac.uk/rbf/CVonline/LOCAL_COPIES/MANDUCHI1/Bilateral_Filtering.html">this link</a>.
               </li>
            </ul>
         </div>
         <h2 id="12">Code</h2>
         <p><a href="https://github.com/opencv/opencv/blob/3.1.0/samples/cpp/tutorial_code/ImgProc/Smoothing.cpp">https://github.com/opencv/opencv/blob/3.1.0/samples/cpp/tutorial_code/ImgProc/Smoothing.cpp</a></p>
         <p>This <a href="./smoothing_demo.html">program</a>:
         </p>
         <div>
            <ul>
               <li>Loads an image</li>
               <li>Applies 4 different kinds of filters (explained in Theory) and show the   filtered images sequentially.</li>
            </ul>
         </div><pre class="code-matlab">
<span class="comment">%% Smoothing Demo</span>
<span class="comment">% Sample code for simple filters</span>
<span class="comment">%</span>
<span class="comment">% Sources:</span>
<span class="comment">%</span>
<span class="comment">% * &lt;https://github.com/opencv/opencv/blob/3.1.0/samples/cpp/tutorial_code/ImgProc/Smoothing.cpp&gt;</span>
<span class="comment">%</span>

<span class="comment">%%</span>
<span class="comment">% Global Variables</span>
DELAY_CAPTION = 0.1;
DELAY_BLUR = 0.01;
MAX_KERNEL_LENGTH = 31;

<span class="comment">%% Source Image</span>
<span class="comment">% Load the source image</span>
src = imread(fullfile(mexopencv.root(),<span class="string">'test'</span>,<span class="string">'lena.jpg'</span>));
src = cv.resize(src, 2/3, 2/3);
imshow(src), title(<span class="string">'Original Image'</span>)
pause(DELAY_CAPTION)

<span class="comment">%dst = cv.putText(src, 'Original Image', [size(src,2) size(src,1)]./4, ...</span>
<span class="comment">%    'FontFace','HersheyComplex', 'FontScale',1, 'Color',[255 255 255]);</span>

<span class="comment">%% Homogeneous blur</span>
<span class="keyword">for</span> i=1:2:MAX_KERNEL_LENGTH
    dst = cv.blur(src, <span class="string">'KSize'</span>,[i i], <span class="string">'Anchor'</span>,[-1,-1]);
    imshow(dst), title(sprintf(<span class="string">'Homogeneous Blur %d'</span>,i))
    pause(DELAY_BLUR)
<span class="keyword">end</span>

<span class="comment">%% Gaussian blur</span>
<span class="keyword">for</span> i=1:2:MAX_KERNEL_LENGTH
    dst = cv.GaussianBlur(src, <span class="string">'KSize'</span>,[i i]);
    imshow(dst), title(sprintf(<span class="string">'Gaussian Blur %d'</span>,i))
    pause(DELAY_BLUR)
<span class="keyword">end</span>

<span class="comment">%% Median blur</span>
<span class="keyword">for</span> i=1:2:MAX_KERNEL_LENGTH
    dst = cv.medianBlur(src, <span class="string">'KSize'</span>,i);
    imshow(dst), title(sprintf(<span class="string">'Median Blur %d'</span>,i))
    pause(DELAY_BLUR)
<span class="keyword">end</span>

<span class="comment">%% Bilateral Filter</span>
<span class="keyword">for</span> i=1:2:MAX_KERNEL_LENGTH
    dst = cv.bilateralFilter(src, <span class="string">'Diameter'</span>,i, <span class="keyword">...</span>
        <span class="string">'SigmaColor'</span>,i*2, <span class="string">'SigmaSpace'</span>,fix(i/2));
    imshow(dst), title(sprintf(<span class="string">'Bilateral Blur %d'</span>,i))
    pause(DELAY_BLUR)
<span class="keyword">end</span>
</pre><h2 id="14">Explanation</h2>
         <p>Let's check the OpenCV functions that involve only the smoothing procedute, since the rest is already known by now.</p>
         <p><h3>1. Normalized Block Filter:</h3></p>
         <p>OpenCV offers the function <tt>cv.blur()</tt> to perform smoothing with this filter.
         </p><pre class="codeinput">dbtype <span class="string">smoothing_demo</span> <span class="string">26:30</span></pre><pre class="codeoutput">
26    for i=1:2:MAX_KERNEL_LENGTH
27        dst = cv.blur(src, 'KSize',[i i], 'Anchor',[-1,-1]);
28        imshow(dst), title(sprintf('Homogeneous Blur %d',i))
29        pause(DELAY_BLUR)
30    end
</pre><p>We specify the following arguments (for more details, check the function reference):</p>
         <div>
            <ul>
               <li><tt>src</tt>: Source image
               </li>
               <li><tt>dst</tt>: Destination image
               </li>
               <li><tt>'KSize',[w,h]</tt>: Defines the size of the kernel to be used (of width <img src="gausian_median_blur_bilateral_filter_eq00125694759345388081.png" alt="$w$" class="equation" width="10" height="7">   pixels and height <img src="gausian_median_blur_bilateral_filter_eq08062630503172331818.png" alt="$h$" class="equation" width="8" height="11"> pixels)
               </li>
               <li><tt>'Anchor',[-1,-1]</tt>: Indicates where the anchor point (the pixel evaluated)   is located with respect to the neighborhood. If there is a negative
                  value,   then the center of the kernel is considered the anchor point.
               </li>
            </ul>
         </div>
         <p><h3>2. Gaussian Filter:</h3></p>
         <p>It is performed by the function <tt>cv.GaussianBlur()</tt>:
         </p><pre class="codeinput">dbtype <span class="string">smoothing_demo</span> <span class="string">33:37</span></pre><pre class="codeoutput">
33    for i=1:2:MAX_KERNEL_LENGTH
34        dst = cv.GaussianBlur(src, 'KSize',[i i]);
35        imshow(dst), title(sprintf('Gaussian Blur %d',i))
36        pause(DELAY_BLUR)
37    end
</pre><p>Here we use the following arguments:</p>
         <div>
            <ul>
               <li><tt>src</tt>: Source image
               </li>
               <li><tt>dst</tt>: Destination image
               </li>
               <li><tt>'KSize',[w,h]</tt>: The size of the kernel to be used (the neighbors to be   considered). <img src="gausian_median_blur_bilateral_filter_eq00125694759345388081.png" alt="$w$" class="equation" width="10" height="7"> and <img src="gausian_median_blur_bilateral_filter_eq08062630503172331818.png" alt="$h$" class="equation" width="8" height="11"> have to be odd and positive numbers otherwise the   size will be calculated using the <img src="gausian_median_blur_bilateral_filter_eq00721157711453237195.png" alt="$\sigma_{x}$" class="equation" width="14" height="9"> and <img src="gausian_median_blur_bilateral_filter_eq07172213848446102970.png" alt="$\sigma_{y}$" class="equation" width="14" height="11"> arguments.
               </li>
               <li><tt>'SigmaX'</tt>: The standard deviation in x. Writing <img src="gausian_median_blur_bilateral_filter_eq00202142981986870057.png" alt="$0$" class="equation" width="7" height="11"> implies that   <img src="gausian_median_blur_bilateral_filter_eq00721157711453237195.png" alt="$\sigma_{x}$" class="equation" width="14" height="9"> is calculated using kernel size.
               </li>
               <li><tt>'SigmaY</tt>: The standard deviation in y. Writing <img src="gausian_median_blur_bilateral_filter_eq00202142981986870057.png" alt="$0$" class="equation" width="7" height="11"> implies that   <img src="gausian_median_blur_bilateral_filter_eq07172213848446102970.png" alt="$\sigma_{y}$" class="equation" width="14" height="11"> is calculated using kernel size.
               </li>
            </ul>
         </div>
         <p><h3>3. Median Filter:</h3></p>
         <p>This filter is provided by the <tt>cv.medianBlur()</tt> function:
         </p><pre class="codeinput">dbtype <span class="string">smoothing_demo</span> <span class="string">40:44</span></pre><pre class="codeoutput">
40    for i=1:2:MAX_KERNEL_LENGTH
41        dst = cv.medianBlur(src, 'KSize',i);
42        imshow(dst), title(sprintf('Median Blur %d',i))
43        pause(DELAY_BLUR)
44    end
</pre><p>We use these arguments:</p>
         <div>
            <ul>
               <li><tt>src</tt>: Source image
               </li>
               <li><tt>dst</tt>: Destination image, must be the same type as <tt>src</tt></li>
               <li><tt>'KSize',i</tt>: Size of the kernel (only one because we use a square window).   Must be odd.
               </li>
            </ul>
         </div>
         <p><h3>4. Bilateral Filter:</h3></p>
         <p>Provided by OpenCV function <tt>cv.bilateralFilter()</tt>.
         </p><pre class="codeinput">dbtype <span class="string">smoothing_demo</span> <span class="string">47:52</span></pre><pre class="codeoutput">
47    for i=1:2:MAX_KERNEL_LENGTH
48        dst = cv.bilateralFilter(src, 'Diameter',i, ...
49            'SigmaColor',i*2, 'SigmaSpace',fix(i/2));
50        imshow(dst), title(sprintf('Bilateral Blur %d',i))
51        pause(DELAY_BLUR)
52    end
</pre><p>We use the following arguments:</p>
         <div>
            <ul>
               <li><tt>src</tt>: Source image
               </li>
               <li><tt>dst</tt>: Destination image
               </li>
               <li><tt>'Diameter',d</tt>: The diameter of each pixel neighborhood.
               </li>
               <li><tt>'SigmaColor',sc</tt>: Standard deviation in the color space <img src="gausian_median_blur_bilateral_filter_eq09436655469171985859.png" alt="$\sigma_{Color}$" class="equation" width="34" height="9">.
               </li>
               <li><tt>'SigmaSpace',ss</tt>: Standard deviation in the coordinate space (in pixel   terms) <img src="gausian_median_blur_bilateral_filter_eq11318364090103759255.png" alt="$\sigma_{Space}$" class="equation" width="35" height="11">.
               </li>
            </ul>
         </div>
         <h2 id="27">Results</h2>
         <div>
            <ul>
               <li>The code opens an image (in this case <tt>lena.jpg</tt>) and display it under the   effects of the 4 filters explained.
               </li>
               <li>Here is a snapshot of the image smoothed using <tt>cv.medianBlur</tt>:
               </li>
            </ul>
         </div>
         <p><img src="./smoothing_demo_04.png"></p>
         <div class="footer">
            <p><a href="https://www.mathworks.com/products/matlab.html">Published with MATLAB&reg; R2017a</a></p>
         </div>
      </div><script type="text/x-mathjax-config">
  // https://stackoverflow.com/a/14631703/97160
  MathJax.Extension.myImg2jax = {
    version: "1.0",
    PreProcess: function (element) {
      var images = element.getElementsByTagName("img");
      for (var i = images.length - 1; i >= 0; i--) {
        var img = images[i];
        if (img.className === "equation") {
          var match = img.alt.match(/^(\$\$?)([\s\S]*)\1$/m);
          if (!match) continue;
          var script = document.createElement("script");
          script.type = "math/tex";
          if (match[1] === "$$") {script.type += ";mode=display"}
          MathJax.HTML.setScript(script, match[2]);
          img.parentNode.replaceChild(script, img);
        }
      }
    }
  };
  MathJax.Hub.Register.PreProcessor(["PreProcess", MathJax.Extension.myImg2jax]);
  </script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-AMS_CHTML"></script>
      <!--
##### SOURCE BEGIN #####
%% Smoothing Images
% In this tutorial you will learn how to apply diverse linear filters to
% smooth images using OpenCV functions such as:
%
% * <matlab:doc('cv.blur') cv.blur>
% * <matlab:doc('cv.GaussianBlur') cv.GaussianBlur>
% * <matlab:doc('cv.medianBlur') cv.medianBlur>
% * <matlab:doc('cv.bilateralFilter') cv.bilateralFilter>
%
% Sources:
%
% * <https://docs.opencv.org/3.1.0/dc/dd3/tutorial_gausian_median_blur_bilateral_filter.html>
%

%% Theory
% Note: The explanation below belongs to the book
% <http://szeliski.org/Book/ Computer Vision: Algorithms and Applications>
% by Richard Szeliski and _Learning OpenCV_.
%%
% _Smoothing_, also called _blurring_, is a simple and frequently used
% image processing operation.
%%
% There are many reasons for smoothing. In this tutorial we will focus on
% smoothing in order to reduce noise (other uses will be seen in the
% following tutorials).
%%
% To perform a smoothing operation we will apply a _filter_ to our image.
% The most common type of filters are _linear_, in which an output pixel's
% value (i.e. $g(i,j)$) is determined as a weighted sum of input pixel
% values (i.e. $f(i+k,j+l)$):
%
% $$ g(i,j) = \sum_{k,l} f(i+k, j+l) h(k,l) $$
%
% $h(k,l)$ is called the _kernel_, which is nothing more than the
% coefficients of the filter.
%
% It helps to visualize a _filter_ as a window of coefficients sliding
% across the image.
%%
% There are many kind of filters, here we will mention the most used.
%

%% 1. Normalized Box Filter
%
% * This filter is the simplest of all! Each output pixel is the _mean_ of
%   its kernel neighbors (all of them contribute with equal weights)
% * The kernel is below:
%
% $$ K = \frac{1}{K_{width} \cdot K_{height}}
%     \left[ {\matrix{
%       1 & 1 & 1 & ... & 1 \cr
%       1 & 1 & 1 & ... & 1 \cr
%       . & . & . & ... & 1 \cr
%       . & . & . & ... & 1 \cr
%       1 & 1 & 1 & ... & 1
%     } } \right] $$
%

%% 2. Gaussian Filter
%
% * Probably the most useful filter (although not the fastest). Gaussian
%   filtering is done by convolving each point in the input array with a
%   _Gaussian kernel_ and then summing them all to produce the output array.
%
% * Just to make the picture clearer, remember how a 1D Gaussian kernel look
%   like?
%

pos = get(0, 'DefaultFigurePosition');
set(gcf, 'Position',pos.*[1 1 0.5 0.5])

x = linspace(-4,4,100);
plot(x, normpdf(x,0,1))
xlabel('x'), ylabel('G(x)'), grid on

%%
% Assuming that an image is 1D, you can notice that the pixel located in the
% middle would have the biggest weight. The weight of its neighbors decreases
% as the spatial distance between them and the center pixel increases.
%
% Note: Remember that a 2D Gaussian can be represented as:
%
% $$ G_{0}(x, y) = A e^{ \frac{ -(x - \mu_{x})^{2} }{ 2\sigma^{2}_{x} } +
%                        \frac{ -(y - \mu_{y})^{2} }{ 2\sigma^{2}_{y} } } $$
%
% where $\mu$ is the mean (the peak) and $\sigma$ represents the variance
% (per each of the variables $x$ and $y$).
%

%% 3. Median Filter
%
% The median filter run through each element of the signal (in this case the
% image) and replace each pixel with the *median* of its neighboring pixels
% (located in a square neighborhood around the evaluated pixel).
%

%% 4. Bilateral Filter
%
% * So far, we have explained some filters which main goal is to _smooth_ an
%   input image. However, sometimes the filters do not only dissolve the
%   noise, but also smooth away the _edges_. To avoid this (at certain extent
%   at least), we can use a bilateral filter.
% * In an analogous way as the Gaussian filter, the bilateral filter also
%   considers the neighboring pixels with weights assigned to each of them.
%   These weights have two components, the first of which is the same
%   weighting used by the Gaussian filter. The second component takes into
%   account the difference in intensity between the neighboring pixels and
%   the evaluated one.
% * For a more detailed explanation you can check
%   <http://homepages.inf.ed.ac.uk/rbf/CVonline/LOCAL_COPIES/MANDUCHI1/Bilateral_Filtering.html this link>.
%

%% Code
% <https://github.com/opencv/opencv/blob/3.1.0/samples/cpp/tutorial_code/ImgProc/Smoothing.cpp>
%
% This <./smoothing_demo.html program>:
%
% * Loads an image
% * Applies 4 different kinds of filters (explained in Theory) and show the
%   filtered images sequentially.
%
%%
% <include>smoothing_demo.m</include>
%

%% Explanation
% Let's check the OpenCV functions that involve only the smoothing procedute,
% since the rest is already known by now.
%

%%
% <html><h3>1. Normalized Block Filter:</h3></html>
%
% OpenCV offers the function |cv.blur()| to perform smoothing with this
% filter.
%
%%
dbtype smoothing_demo 26:30
%%
% We specify the following arguments (for more details, check the function
% reference):
%
% * |src|: Source image
% * |dst|: Destination image
% * |'KSize',[w,h]|: Defines the size of the kernel to be used (of width $w$
%   pixels and height $h$ pixels)
% * |'Anchor',[-1,-1]|: Indicates where the anchor point (the pixel evaluated)
%   is located with respect to the neighborhood. If there is a negative value,
%   then the center of the kernel is considered the anchor point.
%

%%
% <html><h3>2. Gaussian Filter:</h3></html>
%
% It is performed by the function |cv.GaussianBlur()|:
%
%%
dbtype smoothing_demo 33:37
%%
% Here we use the following arguments:
%
% * |src|: Source image
% * |dst|: Destination image
% * |'KSize',[w,h]|: The size of the kernel to be used (the neighbors to be
%   considered). $w$ and $h$ have to be odd and positive numbers otherwise the
%   size will be calculated using the $\sigma_{x}$ and $\sigma_{y}$ arguments.
% * |'SigmaX'|: The standard deviation in x. Writing $0$ implies that
%   $\sigma_{x}$ is calculated using kernel size.
% * |'SigmaY|: The standard deviation in y. Writing $0$ implies that
%   $\sigma_{y}$ is calculated using kernel size.
%

%%
% <html><h3>3. Median Filter:</h3></html>
%
% This filter is provided by the |cv.medianBlur()| function:
%
%%
dbtype smoothing_demo 40:44
%%
% We use these arguments:
%
% * |src|: Source image
% * |dst|: Destination image, must be the same type as |src|
% * |'KSize',i|: Size of the kernel (only one because we use a square window).
%   Must be odd.
%

%%
% <html><h3>4. Bilateral Filter:</h3></html>
%
% Provided by OpenCV function |cv.bilateralFilter()|.
%
%%
dbtype smoothing_demo 47:52
%%
% We use the following arguments:
%
% * |src|: Source image
% * |dst|: Destination image
% * |'Diameter',d|: The diameter of each pixel neighborhood.
% * |'SigmaColor',sc|: Standard deviation in the color space $\sigma_{Color}$.
% * |'SigmaSpace',ss|: Standard deviation in the coordinate space (in pixel
%   terms) $\sigma_{Space}$.
%

%% Results
%
% * The code opens an image (in this case |lena.jpg|) and display it under the
%   effects of the 4 filters explained.
% * Here is a snapshot of the image smoothed using |cv.medianBlur|:
%
% <<./smoothing_demo_04.png>>
%

##### SOURCE END #####
--></body>
</html>