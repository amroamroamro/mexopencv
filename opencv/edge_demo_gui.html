<!DOCTYPE html>
<html>
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   
      <!--This HTML was auto-generated from published MATLAB code.-->
      <title>Canny Edge Detection</title>
      <meta name="generator" content="MATLAB 9.2">
      <link rel="schema.DC" href="http://purl.org/dc/elements/1.1/">
      <meta name="DC.date" content="2017-11-27">
      <meta name="DC.source" content="edge_demo_gui.m">
      <link rel="stylesheet" type="text/css" href="publish_custom.css">
   </head>
   <body>
      <div class="content">
         <h1 id="1">Canny Edge Detection</h1>
         <!--introduction-->
         <p>This sample demonstrates Canny edge detection.</p>
         <p>In this demo, we show how to use the OpenCV function <tt>cv.Canny</tt> to implement the Canny Edge Detector.
         </p>
         <p>Sources:</p>
         <div>
            <ul>
               <li><a href="https://github.com/opencv/opencv/blob/3.2.0/samples/cpp/edge.cpp">https://github.com/opencv/opencv/blob/3.2.0/samples/cpp/edge.cpp</a></li>
               <li><a href="https://github.com/opencv/opencv/blob/3.2.0/samples/python/edge.py">https://github.com/opencv/opencv/blob/3.2.0/samples/python/edge.py</a></li>
               <li><a href="https://docs.opencv.org/3.2.0/da/d5c/tutorial_canny_detector.html">https://docs.opencv.org/3.2.0/da/d5c/tutorial_canny_detector.html</a></li>
               <li><a href="https://docs.opencv.org/3.2.0/da/d22/tutorial_py_canny.html">https://docs.opencv.org/3.2.0/da/d22/tutorial_py_canny.html</a></li>
               <li><a href="https://github.com/opencv/opencv/blob/3.2.0/samples/cpp/tutorial_code/ImgTrans/CannyDetector_Demo.cpp">https://github.com/opencv/opencv/blob/3.2.0/samples/cpp/tutorial_code/ImgTrans/CannyDetector_Demo.cpp</a></li>
            </ul>
         </div>
         <!--/introduction-->
         <h2 id="toc">Contents</h2>
         <div>
            <ul>
               <li><a href="#2">Theory</a></li>
               <li><a href="#3">Steps</a></li>
               <li><a href="#4">Code</a></li>
            </ul>
         </div>
         <h2 id="2">Theory</h2>
         <p>The <i>Canny Edge detector</i> was developed by John F. Canny in 1986. Also known to many as the <i>optimal detector</i>, the Canny algorithm aims to satisfy three main criteria:
         </p>
         <div>
            <ul>
               <li><b>Low error rate:</b> Meaning a good detection of only existent edges.
               </li>
               <li><b>Good localization:</b> The distance between edge pixels detected and real   edge pixels have to be minimized.
               </li>
               <li><b>Minimal response:</b> Only one detector response per edge.
               </li>
            </ul>
         </div>
         <h2 id="3">Steps</h2>
         <p>1) Filter out any noise. The Gaussian filter is used for this purpose. An    example of a Gaussian kernel of <img src="edge_demo_gui_eq03965038263463654921.png" alt="$size = 5$" class="equation" width="52" height="11"> that might be used is shown    below:
         </p>
         <p><img src="edge_demo_gui_eq11670902784990633151.png" alt="$$K = \frac{1}{159}&#xA;      \left[{\matrix{&#xA;          2 &amp;  4 &amp;  5 &amp;  4 &amp; 2 \cr&#xA;          4 &amp;  9 &amp; 12 &amp;  9 &amp; 4 \cr&#xA;          5 &amp; 12 &amp; 15 &amp; 12 &amp; 5 \cr&#xA;          4 &amp;  9 &amp; 12 &amp;  9 &amp; 4 \cr&#xA;          2 &amp;  4 &amp;  5 &amp;  4 &amp; 2&#xA;      }}\right]$$" class="equation" width="198" height="81"></p>
         <p>2) Find the intensity gradient of the image. For this, we follow a procedure    analogous to Sobel:</p>
         <div>
            <ul>
               <li>Apply a pair of convolution masks (in <img src="edge_demo_gui_eq12428413953531653171.png" alt="$x$" class="equation" width="8" height="7"> and <img src="edge_demo_gui_eq08830444604280721118.png" alt="$y$" class="equation" width="8" height="10"> directions):
               </li>
            </ul>
         </div>
         <p><img src="edge_demo_gui_eq02149450116400633003.png" alt="$$G_{x} = \left[{\matrix{&#xA;              -1 &amp; 0 &amp; +1 \cr&#xA;              -2 &amp; 0 &amp; +2 \cr&#xA;              -1 &amp; 0 &amp; +1&#xA;          }}\right]$$" class="equation" width="131" height="53"></p>
         <p><img src="edge_demo_gui_eq08046794882505868820.png" alt="$$G_{y} = \left[{\matrix{&#xA;              -1 &amp; -2 &amp; -1 \cr&#xA;               0 &amp;  0 &amp;  0 \cr&#xA;              +1 &amp; +2 &amp; +1&#xA;          }}\right]$$" class="equation" width="142" height="53"></p>
         <div>
            <ul>
               <li>Find the gradient strength and direction. The direction is rounded to   one of four possible angles (namely 0, 45, 90 or 135)</li>
            </ul>
         </div>
         <p><img src="edge_demo_gui_eq14238734483444486568.png" alt="$$G = \sqrt{ G_{x}^{2} + G_{y}^{2} }$$" class="equation" width="99" height="27"></p>
         <p><img src="edge_demo_gui_eq10146140899898344584.png" alt="$$\theta = \arctan(\frac{ G_{y} }{ G_{x} })$$" class="equation" width="99" height="33"></p>
         <p>3) <i>Non-maximum suppression</i> is applied. This removes pixels that are not    considered to be part of an edge. Hence, only thin lines (candidate edges)
               will remain.
         </p>
         <p>4) <i>Hysteresis</i>: The final step. Canny does use two thresholds    (<i>upper</i> and <i>lower</i>). Canny recommended a <tt>upper:lower</tt> ratio between    2:1 and 3:1.
         </p>
         <div>
            <ul>
               <li>If a pixel gradient is higher than the <i>upper</i> threshold, the pixel is   accepted as an edge
               </li>
               <li>If a pixel gradient value is below the <i>lower</i> threshold, then it is   rejected.
               </li>
               <li>If the pixel gradient is between the two thresholds, then it will be   accepted only if it is connected to a pixel that is
                  above the <i>upper</i>   threshold.
               </li>
            </ul>
         </div>
         <p>For more details, you can always consult your favorite Computer Vision book.</p>
         <h2 id="4">Code</h2>
         <p>This program:</p>
         <div>
            <ul>
               <li>Asks the user to enter a numerical value to set the lower threshold for   our <i>Canny Edge Detector</i> (by means of a slider)
               </li>
               <li>Applies the <i>Canny Detector</i> and generates a <b>mask</b> (bright lines   representing the edges on a black background)
               </li>
               <li>Applies the mask obtained on the original image and display it in a window</li>
            </ul>
         </div><pre class="codeinput"><span class="keyword">function</span> varargout = edge_demo_gui(im)
    <span class="comment">% load source image</span>
    <span class="keyword">if</span> nargin &lt; 1
        im = fullfile(mexopencv.root(),<span class="string">'test'</span>,<span class="string">'fruits.jpg'</span>);
        src = cv.imread(im, <span class="string">'Color'</span>,true);
    <span class="keyword">elseif</span> ischar(im)
        src = cv.imread(im, <span class="string">'Color'</span>,true);
    <span class="keyword">else</span>
        src = im;
    <span class="keyword">end</span>

    <span class="comment">% create the UI</span>
    h = buildGUI(src);
    <span class="keyword">if</span> nargout &gt; 0, varargout{1} = h; <span class="keyword">end</span>
<span class="keyword">end</span>

<span class="keyword">function</span> onChange(~,~,h)
    <span class="comment">%ONCHANGE  Event handler for UI controls</span>

    <span class="comment">% retrieve current values from UI controls</span>
    apertures = [3, 5, 7];
    aIdx = get(h.pop, <span class="string">'Value'</span>);
    thresh = round(get(h.slid, <span class="string">'Value'</span>));
    set(h.txt, <span class="string">'String'</span>,sprintf(<span class="string">'Threshold: %3d'</span>,thresh));

    <span class="comment">% convert image to grayscale, and blur to reduce the noise</span>
    gray = cv.cvtColor(h.src, <span class="string">'RGB2GRAY'</span>);
    gray = cv.blur(gray, <span class="string">'KSize'</span>,[3 3]);

    <span class="comment">% detect edges, with 3:1 as threshold ratio</span>
    <span class="keyword">if</span> true
        <span class="comment">% default canny (Sobel gradient)</span>
        edges = cv.Canny(gray, thresh*[1 3], <span class="string">'ApertureSize'</span>,apertures(aIdx));
    <span class="keyword">else</span>
        <span class="comment">% canny with custom gradient (Scharr)</span>
        dx = cv.Scharr(gray, <span class="string">'DDepth'</span>,<span class="string">'int16'</span>, <span class="string">'XOrder'</span>,1, <span class="string">'YOrder'</span>,0);
        dy = cv.Scharr(gray, <span class="string">'DDepth'</span>,<span class="string">'int16'</span>, <span class="string">'XOrder'</span>,0, <span class="string">'YOrder'</span>,1);
        edges = cv.Canny2(dx, dy, thresh*[1 3]);
    <span class="keyword">end</span>

    <span class="comment">% apply edges mask on original image</span>
    <span class="keyword">if</span> true
        out = cv.copyTo(h.src, <span class="string">'Mask'</span>,edges);
    <span class="keyword">else</span>
        out = bsxfun(@times, h.src, uint8(edges~=0));
    <span class="keyword">end</span>

    <span class="comment">% show result</span>
    set(h.img, <span class="string">'CData'</span>,out);
    drawnow;
<span class="keyword">end</span>

<span class="keyword">function</span> h = buildGUI(img)
    <span class="comment">%BUILDGUI  Creates the UI</span>

    <span class="comment">% parameters</span>
    thresh = 10;
    max_thresh = 150;
    sz = size(img);
    sz(2) = max(sz(2), 300);  <span class="comment">% minimum figure width</span>

    <span class="comment">% build the user interface (no resizing to keep it simple)</span>
    h = struct();
    h.src = img;
    h.fig = figure(<span class="string">'Name'</span>,<span class="string">'Edge map'</span>, <span class="keyword">...</span>
        <span class="string">'NumberTitle'</span>,<span class="string">'off'</span>, <span class="string">'Menubar'</span>,<span class="string">'none'</span>, <span class="string">'Resize'</span>,<span class="string">'off'</span>, <span class="keyword">...</span>
        <span class="string">'Position'</span>,[200 200 sz(2) sz(1)+29]);
    <span class="keyword">if</span> ~mexopencv.isOctave()
        <span class="comment">%HACK: not implemented in Octave</span>
        movegui(h.fig, <span class="string">'center'</span>);
    <span class="keyword">end</span>
    h.ax = axes(<span class="string">'Parent'</span>,h.fig, <span class="keyword">...</span>
        <span class="string">'Units'</span>,<span class="string">'pixels'</span>, <span class="string">'Position'</span>,[1 30 sz(2) sz(1)]);
    <span class="keyword">if</span> ~mexopencv.isOctave()
        h.img = imshow(img, <span class="string">'Parent'</span>,h.ax);
    <span class="keyword">else</span>
        <span class="comment">%HACK: https://savannah.gnu.org/bugs/index.php?45473</span>
        axes(h.ax);
        h.img = imshow(img);
    <span class="keyword">end</span>
    uicontrol(<span class="string">'Parent'</span>,h.fig, <span class="string">'Style'</span>,<span class="string">'text'</span>, <span class="string">'FontSize'</span>,11, <span class="keyword">...</span>
        <span class="string">'Position'</span>,[5 5 65 20], <span class="string">'String'</span>,<span class="string">'Aperture'</span>);
    h.pop = uicontrol(<span class="string">'Parent'</span>,h.fig, <span class="string">'Style'</span>,<span class="string">'popupmenu'</span>, <span class="string">'Value'</span>,1, <span class="keyword">...</span>
       <span class="string">'Position'</span>,[70 5 40 20], <span class="string">'String'</span>,{<span class="string">'3'</span>,<span class="string">'5'</span>,<span class="string">'7'</span>});
    h.txt = uicontrol(<span class="string">'Parent'</span>,h.fig, <span class="string">'Style'</span>,<span class="string">'text'</span>, <span class="string">'FontSize'</span>,11, <span class="keyword">...</span>
        <span class="string">'Position'</span>,[110 5 120 20], <span class="string">'String'</span>,sprintf(<span class="string">'Threshold: %3d'</span>,thresh));
    h.slid = uicontrol(<span class="string">'Parent'</span>,h.fig, <span class="string">'Style'</span>,<span class="string">'slider'</span>, <span class="string">'Value'</span>,thresh, <span class="keyword">...</span>
        <span class="string">'Min'</span>,0, <span class="string">'Max'</span>,max_thresh, <span class="string">'SliderStep'</span>,[1 10]./(max_thresh-0), <span class="keyword">...</span>
        <span class="string">'Position'</span>,[230 5 sz(2)-230-5 20]);

    <span class="comment">% hook event handlers, and trigger default start</span>
    set([h.pop, h.slid], <span class="string">'Callback'</span>,{@onChange,h}, <span class="keyword">...</span>
        <span class="string">'Interruptible'</span>,<span class="string">'off'</span>, <span class="string">'BusyAction'</span>,<span class="string">'cancel'</span>);
    onChange([],[],h);
<span class="keyword">end</span></pre><img src="edge_demo_gui_01.png"><div class="footer">
            <p><a href="https://www.mathworks.com/products/matlab.html">Published with MATLAB&reg; R2017a</a></p>
         </div>
      </div><script type="text/x-mathjax-config">
  // https://stackoverflow.com/a/14631703/97160
  MathJax.Extension.myImg2jax = {
    version: "1.0",
    PreProcess: function (element) {
      var images = element.getElementsByTagName("img");
      for (var i = images.length - 1; i >= 0; i--) {
        var img = images[i];
        if (img.className === "equation") {
          var match = img.alt.match(/^(\$\$?)([\s\S]*)\1$/m);
          if (!match) continue;
          var script = document.createElement("script");
          script.type = "math/tex";
          if (match[1] === "$$") {script.type += ";mode=display"}
          MathJax.HTML.setScript(script, match[2]);
          img.parentNode.replaceChild(script, img);
        }
      }
    }
  };
  MathJax.Hub.Register.PreProcessor(["PreProcess", MathJax.Extension.myImg2jax]);
  </script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-AMS_CHTML"></script>
      <!--
##### SOURCE BEGIN #####
%% Canny Edge Detection
% This sample demonstrates Canny edge detection.
%
% In this demo, we show how to use the OpenCV function |cv.Canny| to implement
% the Canny Edge Detector.
%
% Sources:
%
% * <https://github.com/opencv/opencv/blob/3.2.0/samples/cpp/edge.cpp>
% * <https://github.com/opencv/opencv/blob/3.2.0/samples/python/edge.py>
% * <https://docs.opencv.org/3.2.0/da/d5c/tutorial_canny_detector.html>
% * <https://docs.opencv.org/3.2.0/da/d22/tutorial_py_canny.html>
% * <https://github.com/opencv/opencv/blob/3.2.0/samples/cpp/tutorial_code/ImgTrans/CannyDetector_Demo.cpp>
%

%% Theory
%
% The _Canny Edge detector_ was developed by John F. Canny in 1986. Also known
% to many as the _optimal detector_, the Canny algorithm aims to satisfy three
% main criteria:
%
% * *Low error rate:* Meaning a good detection of only existent edges.
% * *Good localization:* The distance between edge pixels detected and real
%   edge pixels have to be minimized.
% * *Minimal response:* Only one detector response per edge.
%
%% Steps
%
% 1) Filter out any noise. The Gaussian filter is used for this purpose. An
%    example of a Gaussian kernel of $size = 5$ that might be used is shown
%    below:
%
% $$K = \frac{1}{159}
%       \left[{\matrix{
%           2 &  4 &  5 &  4 & 2 \cr
%           4 &  9 & 12 &  9 & 4 \cr
%           5 & 12 & 15 & 12 & 5 \cr
%           4 &  9 & 12 &  9 & 4 \cr
%           2 &  4 &  5 &  4 & 2
%       }}\right]$$
%
% 2) Find the intensity gradient of the image. For this, we follow a procedure
%    analogous to Sobel:
%
% * Apply a pair of convolution masks (in $x$ and $y$ directions):
%
% $$G_{x} = \left[{\matrix{
%               -1 & 0 & +1 \cr
%               -2 & 0 & +2 \cr
%               -1 & 0 & +1
%           }}\right]$$
%
% $$G_{y} = \left[{\matrix{
%               -1 & -2 & -1 \cr
%                0 &  0 &  0 \cr
%               +1 & +2 & +1
%           }}\right]$$
%
% * Find the gradient strength and direction. The direction is rounded to
%   one of four possible angles (namely 0, 45, 90 or 135)
%
% $$G = \sqrt{ G_{x}^{2} + G_{y}^{2} }$$
%
% $$\theta = \arctan(\frac{ G_{y} }{ G_{x} })$$
%
% 3) _Non-maximum suppression_ is applied. This removes pixels that are not
%    considered to be part of an edge. Hence, only thin lines (candidate edges)
%    will remain.
%
% 4) _Hysteresis_: The final step. Canny does use two thresholds
%    (_upper_ and _lower_). Canny recommended a |upper:lower| ratio between
%    2:1 and 3:1.
%
% * If a pixel gradient is higher than the _upper_ threshold, the pixel is
%   accepted as an edge
% * If a pixel gradient value is below the _lower_ threshold, then it is
%   rejected.
% * If the pixel gradient is between the two thresholds, then it will be
%   accepted only if it is connected to a pixel that is above the _upper_
%   threshold.
%
% For more details, you can always consult your favorite Computer Vision book.
%

%% Code
%
% This program:
%
% * Asks the user to enter a numerical value to set the lower threshold for
%   our _Canny Edge Detector_ (by means of a slider)
% * Applies the _Canny Detector_ and generates a *mask* (bright lines
%   representing the edges on a black background)
% * Applies the mask obtained on the original image and display it in a window
%

function varargout = edge_demo_gui(im)
    % load source image
    if nargin < 1
        im = fullfile(mexopencv.root(),'test','fruits.jpg');
        src = cv.imread(im, 'Color',true);
    elseif ischar(im)
        src = cv.imread(im, 'Color',true);
    else
        src = im;
    end

    % create the UI
    h = buildGUI(src);
    if nargout > 0, varargout{1} = h; end
end

function onChange(~,~,h)
    %ONCHANGE  Event handler for UI controls

    % retrieve current values from UI controls
    apertures = [3, 5, 7];
    aIdx = get(h.pop, 'Value');
    thresh = round(get(h.slid, 'Value'));
    set(h.txt, 'String',sprintf('Threshold: %3d',thresh));

    % convert image to grayscale, and blur to reduce the noise
    gray = cv.cvtColor(h.src, 'RGB2GRAY');
    gray = cv.blur(gray, 'KSize',[3 3]);

    % detect edges, with 3:1 as threshold ratio
    if true
        % default canny (Sobel gradient)
        edges = cv.Canny(gray, thresh*[1 3], 'ApertureSize',apertures(aIdx));
    else
        % canny with custom gradient (Scharr)
        dx = cv.Scharr(gray, 'DDepth','int16', 'XOrder',1, 'YOrder',0);
        dy = cv.Scharr(gray, 'DDepth','int16', 'XOrder',0, 'YOrder',1);
        edges = cv.Canny2(dx, dy, thresh*[1 3]);
    end

    % apply edges mask on original image
    if true
        out = cv.copyTo(h.src, 'Mask',edges);
    else
        out = bsxfun(@times, h.src, uint8(edges~=0));
    end

    % show result
    set(h.img, 'CData',out);
    drawnow;
end

function h = buildGUI(img)
    %BUILDGUI  Creates the UI

    % parameters
    thresh = 10;
    max_thresh = 150;
    sz = size(img);
    sz(2) = max(sz(2), 300);  % minimum figure width

    % build the user interface (no resizing to keep it simple)
    h = struct();
    h.src = img;
    h.fig = figure('Name','Edge map', ...
        'NumberTitle','off', 'Menubar','none', 'Resize','off', ...
        'Position',[200 200 sz(2) sz(1)+29]);
    if ~mexopencv.isOctave()
        %HACK: not implemented in Octave
        movegui(h.fig, 'center');
    end
    h.ax = axes('Parent',h.fig, ...
        'Units','pixels', 'Position',[1 30 sz(2) sz(1)]);
    if ~mexopencv.isOctave()
        h.img = imshow(img, 'Parent',h.ax);
    else
        %HACK: https://savannah.gnu.org/bugs/index.php?45473
        axes(h.ax);
        h.img = imshow(img);
    end
    uicontrol('Parent',h.fig, 'Style','text', 'FontSize',11, ...
        'Position',[5 5 65 20], 'String','Aperture');
    h.pop = uicontrol('Parent',h.fig, 'Style','popupmenu', 'Value',1, ...
       'Position',[70 5 40 20], 'String',{'3','5','7'});
    h.txt = uicontrol('Parent',h.fig, 'Style','text', 'FontSize',11, ...
        'Position',[110 5 120 20], 'String',sprintf('Threshold: %3d',thresh));
    h.slid = uicontrol('Parent',h.fig, 'Style','slider', 'Value',thresh, ...
        'Min',0, 'Max',max_thresh, 'SliderStep',[1 10]./(max_thresh-0), ...
        'Position',[230 5 sz(2)-230-5 20]);

    % hook event handlers, and trigger default start
    set([h.pop, h.slid], 'Callback',{@onChange,h}, ...
        'Interruptible','off', 'BusyAction','cancel');
    onChange([],[],h);
end

##### SOURCE END #####
--></body>
</html>