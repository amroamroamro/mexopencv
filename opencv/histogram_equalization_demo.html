<!DOCTYPE html>
<html>
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   
      <!--This HTML was auto-generated from published MATLAB code.-->
      <title>Histogram Equalization</title>
      <meta name="generator" content="MATLAB 9.2">
      <link rel="schema.DC" href="http://purl.org/dc/elements/1.1/">
      <meta name="DC.date" content="2017-11-27">
      <meta name="DC.source" content="histogram_equalization_demo.m">
      <link rel="stylesheet" type="text/css" href="publish_custom.css">
   </head>
   <body>
      <div class="content">
         <h1 id="1">Histogram Equalization</h1>
         <!--introduction-->
         <p>In this demo, we show:</p>
         <div>
            <ul>
               <li>What an image histogram is and why it is useful</li>
               <li>How to equalize histograms of images by using the OpenCV function   <tt>cv.equalizeHist</tt></li>
            </ul>
         </div>
         <p>Sources:</p>
         <div>
            <ul>
               <li><a href="https://docs.opencv.org/3.2.0/d4/d1b/tutorial_histogram_equalization.html">https://docs.opencv.org/3.2.0/d4/d1b/tutorial_histogram_equalization.html</a></li>
               <li><a href="https://github.com/opencv/opencv/blob/3.2.0/samples/cpp/tutorial_code/Histograms_Matching/EqualizeHist_Demo.cpp">https://github.com/opencv/opencv/blob/3.2.0/samples/cpp/tutorial_code/Histograms_Matching/EqualizeHist_Demo.cpp</a></li>
            </ul>
         </div>
         <!--/introduction-->
         <h2 id="toc">Contents</h2>
         <div>
            <ul>
               <li><a href="#2">Theory</a></li>
               <li><a href="#3">Code</a></li>
               <li><a href="#9">Helper function</a></li>
            </ul>
         </div>
         <h2 id="2">Theory</h2>
         <p>An Image Histogram is a graphical representation of the intensity distribution of an image. It quantifies the number of pixels
            for each intensity value considered.
         </p>
         <p><img src="https://docs.opencv.org/3.2.0/Histogram_Equalization_Theory_0.jpg"></p>
         <p>Histogram Equalization is a method that improves the contrast in an image, in order to stretch out the intensity range. To
            make it clearer, from the image above, you can see that the pixels seem clustered around the middle of the available range
            of intensities. What Histogram Equalization does is to <i>stretch out</i> this range. Take a look at the figure below: The green circles indicate the <i>underpopulated</i> intensities. After applying the equalization, we get an histogram like the figure in the center. The resulting image is shown
            in the picture at right.
         </p>
         <p><img src="https://docs.opencv.org/3.2.0/Histogram_Equalization_Theory_1.jpg"></p>
         <p>Equalization implies <i>mapping</i> one distribution (the given histogram) to another distribution (a wider and more uniform distribution of intensity values)
            so the intensity values are spreaded over the whole range. To accomplish the equalization effect, the remapping should be
            the <i>cumulative distribution function (cdf)</i> (more details, refer to <i>Learning OpenCV</i>). For the histogram <img src="histogram_equalization_demo_eq03479968029948872532.png" alt="$H(i)$" class="equation" width="28" height="15">, its <i>cumulative distribution</i><img src="histogram_equalization_demo_eq05532304194481871879.png" alt="$H^{'}(i)$" class="equation" width="32" height="18"> is:
         </p>
         <p><img src="histogram_equalization_demo_eq03318358537360814601.png" alt="$$H^{'}(i) = \sum_{0 \le j < i} H(j)$$" class="equation" width="115" height="34"></p>
         <p>To use this as a remapping function, we have to normalize <img src="histogram_equalization_demo_eq05532304194481871879.png" alt="$H^{'}(i)$" class="equation" width="32" height="18"> such that the maximum value is 255 (or the maximum value for the intensity of the image). From the example above, the cumulative
            function is:
         </p>
         <p><img src="https://docs.opencv.org/3.2.0/Histogram_Equalization_Theory_2.jpg"></p>
         <p>Finally, we use a simple remapping procedure to obtain the intensity values of the equalized image:</p>
         <p><img src="histogram_equalization_demo_eq04780442222216052705.png" alt="$$equalized( x, y ) = H^{'}( src(x,y) )$$" class="equation" width="196" height="19"></p>
         <h2 id="3">Code</h2>
         <p>This program:</p>
         <div>
            <ul>
               <li>Loads an image</li>
               <li>Convert the original image to grayscale</li>
               <li>Equalize the Histogram by using the OpenCV function <tt>cv.equalizeHist</tt></li>
               <li>Display the source and equalized images in a window.</li>
            </ul>
         </div>
         <p>Load source 8-bit grayscale image</p><pre class="codeinput"><span class="keyword">if</span> true
    im = which(<span class="string">'pout.tif'</span>);
<span class="keyword">else</span>
    im = which(<span class="string">'tire.tif'</span>);
<span class="keyword">end</span>
<span class="keyword">if</span> isempty(im)
    im = fullfile(mexopencv.root(), <span class="string">'test'</span>, <span class="string">'sudoku.jpg'</span>);
<span class="keyword">end</span>
src = cv.imread(im, <span class="string">'Grayscale'</span>,true);</pre><p>Apply histogram equalization</p><pre class="codeinput"><span class="keyword">if</span> true
    dst = cv.equalizeHist(src);
<span class="keyword">elseif</span> mexopencv.require(<span class="string">'images'</span>)
    dst = histeq(src);
<span class="keyword">end</span></pre><p>Select function to plot 1D histogram</p><pre class="codeinput">lvl = @(I) sprintf(<span class="string">'%d unique levels'</span>, numel(unique(I(:))));
<span class="keyword">if</span> mexopencv.require(<span class="string">'images'</span>)
    histFunc = @imhist;
<span class="keyword">else</span>
    histFunc = @my_imhist;
<span class="keyword">end</span></pre><p>Display both images and their histograms</p><pre class="codeinput">subplot(221), imshow(src), title(<span class="string">'Source'</span>)
subplot(223), imshow(dst), title(<span class="string">'Equalized'</span>)
subplot(222), histFunc(src), title(lvl(src))
subplot(224), histFunc(dst), title(lvl(dst))</pre><img src="histogram_equalization_demo_01.png"><p>Notice that the pixels are clustered around the center of the histogram. After applying the equalization, the image has certainly
            more contrast. Notice how the number of pixels is more distributed through the intensity range.
         </p>
         <h2 id="9">Helper function</h2><pre class="codeinput"><span class="keyword">function</span> my_imhist(I)
    <span class="comment">% compute histogram for 8-bit grayscale image</span>
    bins = 0:255;
    counts = histc(double(I(:)), bins);

    <span class="comment">% plot intensities counts</span>
    stem(bins, counts, <span class="string">'Marker'</span>,<span class="string">'none'</span>)
    axis([0 255 0 Inf])

    <span class="comment">% plot color stripe at the bottom</span>
    yl = round(0.05 * max(counts));
    clr = repmat(uint8(bins), [10 1 3]);
    image(<span class="string">'XData'</span>,[0 255], <span class="string">'YData'</span>,[-yl 0], <span class="string">'CData'</span>,clr)
    set(gca, <span class="string">'Layer'</span>,<span class="string">'top'</span>)
    axis <span class="string">tight</span>
<span class="keyword">end</span></pre><div class="footer">
            <p><a href="https://www.mathworks.com/products/matlab.html">Published with MATLAB&reg; R2017a</a></p>
         </div>
      </div><script type="text/x-mathjax-config">
  // https://stackoverflow.com/a/14631703/97160
  MathJax.Extension.myImg2jax = {
    version: "1.0",
    PreProcess: function (element) {
      var images = element.getElementsByTagName("img");
      for (var i = images.length - 1; i >= 0; i--) {
        var img = images[i];
        if (img.className === "equation") {
          var match = img.alt.match(/^(\$\$?)([\s\S]*)\1$/m);
          if (!match) continue;
          var script = document.createElement("script");
          script.type = "math/tex";
          if (match[1] === "$$") {script.type += ";mode=display"}
          MathJax.HTML.setScript(script, match[2]);
          img.parentNode.replaceChild(script, img);
        }
      }
    }
  };
  MathJax.Hub.Register.PreProcessor(["PreProcess", MathJax.Extension.myImg2jax]);
  </script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-AMS_CHTML"></script>
      <!--
##### SOURCE BEGIN #####
%% Histogram Equalization
%
% In this demo, we show:
%
% * What an image histogram is and why it is useful
% * How to equalize histograms of images by using the OpenCV function
%   |cv.equalizeHist|
%
% Sources:
%
% * <https://docs.opencv.org/3.2.0/d4/d1b/tutorial_histogram_equalization.html>
% * <https://github.com/opencv/opencv/blob/3.2.0/samples/cpp/tutorial_code/Histograms_Matching/EqualizeHist_Demo.cpp>
%

%% Theory
%
% An Image Histogram is a graphical representation of the intensity
% distribution of an image. It quantifies the number of pixels for each
% intensity value considered.
%
% <<https://docs.opencv.org/3.2.0/Histogram_Equalization_Theory_0.jpg>>
%
% Histogram Equalization is a method that improves the contrast in an image,
% in order to stretch out the intensity range. To make it clearer, from the
% image above, you can see that the pixels seem clustered around the middle of
% the available range of intensities. What Histogram Equalization does is to
% _stretch out_ this range. Take a look at the figure below: The green circles
% indicate the _underpopulated_ intensities. After applying the equalization,
% we get an histogram like the figure in the center. The resulting image is
% shown in the picture at right.
%
% <<https://docs.opencv.org/3.2.0/Histogram_Equalization_Theory_1.jpg>>
%
% Equalization implies _mapping_ one distribution (the given histogram) to
% another distribution (a wider and more uniform distribution of intensity
% values) so the intensity values are spreaded over the whole range.
% To accomplish the equalization effect, the remapping should be the
% _cumulative distribution function (cdf)_ (more details, refer to
% _Learning OpenCV_). For the histogram $H(i)$, its _cumulative distribution_
% $H^{'}(i)$ is:
%
% $$H^{'}(i) = \sum_{0 \le j < i} H(j)$$
%
% To use this as a remapping function, we have to normalize $H^{'}(i)$ such
% that the maximum value is 255 (or the maximum value for the intensity of the
% image). From the example above, the cumulative function is:
%
% <<https://docs.opencv.org/3.2.0/Histogram_Equalization_Theory_2.jpg>>
%
% Finally, we use a simple remapping procedure to obtain the intensity values
% of the equalized image:
%
% $$equalized( x, y ) = H^{'}( src(x,y) )$$
%

%% Code
%
% This program:
%
% * Loads an image
% * Convert the original image to grayscale
% * Equalize the Histogram by using the OpenCV function |cv.equalizeHist|
% * Display the source and equalized images in a window.
%

%%
% Load source 8-bit grayscale image
if true
    im = which('pout.tif');
else
    im = which('tire.tif');
end
if isempty(im)
    im = fullfile(mexopencv.root(), 'test', 'sudoku.jpg');
end
src = cv.imread(im, 'Grayscale',true);

%%
% Apply histogram equalization
if true
    dst = cv.equalizeHist(src);
elseif mexopencv.require('images')
    dst = histeq(src);
end

%%
% Select function to plot 1D histogram
lvl = @(I) sprintf('%d unique levels', numel(unique(I(:))));
if mexopencv.require('images')
    histFunc = @imhist;
else
    histFunc = @my_imhist;
end

%%
% Display both images and their histograms
subplot(221), imshow(src), title('Source')
subplot(223), imshow(dst), title('Equalized')
subplot(222), histFunc(src), title(lvl(src))
subplot(224), histFunc(dst), title(lvl(dst))

%%
% Notice that the pixels are clustered around the center of the histogram.
% After applying the equalization, the image has certainly more contrast.
% Notice how the number of pixels is more distributed through the intensity
% range.
%

%% Helper function

function my_imhist(I)
    % compute histogram for 8-bit grayscale image
    bins = 0:255;
    counts = histc(double(I(:)), bins);

    % plot intensities counts
    stem(bins, counts, 'Marker','none')
    axis([0 255 0 Inf])

    % plot color stripe at the bottom
    yl = round(0.05 * max(counts));
    clr = repmat(uint8(bins), [10 1 3]);
    image('XData',[0 255], 'YData',[-yl 0], 'CData',clr)
    set(gca, 'Layer','top')
    axis tight
end

##### SOURCE END #####
--></body>
</html>