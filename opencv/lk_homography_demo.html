<!DOCTYPE html>
<html>
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   
      <!--This HTML was auto-generated from published MATLAB code.-->
      <title>Lucas-Kanade Homography Tracker</title>
      <meta name="generator" content="MATLAB 9.2">
      <link rel="schema.DC" href="http://purl.org/dc/elements/1.1/">
      <meta name="DC.date" content="2017-11-27">
      <meta name="DC.source" content="lk_homography_demo.m">
      <link rel="stylesheet" type="text/css" href="publish_custom.css">
   </head>
   <body>
      <div class="content">
         <h1 id="1">Lucas-Kanade Homography Tracker</h1>
         <!--introduction-->
         <p>Lucas-Kanade sparse optical flow demo. Uses <tt>cv.goodFeaturesToTrack</tt> for track initialization and back-tracking for match verification between frames. Finds homography between reference and
            current views.
         </p>
         <p>Sources:</p>
         <div>
            <ul>
               <li><a href="https://github.com/opencv/opencv/blob/3.2.0/samples/python/lk_homography.py">https://github.com/opencv/opencv/blob/3.2.0/samples/python/lk_homography.py</a></li>
            </ul>
         </div>
         <!--/introduction-->
         <h2 id="toc">Contents</h2>
         <div>
            <ul>
               <li><a href="#2">Options</a></li>
               <li><a href="#3">Video</a></li>
               <li><a href="#4">First frame</a></li>
               <li><a href="#5">Initialize</a></li>
               <li><a href="#6">Main loop</a></li>
            </ul>
         </div>
         <h2 id="2">Options</h2>
         <p>Parameters for corner detection and flow computation</p><pre class="codeinput">shi_params = {<span class="string">'MaxCorners'</span>,1000, <span class="string">'QualityLevel'</span>,0.01, <span class="string">'MinDistance'</span>,8, <span class="keyword">...</span>
    <span class="string">'BlockSize'</span>,19};
lk_params = {<span class="string">'WinSize'</span>,[19 19], <span class="string">'MaxLevel'</span>,2, <span class="keyword">...</span>
    <span class="string">'Criteria'</span>,struct(<span class="string">'type'</span>,<span class="string">'Count+EPS'</span>, <span class="string">'maxCount'</span>,10, <span class="string">'epsilon'</span>,0.03)};</pre><h2 id="3">Video</h2>
         <p>Prepare video source</p><pre class="codeinput"><span class="keyword">if</span> true
    vid = 0;
<span class="keyword">elseif</span> true
    vid = fullfile(mexopencv.root(), <span class="string">'test'</span>, <span class="string">'768x576.avi'</span>);
<span class="keyword">elseif</span> mexopencv.require(<span class="string">'vision'</span>)
    vid = fullfile(toolboxdir(<span class="string">'vision'</span>), <span class="string">'visiondata'</span>, <span class="string">'visiontraffic.avi'</span>);
<span class="keyword">end</span>
cap = createVideoCapture([], <span class="string">'chess'</span>);
assert(cap.isOpened(), <span class="string">'Failed to initialize capturing'</span>);</pre><h2 id="4">First frame</h2>
         <p>Grab first frame</p><pre class="codeinput">frame0 = cap.read();
assert(~isempty(frame0), <span class="string">'Failed to read frame'</span>);
sz = [size(frame0,2), size(frame0,1)];  <span class="comment">% [width,height]</span></pre><h2 id="5">Initialize</h2><pre class="codeinput"><span class="comment">% Plot</span>
hImg = imshow(frame0);
title(<span class="string">'Lucas-Kanade homography tracker'</span>)

<span class="comment">% UI widgets to control app state</span>
algs = {<span class="string">'0'</span>, <span class="string">'Ransac'</span>, <span class="string">'LMedS'</span>, <span class="string">'Rho'</span>};
hBtn = uicontrol(<span class="string">'Style'</span>,<span class="string">'pushbutton'</span>, <span class="string">'Position'</span>,[20 20 120 20], <span class="keyword">...</span>
    <span class="string">'String'</span>,<span class="string">'Start tracking'</span>, <span class="string">'Callback'</span>,@(o,~) set(o, <span class="string">'Enable'</span>,<span class="string">'off'</span>));
hCB = uicontrol(<span class="string">'Style'</span>,<span class="string">'popupmenu'</span>, <span class="string">'Position'</span>,[140 20 120 20], <span class="keyword">...</span>
    <span class="string">'String'</span>,algs, <span class="string">'Value'</span>,2);</pre><img src="lk_homography_demo_01.png"><h2 id="6">Main loop</h2><pre class="codeinput">p0 = {};  <span class="comment">% stores points to track</span>
<span class="keyword">while</span> ishghandle(hImg)
    <span class="comment">% Grab next frame</span>
    frame = cap.read();
    <span class="keyword">if</span> isempty(frame), <span class="keyword">break</span>; <span class="keyword">end</span>
    next = cv.cvtColor(frame, <span class="string">'RGB2GRAY'</span>);

    out = frame;
    <span class="keyword">if</span> ~isempty(p0)
        <span class="comment">% track points in forward and backward direction, and check trace</span>
        p2 = cv.calcOpticalFlowPyrLK(prev, next, p1, lk_params{:});
        p1r = cv.calcOpticalFlowPyrLK(next, prev, p2, lk_params{:});
        good = cellfun(@(a,b) max(abs(a - b)), p1, p1r) &lt; 1.0;

        <span class="comment">% keep good matches</span>
        p0 = p0(good);
        p1 = p2(good);
        prev = next;  <span class="comment">% next iteration</span>
        str = sprintf(<span class="string">'track count: %d'</span>, numel(p1));

        <span class="comment">% we need at least 4 pairs of points to estimate homography</span>
        <span class="keyword">if</span> numel(p1) &lt; 4
            p0 = {};
            <span class="keyword">continue</span>;
        <span class="keyword">end</span>

        <span class="comment">% compute perspective transformation, and apply it on reference image</span>
        <span class="comment">% (homography between ref points and their currently tracked locations)</span>
        [H, inliers] = cv.findHomography(p0, p1, <span class="keyword">...</span>
            <span class="string">'Method'</span>,algs{get(hCB, <span class="string">'Value'</span>)}, <span class="string">'RansacReprojThreshold'</span>,10.0);
        overlay = cv.warpPerspective(frame0, H, <span class="string">'DSize'</span>,sz);
        out = cv.addWeighted(out,0.5, overlay,0.5, 0.0);

        <span class="comment">% draw points correspondances (inliers/outliers used in estimating H)</span>
        inliers = logical(inliers);
        out = cv.line(out, p0(inliers), p1(inliers), <span class="string">'Color'</span>,[0 128 0]);
        out = cv.line(out, p0(~inliers), p1(~inliers), <span class="string">'Color'</span>,[128 0 0]);
        out = cv.circle(out, p1(inliers), 2, <span class="string">'Thickness'</span>,<span class="string">'Filled'</span>, <span class="string">'Color'</span>,[0 255 0]);
        out = cv.circle(out, p1(~inliers), 2, <span class="string">'Thickness'</span>,<span class="string">'Filled'</span>, <span class="string">'Color'</span>,[255 0 0]);
    <span class="keyword">else</span>
        <span class="comment">% detect and show corners</span>
        p1 = cv.goodFeaturesToTrack(next, shi_params{:});
        str = sprintf(<span class="string">'feature count: %d'</span>, numel(p1));
        <span class="keyword">if</span> ~isempty(p1)
            out = cv.circle(out, p1, 2, <span class="string">'Thickness'</span>,<span class="string">'Filled'</span>, <span class="string">'Color'</span>,[0 0 255]);
        <span class="keyword">end</span>
    <span class="keyword">end</span>

    <span class="comment">% display points count</span>
    out = cv.putText(out, str, [20 20], <span class="keyword">...</span>
        <span class="string">'FontScale'</span>,0.5, <span class="string">'Color'</span>,[255 255 0], <span class="string">'LineType'</span>,<span class="string">'AA'</span>);

    <span class="comment">% check if track button was clicked</span>
    <span class="keyword">if</span> strcmp(get(hBtn, <span class="string">'Enable'</span>), <span class="string">'off'</span>)
        <span class="comment">% save reference frame, and initialize reference points to track</span>
        frame0 = frame;
        p0 = cv.goodFeaturesToTrack(next, shi_params{:});
        <span class="keyword">if</span> ~isempty(p0)
            <span class="comment">% init points and gray image updated each iteration while tracking</span>
            p1 = p0;
            prev = next;
        <span class="keyword">end</span>
        set(hBtn, <span class="string">'Enable'</span>,<span class="string">'on'</span>);
    <span class="keyword">end</span>

    <span class="comment">% Display result</span>
    set(hImg, <span class="string">'CData'</span>,out);
    drawnow;
<span class="keyword">end</span>
cap.release();</pre><img src="lk_homography_demo_02.png"><div class="footer">
            <p><a href="https://www.mathworks.com/products/matlab.html">Published with MATLAB&reg; R2017a</a></p>
         </div>
      </div>
      <!--
##### SOURCE BEGIN #####
%% Lucas-Kanade Homography Tracker
%
% Lucas-Kanade sparse optical flow demo. Uses |cv.goodFeaturesToTrack| for
% track initialization and back-tracking for match verification between
% frames. Finds homography between reference and current views.
%
% Sources:
%
% * <https://github.com/opencv/opencv/blob/3.2.0/samples/python/lk_homography.py>
%

%% Options
% Parameters for corner detection and flow computation
shi_params = {'MaxCorners',1000, 'QualityLevel',0.01, 'MinDistance',8, ...
    'BlockSize',19};
lk_params = {'WinSize',[19 19], 'MaxLevel',2, ...
    'Criteria',struct('type','Count+EPS', 'maxCount',10, 'epsilon',0.03)};

%% Video
% Prepare video source
if true
    vid = 0;
elseif true
    vid = fullfile(mexopencv.root(), 'test', '768x576.avi');
elseif mexopencv.require('vision')
    vid = fullfile(toolboxdir('vision'), 'visiondata', 'visiontraffic.avi');
end
cap = createVideoCapture([], 'chess');
assert(cap.isOpened(), 'Failed to initialize capturing');

%% First frame
% Grab first frame
frame0 = cap.read();
assert(~isempty(frame0), 'Failed to read frame');
sz = [size(frame0,2), size(frame0,1)];  % [width,height]

%% Initialize

% Plot
hImg = imshow(frame0);
title('Lucas-Kanade homography tracker')

% UI widgets to control app state
algs = {'0', 'Ransac', 'LMedS', 'Rho'};
hBtn = uicontrol('Style','pushbutton', 'Position',[20 20 120 20], ...
    'String','Start tracking', 'Callback',@(o,~) set(o, 'Enable','off'));
hCB = uicontrol('Style','popupmenu', 'Position',[140 20 120 20], ...
    'String',algs, 'Value',2);

%% Main loop
p0 = {};  % stores points to track
while ishghandle(hImg)
    % Grab next frame
    frame = cap.read();
    if isempty(frame), break; end
    next = cv.cvtColor(frame, 'RGB2GRAY');

    out = frame;
    if ~isempty(p0)
        % track points in forward and backward direction, and check trace
        p2 = cv.calcOpticalFlowPyrLK(prev, next, p1, lk_params{:});
        p1r = cv.calcOpticalFlowPyrLK(next, prev, p2, lk_params{:});
        good = cellfun(@(a,b) max(abs(a - b)), p1, p1r) < 1.0;

        % keep good matches
        p0 = p0(good);
        p1 = p2(good);
        prev = next;  % next iteration
        str = sprintf('track count: %d', numel(p1));

        % we need at least 4 pairs of points to estimate homography
        if numel(p1) < 4
            p0 = {};
            continue;
        end

        % compute perspective transformation, and apply it on reference image
        % (homography between ref points and their currently tracked locations)
        [H, inliers] = cv.findHomography(p0, p1, ...
            'Method',algs{get(hCB, 'Value')}, 'RansacReprojThreshold',10.0);
        overlay = cv.warpPerspective(frame0, H, 'DSize',sz);
        out = cv.addWeighted(out,0.5, overlay,0.5, 0.0);

        % draw points correspondances (inliers/outliers used in estimating H)
        inliers = logical(inliers);
        out = cv.line(out, p0(inliers), p1(inliers), 'Color',[0 128 0]);
        out = cv.line(out, p0(~inliers), p1(~inliers), 'Color',[128 0 0]);
        out = cv.circle(out, p1(inliers), 2, 'Thickness','Filled', 'Color',[0 255 0]);
        out = cv.circle(out, p1(~inliers), 2, 'Thickness','Filled', 'Color',[255 0 0]);
    else
        % detect and show corners
        p1 = cv.goodFeaturesToTrack(next, shi_params{:});
        str = sprintf('feature count: %d', numel(p1));
        if ~isempty(p1)
            out = cv.circle(out, p1, 2, 'Thickness','Filled', 'Color',[0 0 255]);
        end
    end

    % display points count
    out = cv.putText(out, str, [20 20], ...
        'FontScale',0.5, 'Color',[255 255 0], 'LineType','AA');

    % check if track button was clicked
    if strcmp(get(hBtn, 'Enable'), 'off')
        % save reference frame, and initialize reference points to track
        frame0 = frame;
        p0 = cv.goodFeaturesToTrack(next, shi_params{:});
        if ~isempty(p0)
            % init points and gray image updated each iteration while tracking
            p1 = p0;
            prev = next;
        end
        set(hBtn, 'Enable','on');
    end

    % Display result
    set(hImg, 'CData',out);
    drawnow;
end
cap.release();

##### SOURCE END #####
-->
   </body>
</html>