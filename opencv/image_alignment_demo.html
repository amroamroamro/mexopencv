<!DOCTYPE html>
<html>
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   
      <!--This HTML was auto-generated from published MATLAB code.-->
      <title>Image Alignment using ECC algorithm</title>
      <meta name="generator" content="MATLAB 9.2">
      <link rel="schema.DC" href="http://purl.org/dc/elements/1.1/">
      <meta name="DC.date" content="2017-11-27">
      <meta name="DC.source" content="image_alignment_demo.m">
      <link rel="stylesheet" type="text/css" href="publish_custom.css">
   </head>
   <body>
      <div class="content">
         <h1 id="1">Image Alignment using ECC algorithm</h1>
         <!--introduction-->
         <p>This sample demostrates the use of the ECC image alignment algorithm. When one image is given, the template image is artificially
            formed by a random warp given the motion type. Otherwise supply both images. If input warp matrix is not specified, the identity
            transformation is used to initialize the algorithm.
         </p>
         <p>Sources:</p>
         <div>
            <ul>
               <li><a href="https://github.com/opencv/opencv/blob/3.2.0/samples/cpp/image_alignment.cpp">https://github.com/opencv/opencv/blob/3.2.0/samples/cpp/image_alignment.cpp</a></li>
            </ul>
         </div>
         <!--/introduction-->
         <h2 id="toc">Contents</h2>
         <div>
            <ul>
               <li><a href="#2">Options</a></li>
               <li><a href="#5">Input image</a></li>
               <li><a href="#6">Template image</a></li>
               <li><a href="#7">Input warp matrix</a></li>
               <li><a href="#8">Estimate transformation</a></li>
               <li><a href="#10">Apply estimated transformation</a></li>
            </ul>
         </div>
         <h2 id="2">Options</h2><pre class="codeinput">INPUT_IMAGE = fullfile(mexopencv.root(), <span class="string">'test'</span>, <span class="string">'fruits.jpg'</span>);
LOAD_TEMPLATE = false;
LOAD_MAT = false;
MOTION_TYPE = <span class="string">'Affine'</span>;</pre><p>type of motion</p><pre class="codeinput">MOTION_TYPE = validatestring(MOTION_TYPE, <span class="keyword">...</span>
    {<span class="string">'Translation'</span>, <span class="string">'Euclidean'</span>, <span class="string">'Affine'</span>, <span class="string">'Homography'</span>});</pre><p>termination criteria (ECC iterations and convergnce epsilon)</p><pre class="codeinput">CRIT = struct(<span class="string">'type'</span>,<span class="string">'Count+EPS'</span>, <span class="string">'maxCount'</span>,50, <span class="string">'epsilon'</span>,1e-4);
<span class="keyword">if</span> CRIT.maxCount &gt; 200
    warning(<span class="string">'Too many iterations'</span>);
<span class="keyword">end</span></pre><h2 id="5">Input image</h2>
         <p>load input image</p><pre class="codeinput">imgInput = cv.imread(INPUT_IMAGE, <span class="string">'Grayscale'</span>,true);</pre><h2 id="6">Template image</h2>
         <p>initialize or load template image</p><pre class="codeinput">M0 = [];
<span class="keyword">if</span> LOAD_TEMPLATE
    <span class="comment">% load an existing template image</span>
    fmts = imformats();
    filtspec = strjoin(strcat(<span class="string">'*.'</span>, [fmts.ext]), <span class="string">';'</span>);
    [fn,fp] = uigetfile(filtspec, <span class="string">'Select an image'</span>);
    <span class="keyword">if</span> fp==0, error(<span class="string">'No file selected'</span>); <span class="keyword">end</span>
    imgTemplate = cv.imread(fullfile(fp,fn), <span class="string">'Grayscale'</span>,true);
<span class="keyword">else</span>
    <span class="comment">% create a template image by applying a random warp to input image</span>
    imgInput = cv.resize(imgInput, [216 216]);
    opts = {<span class="string">'DSize'</span>,[200 200], <span class="string">'Interpolation'</span>,<span class="string">'Linear'</span>, <span class="string">'WarpInverse'</span>,true};
    <span class="keyword">switch</span> MOTION_TYPE
        <span class="keyword">case</span> <span class="string">'Translation'</span>
            M0 = [1 0 rand*10+10;
                  0 1 rand*10+10];
            imgTemplate = cv.warpAffine(imgInput, M0, opts{:});
        <span class="keyword">case</span> <span class="string">'Euclidean'</span>
            theta = pi/30 + pi*randi([-2 2])/180;
            M0 = [cos(theta) -sin(theta) rand*10+10;
                  sin(theta)  cos(theta) rand*10+10];
            imgTemplate = cv.warpAffine(imgInput, M0, opts{:});
        <span class="keyword">case</span> <span class="string">'Affine'</span>
            M0 = [1-(rand*0.1-0.05)    rand*0.06-0.03 rand*10+10;
                     rand*0.06-0.03 1-(rand*0.1-0.05) rand*10+10];
            imgTemplate = cv.warpAffine(imgInput, M0, opts{:});
        <span class="keyword">case</span> <span class="string">'Homography'</span>
            M0 = [1-(rand*0.1-0.05)    rand*0.06-0.03 rand*10+10;
                     rand*0.06-0.03 1-(rand*0.1-0.05) rand*10+10;
                     rand*2e-4+2e-4    rand*2e-4+2e-4 1];
            imgTemplate = cv.warpPerspective(imgInput, M0, opts{:});
    <span class="keyword">end</span>
    display(M0)  <span class="comment">% ground truth</span>
<span class="keyword">end</span>
sz = size(imgTemplate);</pre><pre class="codeoutput">M0 =
    1.0196    0.0089   17.8664
   -0.0236    1.0216   18.8430
</pre><h2 id="7">Input warp matrix</h2>
         <p>initialize or load warp matrix</p><pre class="codeinput">M = [];
<span class="keyword">if</span> LOAD_MAT
    <span class="comment">% load from a MAT-file</span>
    uiopen(<span class="string">'load'</span>);
    assert(~isempty(M), <span class="string">'Failed to load warp matrix M'</span>);
    <span class="keyword">if</span> strcmp(MOTION_TYPE, <span class="string">'Homography'</span>)
        assert(isequal(size(M), [3 3]));
    <span class="keyword">else</span>
        assert(isequal(size(M), [2 3]));
    <span class="keyword">end</span>
<span class="keyword">else</span>
    <span class="comment">% identity matrix</span>
    <span class="keyword">if</span> strcmp(MOTION_TYPE, <span class="string">'Homography'</span>)
        M = eye(3,3);
    <span class="keyword">else</span>
        M = eye(2,3);
    <span class="keyword">end</span>
    warning([<span class="string">'Performance Warning: Identity warp ideally assumes images '</span> <span class="keyword">...</span>
        <span class="string">'of similar size. If the deformation is strong, the identity '</span> <span class="keyword">...</span>
        <span class="string">'warp may not be a good initialization, and estimation may fail.'</span>]);
<span class="keyword">end</span>
display(M)</pre><pre class="codeoutput">Warning: Performance Warning: Identity warp ideally assumes images of similar
size. If the deformation is strong, the identity warp may not be a good
initialization, and estimation may fail. 
M =
     1     0     0
     0     1     0
</pre><h2 id="8">Estimate transformation</h2><pre class="codeinput">fprintf(<span class="string">'Estimating "%s" transformation...\n'</span>, MOTION_TYPE);
tic
M = cv.findTransformECC(imgTemplate, imgInput, <span class="keyword">...</span>
    <span class="string">'InputWarp'</span>,M, <span class="string">'MotionType'</span>,MOTION_TYPE, <span class="string">'Criteria'</span>,CRIT);
toc
display(M)</pre><pre class="codeoutput">Estimating "Affine" transformation...
Elapsed time is 0.180881 seconds.
M =
  2&times;3 single matrix
    1.0195    0.0090   17.8705
   -0.0235    1.0216   18.8507
</pre><p>compare against ground truth</p><pre class="codeinput"><span class="keyword">if</span> ~isempty(M0)
    err = norm(M - M0)
<span class="keyword">end</span></pre><pre class="codeoutput">err =
  single
    0.0088
</pre><h2 id="10">Apply estimated transformation</h2>
         <p>warped image</p><pre class="codeinput">opts = {<span class="string">'DSize'</span>,[sz(2) sz(1)], <span class="string">'Interpolation'</span>,<span class="string">'Linear'</span>, <span class="string">'WarpInverse'</span>,true};
<span class="keyword">if</span> strcmp(MOTION_TYPE, <span class="string">'Homography'</span>)
    imgWarped = cv.warpPerspective(imgInput, M, opts{:});
<span class="keyword">else</span>
    imgWarped = cv.warpAffine(imgInput, M, opts{:});
<span class="keyword">end</span></pre><p>compare against template image</p><pre class="codeinput"><span class="keyword">if</span> ~mexopencv.isOctave() &amp;&amp; mexopencv.require(<span class="string">'vision'</span>)
    imgError = imfuse(imgTemplate, imgWarped, <span class="string">'diff'</span>);
<span class="keyword">else</span>
    imgError = abs(double(imgTemplate) - double(imgWarped));
    imgError = imgError / max(imgError(:));
<span class="keyword">end</span></pre><p>compute region boundary in input image corresponding to template image</p><pre class="codeinput">pts = [1 1; sz(2) 1; sz(2) sz(1); 1 sz(1)]; <span class="comment">% corners to warp (TL/TR/BR/BL)</span>
pts(:,3) = 1;  <span class="comment">% homogeneous coordinates</span>
<span class="keyword">if</span> strcmp(MOTION_TYPE, <span class="string">'Homography'</span>)
    pts = pts * M.';
<span class="keyword">else</span>
    pts = pts * [M; 0 0 1].';
<span class="keyword">end</span>
pts = bsxfun(@rdivide, pts(:,1:2), pts(:,3));</pre><p>show results</p><pre class="codeinput">subplot(221), imshow(imgInput), title(<span class="string">'image'</span>)
line(pts([1:end 1],1), pts([1:end 1],2), <span class="string">'Color'</span>,<span class="string">'m'</span>, <span class="string">'LineWidth'</span>,2)
axis <span class="string">tight</span>
subplot(222), imshow(imgTemplate), title(<span class="string">'template'</span>)
subplot(223), imshow(imgWarped), title(<span class="string">'warped image'</span>)
subplot(224), imshow(imgError), title(<span class="string">'error'</span>)</pre><img src="image_alignment_demo_01.png"><div class="footer">
            <p><a href="https://www.mathworks.com/products/matlab.html">Published with MATLAB&reg; R2017a</a></p>
         </div>
      </div>
      <!--
##### SOURCE BEGIN #####
%% Image Alignment using ECC algorithm
%
% This sample demostrates the use of the ECC image alignment algorithm. When
% one image is given, the template image is artificially formed by a random
% warp given the motion type. Otherwise supply both images. If input warp
% matrix is not specified, the identity transformation is used to initialize
% the algorithm.
%
% Sources:
%
% * <https://github.com/opencv/opencv/blob/3.2.0/samples/cpp/image_alignment.cpp>
%

%% Options
INPUT_IMAGE = fullfile(mexopencv.root(), 'test', 'fruits.jpg');
LOAD_TEMPLATE = false;
LOAD_MAT = false;
MOTION_TYPE = 'Affine';

%%
% type of motion
MOTION_TYPE = validatestring(MOTION_TYPE, ...
    {'Translation', 'Euclidean', 'Affine', 'Homography'});

%%
% termination criteria (ECC iterations and convergnce epsilon)
CRIT = struct('type','Count+EPS', 'maxCount',50, 'epsilon',1e-4);
if CRIT.maxCount > 200
    warning('Too many iterations');
end

%% Input image
% load input image
imgInput = cv.imread(INPUT_IMAGE, 'Grayscale',true);

%% Template image
% initialize or load template image
M0 = [];
if LOAD_TEMPLATE
    % load an existing template image
    fmts = imformats();
    filtspec = strjoin(strcat('*.', [fmts.ext]), ';');
    [fn,fp] = uigetfile(filtspec, 'Select an image');
    if fp==0, error('No file selected'); end
    imgTemplate = cv.imread(fullfile(fp,fn), 'Grayscale',true);
else
    % create a template image by applying a random warp to input image
    imgInput = cv.resize(imgInput, [216 216]);
    opts = {'DSize',[200 200], 'Interpolation','Linear', 'WarpInverse',true};
    switch MOTION_TYPE
        case 'Translation'
            M0 = [1 0 rand*10+10;
                  0 1 rand*10+10];
            imgTemplate = cv.warpAffine(imgInput, M0, opts{:});
        case 'Euclidean'
            theta = pi/30 + pi*randi([-2 2])/180;
            M0 = [cos(theta) -sin(theta) rand*10+10;
                  sin(theta)  cos(theta) rand*10+10];
            imgTemplate = cv.warpAffine(imgInput, M0, opts{:});
        case 'Affine'
            M0 = [1-(rand*0.1-0.05)    rand*0.06-0.03 rand*10+10;
                     rand*0.06-0.03 1-(rand*0.1-0.05) rand*10+10];
            imgTemplate = cv.warpAffine(imgInput, M0, opts{:});
        case 'Homography'
            M0 = [1-(rand*0.1-0.05)    rand*0.06-0.03 rand*10+10;
                     rand*0.06-0.03 1-(rand*0.1-0.05) rand*10+10;
                     rand*2e-4+2e-4    rand*2e-4+2e-4 1];
            imgTemplate = cv.warpPerspective(imgInput, M0, opts{:});
    end
    display(M0)  % ground truth
end
sz = size(imgTemplate);

%% Input warp matrix
% initialize or load warp matrix
M = [];
if LOAD_MAT
    % load from a MAT-file
    uiopen('load');
    assert(~isempty(M), 'Failed to load warp matrix M');
    if strcmp(MOTION_TYPE, 'Homography')
        assert(isequal(size(M), [3 3]));
    else
        assert(isequal(size(M), [2 3]));
    end
else
    % identity matrix
    if strcmp(MOTION_TYPE, 'Homography')
        M = eye(3,3);
    else
        M = eye(2,3);
    end
    warning(['Performance Warning: Identity warp ideally assumes images ' ...
        'of similar size. If the deformation is strong, the identity ' ...
        'warp may not be a good initialization, and estimation may fail.']);
end
display(M)

%% Estimate transformation
fprintf('Estimating "%s" transformation...\n', MOTION_TYPE);
tic
M = cv.findTransformECC(imgTemplate, imgInput, ...
    'InputWarp',M, 'MotionType',MOTION_TYPE, 'Criteria',CRIT);
toc
display(M)

%%
% compare against ground truth
if ~isempty(M0)
    err = norm(M - M0)
end

%% Apply estimated transformation
% warped image
opts = {'DSize',[sz(2) sz(1)], 'Interpolation','Linear', 'WarpInverse',true};
if strcmp(MOTION_TYPE, 'Homography')
    imgWarped = cv.warpPerspective(imgInput, M, opts{:});
else
    imgWarped = cv.warpAffine(imgInput, M, opts{:});
end

%%
% compare against template image
if ~mexopencv.isOctave() && mexopencv.require('vision')
    imgError = imfuse(imgTemplate, imgWarped, 'diff');
else
    imgError = abs(double(imgTemplate) - double(imgWarped));
    imgError = imgError / max(imgError(:));
end

%%
% compute region boundary in input image corresponding to template image
pts = [1 1; sz(2) 1; sz(2) sz(1); 1 sz(1)]; % corners to warp (TL/TR/BR/BL)
pts(:,3) = 1;  % homogeneous coordinates
if strcmp(MOTION_TYPE, 'Homography')
    pts = pts * M.';
else
    pts = pts * [M; 0 0 1].';
end
pts = bsxfun(@rdivide, pts(:,1:2), pts(:,3));

%%
% show results
subplot(221), imshow(imgInput), title('image')
line(pts([1:end 1],1), pts([1:end 1],2), 'Color','m', 'LineWidth',2)
axis tight
subplot(222), imshow(imgTemplate), title('template')
subplot(223), imshow(imgWarped), title('warped image')
subplot(224), imshow(imgError), title('error')

##### SOURCE END #####
-->
   </body>
</html>