<!DOCTYPE html>
<html>
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   
      <!--This HTML was auto-generated from published MATLAB code.-->
      <title>Smile Detection</title>
      <meta name="generator" content="MATLAB 9.2">
      <link rel="schema.DC" href="http://purl.org/dc/elements/1.1/">
      <meta name="DC.date" content="2017-11-27">
      <meta name="DC.source" content="smiledetect_demo.m">
      <link rel="stylesheet" type="text/css" href="publish_custom.css">
   </head>
   <body>
      <div class="content">
         <h1 id="1">Smile Detection</h1>
         <!--introduction-->
         <p>This program demonstrates the smile detector.</p>
         <p>NOTE: Smile intensity will only be valid after a first smile has been detected.</p>
         <p>Sources:</p>
         <div>
            <ul>
               <li><a href="https://github.com/opencv/opencv/blob/3.1.0/samples/cpp/smiledetect.cpp">https://github.com/opencv/opencv/blob/3.1.0/samples/cpp/smiledetect.cpp</a></li>
            </ul>
         </div>
         <!--/introduction-->
         <h2 id="toc">Contents</h2>
         <div>
            <ul>
               <li><a href="#2">Options</a></li>
               <li><a href="#3">Initialize</a></li>
               <li><a href="#4">Main loop</a></li>
               <li><a href="#5">Process function</a></li>
               <li><a href="#6">Helper function</a></li>
            </ul>
         </div>
         <h2 id="2">Options</h2><pre class="codeinput"><span class="comment">% this is the frontal face classifier</span>
cascadeName = fullfile(mexopencv.root(),<span class="string">'test'</span>,<span class="string">'haarcascade_frontalface_alt.xml'</span>);
<span class="comment">% this is the secondary smile classifier</span>
nestedCascadeName = fullfile(mexopencv.root(),<span class="string">'test'</span>,<span class="string">'haarcascade_smile.xml'</span>);
<span class="comment">% image scale greater or equal to 1, try 2.0 for example,</span>
<span class="comment">% the larger the faster the processing</span>
scale = 1.0;
<span class="comment">% attempts detection of flipped image as well</span>
tryflip = false;</pre><h2 id="3">Initialize</h2><pre class="codeinput"><span class="comment">% download XML files if missing</span>
download_classifier_xml(cascadeName);
download_classifier_xml(nestedCascadeName);

<span class="comment">% load cacade classifiers</span>
cascade = cv.CascadeClassifier(cascadeName);
assert(~cascade.empty(), <span class="string">'Could not load face cascade'</span>);
nestedCascade = cv.CascadeClassifier(nestedCascadeName);
assert(~nestedCascade.empty(), <span class="string">'Could not load smile cascade'</span>);
scale = max(scale, 1.0);</pre><h2 id="4">Main loop</h2>
         <p>(either video feed or a still image)</p><pre class="codeinput"><span class="keyword">if</span> false
    <span class="comment">% read an image</span>
    frame = cv.imread(fullfile(mexopencv.root(),<span class="string">'test'</span>,<span class="string">'lena.jpg'</span>), <span class="string">'Color'</span>,true);
    <span class="comment">% detect faces/eyes and draw detections</span>
    frame = detectAndDraw(frame, cascade, nestedCascade, scale, tryflip);
    imshow(frame);
<span class="keyword">else</span>
    <span class="comment">% prepare video input</span>
    cap = createVideoCapture([], <span class="string">'lena'</span>);
    pause(1);
    assert(cap.isOpened(), <span class="string">'Failed to initialize camera capture'</span>);

    <span class="comment">% prepare figure</span>
    frame = cap.read();
    assert(~isempty(frame), <span class="string">'Failed to read frame'</span>);
    hImg = imshow(frame);

    <span class="comment">% video feed</span>
    <span class="keyword">while</span> ishghandle(hImg)
        <span class="comment">% read frame</span>
        frame = cap.read();
        <span class="keyword">if</span> isempty(frame), <span class="keyword">break</span>; <span class="keyword">end</span>

        <span class="comment">% detect faces/eyes and draw detections</span>
        frame = detectAndDraw(frame, cascade, nestedCascade, scale, tryflip);

        <span class="comment">% update</span>
        set(hImg, <span class="string">'CData'</span>,frame);
        drawnow;
    <span class="keyword">end</span>
    cap.release();
<span class="keyword">end</span></pre><img src="smiledetect_demo_01.png"><h2 id="5">Process function</h2><pre class="codeinput"><span class="keyword">function</span> img = detectAndDraw(img, cascadeF, cascadeS, scale, tryflip)
    <span class="comment">% smile min/max neighbors</span>
    <span class="keyword">persistent</span> minNB maxNB;

    <span class="comment">% downscale image and preprocess it</span>
    fx = 1/scale;
    gray = cv.cvtColor(img, <span class="string">'RGB2GRAY'</span>);
    gray = cv.resize(gray, fx, fx);
    gray = cv.equalizeHist(gray);
    [h,w] = size(gray);

    <span class="comment">% detection options</span>
    detectOpts = {
        <span class="string">'ScaleFactor'</span>,1.1, <span class="keyword">...</span>
        <span class="string">'MinNeighbors'</span>,2, <span class="keyword">...</span>
        <span class="keyword">...</span><span class="comment"> 'FindBiggestObject',true, ...</span>
        <span class="keyword">...</span><span class="comment"> 'DoRoughSearch',true, ...</span>
        <span class="string">'ScaleImage'</span>,true, <span class="keyword">...</span>
        <span class="string">'MinSize'</span>,[30 30]
    };

    <span class="comment">% detect faces</span>
    tic
    faces = cascadeF.detect(gray, detectOpts{:});
    <span class="keyword">if</span> tryflip
        faces2 = cascadeF.detect(cv.flip(gray, 1), detectOpts{:});
        faces2 = cellfun(@(r) [w-r(1)-r(3) r(2:4)], faces2, <span class="string">'Uniform'</span>,false);
        faces = [faces(:); faces2(:)];
    <span class="keyword">end</span>
    toc

    <span class="comment">% draw</span>
    clrs = uint8(255 * lines(7));
    <span class="keyword">for</span> i=1:numel(faces)
        r = faces{i};
        ii = mod(i-1, size(clrs,1)) + 1;
        drawOpts = {<span class="string">'Color'</span>,clrs(ii,:), <span class="string">'Thickness'</span>,3};

        <span class="comment">% draw faces</span>
        aspect_ratio = r(3)/r(4);
        <span class="keyword">if</span> 0.75 &lt; aspect_ratio &amp;&amp; aspect_ratio &lt; 1.3
            center = round((r(1:2) + r(3:4)*0.5) * scale);
            radius = round((r(3) + r(4)) * 0.25*scale);
            img = cv.circle(img, center, radius, drawOpts{:});
        <span class="keyword">else</span>
            pt1 = round(r(1:2) * scale);
            pt2 = round((r(1:2) + r(3:4) - 1) * scale);
            img = cv.rectangle(img, pt1, pt2, drawOpts{:});
        <span class="keyword">end</span>

        <span class="comment">% detect nested objects (smile) in lower half of face</span>
        half_height = round(r(4)/2);
        r(2) = r(2) + half_height;
        r(4) = half_height - 1;
        <span class="keyword">if</span> false &amp;&amp; mexopencv.require(<span class="string">'images'</span>)
            grayROI = imcrop(gray, [r(1:2)+1 r(3:4)]);
        <span class="keyword">else</span>
            grayROI = cv.Rect.crop(gray, r);
        <span class="keyword">end</span>
        nestedObjs = cascadeS.detect(grayROI, <span class="keyword">...</span>
            <span class="string">'ScaleFactor'</span>,1.1, <span class="keyword">...</span>
            <span class="string">'MinNeighbors'</span>,0, <span class="keyword">...</span>
            <span class="keyword">...</span><span class="comment"> 'FindBiggestObject',true, ...</span>
            <span class="keyword">...</span><span class="comment"> 'DoRoughSearch',true, ...</span>
            <span class="keyword">...</span><span class="comment"> 'DoCannyPruning',true, ...</span>
            <span class="string">'ScaleImage'</span>,true, <span class="keyword">...</span>
            <span class="string">'MinSize'</span>,[30 30]);

        <span class="comment">% The number of detected neighbors depends on image size (and also</span>
        <span class="comment">% illumination, etc.). The following steps use a floating minimum</span>
        <span class="comment">% and maximum of neighbors. Intensity thus estimated will be accurate</span>
        <span class="comment">% only after a first smile has been displayed by the user.</span>
        smileNB = numel(nestedObjs);
        <span class="keyword">if</span> isempty(minNB)
            minNB = smileNB;
            maxNB = smileNB;
        <span class="keyword">end</span>
        maxNB = max(maxNB, smileNB);

        <span class="comment">% draw rectangle bar on left side of image reflecting smile intensity</span>
        intensity = (smileNB - minNB) / (maxNB - minNB + 1);
        h_rect = round(h * intensity);
        clr = round([255 * intensity, 0, 0]);
        img = cv.rectangle(img, [0 h], [round(w/10) h-h_rect], <span class="keyword">...</span>
            <span class="string">'Color'</span>,clr, <span class="string">'Thickness'</span>,<span class="string">'Filled'</span>);
    <span class="keyword">end</span>
<span class="keyword">end</span></pre><pre class="codeoutput">Elapsed time is 0.075507 seconds.
Elapsed time is 0.056394 seconds.
Elapsed time is 0.059050 seconds.
Elapsed time is 0.058014 seconds.
Elapsed time is 0.062390 seconds.
Elapsed time is 0.058634 seconds.
Elapsed time is 0.054683 seconds.
Elapsed time is 0.054191 seconds.
Elapsed time is 0.053590 seconds.
Elapsed time is 0.056938 seconds.
Elapsed time is 0.061333 seconds.
Elapsed time is 0.059133 seconds.
Elapsed time is 0.053069 seconds.
Elapsed time is 0.059209 seconds.
Elapsed time is 0.058121 seconds.
Elapsed time is 0.056840 seconds.
Elapsed time is 0.059636 seconds.
Elapsed time is 0.056073 seconds.
Elapsed time is 0.058268 seconds.
Elapsed time is 0.055052 seconds.
Elapsed time is 0.056169 seconds.
Elapsed time is 0.054429 seconds.
Elapsed time is 0.054508 seconds.
Elapsed time is 0.054266 seconds.
Elapsed time is 0.053605 seconds.
Elapsed time is 0.054506 seconds.
Elapsed time is 0.054681 seconds.
Elapsed time is 0.054852 seconds.
Elapsed time is 0.055301 seconds.
Elapsed time is 0.060512 seconds.
Elapsed time is 0.053368 seconds.
Elapsed time is 0.055298 seconds.
Elapsed time is 0.054175 seconds.
Elapsed time is 0.055073 seconds.
Elapsed time is 0.054710 seconds.
Elapsed time is 0.054834 seconds.
Elapsed time is 0.053693 seconds.
Elapsed time is 0.053870 seconds.
Elapsed time is 0.054673 seconds.
Elapsed time is 0.054641 seconds.
Elapsed time is 0.054990 seconds.
Elapsed time is 0.054420 seconds.
Elapsed time is 0.053657 seconds.
Elapsed time is 0.054728 seconds.
Elapsed time is 0.054503 seconds.
Elapsed time is 0.053485 seconds.
Elapsed time is 0.053717 seconds.
Elapsed time is 0.053619 seconds.
Elapsed time is 0.054895 seconds.
Elapsed time is 0.054330 seconds.
</pre><img src="smiledetect_demo_02.png"><h2 id="6">Helper function</h2><pre class="codeinput"><span class="keyword">function</span> download_classifier_xml(fname)
    <span class="keyword">if</span> exist(fname, <span class="string">'file'</span>) ~= 2
        <span class="comment">% attempt to download trained Haar/LBP/HOG classifier from Github</span>
        url = <span class="string">'https://cdn.rawgit.com/opencv/opencv/3.2.0/data/'</span>;
        [~, f, ext] = fileparts(fname);
        <span class="keyword">if</span> strncmpi(f, <span class="string">'haarcascade_'</span>, length(<span class="string">'haarcascade_'</span>))
            url = [url, <span class="string">'haarcascades/'</span>];
        <span class="keyword">elseif</span> strncmpi(f, <span class="string">'lbpcascade_'</span>, length(<span class="string">'lbpcascade_'</span>))
            url = [url, <span class="string">'lbpcascades/'</span>];
        <span class="keyword">elseif</span> strncmpi(f, <span class="string">'hogcascade_'</span>, length(<span class="string">'hogcascade_'</span>))
            url = [url, <span class="string">'hogcascades/'</span>];
        <span class="keyword">else</span>
            error(<span class="string">'File not found'</span>);
        <span class="keyword">end</span>
        fprintf(<span class="string">'Downloading cascade classifier "%s"...\n'</span>, [f ext]);
        url = [url f ext];
        urlwrite(url, fname);
    <span class="keyword">end</span>
<span class="keyword">end</span></pre><div class="footer">
            <p><a href="https://www.mathworks.com/products/matlab.html">Published with MATLAB&reg; R2017a</a></p>
         </div>
      </div>
      <!--
##### SOURCE BEGIN #####
%% Smile Detection
% This program demonstrates the smile detector.
%
% NOTE: Smile intensity will only be valid after a first smile has been
% detected.
%
% Sources:
%
% * <https://github.com/opencv/opencv/blob/3.1.0/samples/cpp/smiledetect.cpp>
%

%% Options

% this is the frontal face classifier
cascadeName = fullfile(mexopencv.root(),'test','haarcascade_frontalface_alt.xml');
% this is the secondary smile classifier
nestedCascadeName = fullfile(mexopencv.root(),'test','haarcascade_smile.xml');
% image scale greater or equal to 1, try 2.0 for example,
% the larger the faster the processing
scale = 1.0;
% attempts detection of flipped image as well
tryflip = false;

%% Initialize

% download XML files if missing
download_classifier_xml(cascadeName);
download_classifier_xml(nestedCascadeName);

% load cacade classifiers
cascade = cv.CascadeClassifier(cascadeName);
assert(~cascade.empty(), 'Could not load face cascade');
nestedCascade = cv.CascadeClassifier(nestedCascadeName);
assert(~nestedCascade.empty(), 'Could not load smile cascade');
scale = max(scale, 1.0);

%% Main loop
% (either video feed or a still image)
if false
    % read an image
    frame = cv.imread(fullfile(mexopencv.root(),'test','lena.jpg'), 'Color',true);
    % detect faces/eyes and draw detections
    frame = detectAndDraw(frame, cascade, nestedCascade, scale, tryflip);
    imshow(frame);
else
    % prepare video input
    cap = createVideoCapture([], 'lena');
    pause(1);
    assert(cap.isOpened(), 'Failed to initialize camera capture');

    % prepare figure
    frame = cap.read();
    assert(~isempty(frame), 'Failed to read frame');
    hImg = imshow(frame);

    % video feed
    while ishghandle(hImg)
        % read frame
        frame = cap.read();
        if isempty(frame), break; end

        % detect faces/eyes and draw detections
        frame = detectAndDraw(frame, cascade, nestedCascade, scale, tryflip);

        % update
        set(hImg, 'CData',frame);
        drawnow;
    end
    cap.release();
end

%% Process function

function img = detectAndDraw(img, cascadeF, cascadeS, scale, tryflip)
    % smile min/max neighbors
    persistent minNB maxNB;

    % downscale image and preprocess it
    fx = 1/scale;
    gray = cv.cvtColor(img, 'RGB2GRAY');
    gray = cv.resize(gray, fx, fx);
    gray = cv.equalizeHist(gray);
    [h,w] = size(gray);

    % detection options
    detectOpts = {
        'ScaleFactor',1.1, ...
        'MinNeighbors',2, ...
        ... 'FindBiggestObject',true, ...
        ... 'DoRoughSearch',true, ...
        'ScaleImage',true, ...
        'MinSize',[30 30]
    };

    % detect faces
    tic
    faces = cascadeF.detect(gray, detectOpts{:});
    if tryflip
        faces2 = cascadeF.detect(cv.flip(gray, 1), detectOpts{:});
        faces2 = cellfun(@(r) [w-r(1)-r(3) r(2:4)], faces2, 'Uniform',false);
        faces = [faces(:); faces2(:)];
    end
    toc

    % draw
    clrs = uint8(255 * lines(7));
    for i=1:numel(faces)
        r = faces{i};
        ii = mod(i-1, size(clrs,1)) + 1;
        drawOpts = {'Color',clrs(ii,:), 'Thickness',3};

        % draw faces
        aspect_ratio = r(3)/r(4);
        if 0.75 < aspect_ratio && aspect_ratio < 1.3
            center = round((r(1:2) + r(3:4)*0.5) * scale);
            radius = round((r(3) + r(4)) * 0.25*scale);
            img = cv.circle(img, center, radius, drawOpts{:});
        else
            pt1 = round(r(1:2) * scale);
            pt2 = round((r(1:2) + r(3:4) - 1) * scale);
            img = cv.rectangle(img, pt1, pt2, drawOpts{:});
        end

        % detect nested objects (smile) in lower half of face
        half_height = round(r(4)/2);
        r(2) = r(2) + half_height;
        r(4) = half_height - 1;
        if false && mexopencv.require('images')
            grayROI = imcrop(gray, [r(1:2)+1 r(3:4)]);
        else
            grayROI = cv.Rect.crop(gray, r);
        end
        nestedObjs = cascadeS.detect(grayROI, ...
            'ScaleFactor',1.1, ...
            'MinNeighbors',0, ...
            ... 'FindBiggestObject',true, ...
            ... 'DoRoughSearch',true, ...
            ... 'DoCannyPruning',true, ...
            'ScaleImage',true, ...
            'MinSize',[30 30]);

        % The number of detected neighbors depends on image size (and also
        % illumination, etc.). The following steps use a floating minimum
        % and maximum of neighbors. Intensity thus estimated will be accurate
        % only after a first smile has been displayed by the user.
        smileNB = numel(nestedObjs);
        if isempty(minNB)
            minNB = smileNB;
            maxNB = smileNB;
        end
        maxNB = max(maxNB, smileNB);

        % draw rectangle bar on left side of image reflecting smile intensity
        intensity = (smileNB - minNB) / (maxNB - minNB + 1);
        h_rect = round(h * intensity);
        clr = round([255 * intensity, 0, 0]);
        img = cv.rectangle(img, [0 h], [round(w/10) h-h_rect], ...
            'Color',clr, 'Thickness','Filled');
    end
end

%% Helper function

function download_classifier_xml(fname)
    if exist(fname, 'file') ~= 2
        % attempt to download trained Haar/LBP/HOG classifier from Github
        url = 'https://cdn.rawgit.com/opencv/opencv/3.2.0/data/';
        [~, f, ext] = fileparts(fname);
        if strncmpi(f, 'haarcascade_', length('haarcascade_'))
            url = [url, 'haarcascades/'];
        elseif strncmpi(f, 'lbpcascade_', length('lbpcascade_'))
            url = [url, 'lbpcascades/'];
        elseif strncmpi(f, 'hogcascade_', length('hogcascade_'))
            url = [url, 'hogcascades/'];
        else
            error('File not found');
        end
        fprintf('Downloading cascade classifier "%s"...\n', [f ext]);
        url = [url f ext];
        urlwrite(url, fname);
    end
end

##### SOURCE END #####
-->
   </body>
</html>