<!DOCTYPE html>
<html>
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   
      <!--This HTML was auto-generated from published MATLAB code.-->
      <title>Multi-Scale Turing Patterns Generator</title>
      <meta name="generator" content="MATLAB 9.2">
      <link rel="schema.DC" href="http://purl.org/dc/elements/1.1/">
      <meta name="DC.date" content="2017-11-27">
      <meta name="DC.source" content="turing_patterns_demo.m">
      <link rel="stylesheet" type="text/css" href="publish_custom.css">
   </head>
   <body>
      <div class="content">
         <h1 id="1">Multi-Scale Turing Patterns Generator</h1>
         <p>Inspired by: <a href="http://www.jonathanmccabe.com/Cyclic_Symmetric_Multi-Scale_Turing_Patterns.pdf">http://www.jonathanmccabe.com/Cyclic_Symmetric_Multi-Scale_Turing_Patterns.pdf</a></p>
         <p>Sources:</p>
         <div>
            <ul>
               <li><a href="https://github.com/opencv/opencv/blob/3.2.0/samples/python/turing.py">https://github.com/opencv/opencv/blob/3.2.0/samples/python/turing.py</a></li>
            </ul>
         </div><pre class="codeinput"><span class="keyword">function</span> turing_patterns_demo()</pre><p>Options</p><pre class="codeinput">    sz = 512;          <span class="comment">% image size, should be 2^n</span>
    nscales = 6;       <span class="comment">% number of pyramid levels, less than log2(sz)</span>
    write_vid = true;  <span class="comment">% whether to save as video</span></pre><p>Initialize</p><pre class="codeinput">    a = rand(sz,sz);
    ms = zeros(sz,sz,nscales);
    vs = zeros(sz,sz,nscales);
    [R,C] = ndgrid(1:sz);</pre><p>Prepare plot</p><pre class="codeinput">    hImg = imshow(a);
    title(<span class="string">'frame 0'</span>)</pre><img src="turing_patterns_demo_01.png"><p>Prepare video writer</p><pre class="codeinput">    <span class="keyword">if</span> write_vid
        <span class="keyword">if</span> true
            <span class="comment">% builtin MJPG encoder, should work across all systems</span>
            vidext = <span class="string">'avi'</span>;
            fourcc = <span class="string">'MJPG'</span>;
        <span class="keyword">else</span>
            <span class="comment">% FFmpeg in OpenCV can use OpenH264 for encoding H.264,</span>
            <span class="comment">% download binaries and set OPENH264_LIBRARY environment variable</span>
            <span class="comment">% https://github.com/opencv/opencv/tree/3.3.1/3rdparty/ffmpeg</span>
            <span class="comment">% https://github.com/cisco/openh264/releases</span>
            vidext = <span class="string">'mp4'</span>;
            fourcc = <span class="string">'H264'</span>;
        <span class="keyword">end</span>
        vidfile = fullfile(tempdir(), [<span class="string">'turing.'</span> vidext]);
        vid = cv.VideoWriter(vidfile, [sz sz], <span class="string">'FourCC'</span>,fourcc);
        assert(vid.isOpened(), <span class="string">'Could not open output video'</span>);
    <span class="keyword">end</span></pre><p>Main loop</p><pre class="codeinput">    counter = 0;
    <span class="keyword">while</span> ishghandle(hImg)
        counter = counter + 1;
        <span class="keyword">if</span> counter &gt; 100, <span class="keyword">break</span>; <span class="keyword">end</span>

        <span class="comment">% update pattern</span>
        a_lods = cv.buildPyramid(a, <span class="string">'MaxLevel'</span>,nscales);
        <span class="keyword">for</span> i=1:nscales
            [ms(:,:,i), vs(:,:,i)] = process_scale(a_lods, i);
        <span class="keyword">end</span>
        [~,mi] = min(vs, [], 3);
        mi = sub2ind([sz sz nscales], R, C, mi);
        a = a + ms(mi) * 0.025;
        a = (a - min(a(:))) / (max(a(:)) - min(a(:)));

        <span class="comment">% write video frame</span>
        <span class="keyword">if</span> write_vid
            frame = repmat(uint8(a*255), [1 1 3]); <span class="comment">% 8-bit RGB</span>
            vid.write(frame);
        <span class="keyword">end</span>

        <span class="comment">% show result</span>
        set(hImg, <span class="string">'CData'</span>,a);
        title(sprintf(<span class="string">'frame %d'</span>,counter));
        drawnow;
    <span class="keyword">end</span></pre><img src="turing_patterns_demo_02.png"><p>Finalize video</p><pre class="codeinput">    <span class="keyword">if</span> write_vid
        vid.release();
        fprintf(<span class="string">'Video saved: %s\n'</span>, vidfile);
        <span class="keyword">if</span> ispc() &amp;&amp; ~mexopencv.isOctave()
            <span class="comment">%HACK: WINOPEN not implemented in Octave</span>
            winopen(vidfile);
        <span class="keyword">end</span>
    <span class="keyword">end</span></pre><pre class="codeoutput">Video saved: C:\Users\Amro\AppData\Local\Temp\turing.avi
</pre><pre class="codeinput"><span class="keyword">end</span></pre><p>Helper function</p><pre class="codeinput"><span class="keyword">function</span> [m,v] = process_scale(a_lods, lod)
    d = a_lods{lod} - cv.pyrUp(a_lods{lod+1});
    <span class="keyword">for</span> i=2:lod
        d = cv.pyrUp(d);
    <span class="keyword">end</span>
    m = sign(d);
    v = cv.GaussianBlur(d.*d, <span class="string">'KSize'</span>,[3 3]);
<span class="keyword">end</span></pre><div class="footer">
            <p><a href="https://www.mathworks.com/products/matlab.html">Published with MATLAB&reg; R2017a</a></p>
         </div>
      </div>
      <!--
##### SOURCE BEGIN #####
%% Multi-Scale Turing Patterns Generator
%
% Inspired by:
% <http://www.jonathanmccabe.com/Cyclic_Symmetric_Multi-Scale_Turing_Patterns.pdf>
%
% Sources:
%
% * <https://github.com/opencv/opencv/blob/3.2.0/samples/python/turing.py>
%

function turing_patterns_demo()
    %%
    % Options
    sz = 512;          % image size, should be 2^n
    nscales = 6;       % number of pyramid levels, less than log2(sz)
    write_vid = true;  % whether to save as video

    %%
    % Initialize
    a = rand(sz,sz);
    ms = zeros(sz,sz,nscales);
    vs = zeros(sz,sz,nscales);
    [R,C] = ndgrid(1:sz);

    %%
    % Prepare plot
    hImg = imshow(a);
    title('frame 0')

    %%
    % Prepare video writer
    if write_vid
        if true
            % builtin MJPG encoder, should work across all systems
            vidext = 'avi';
            fourcc = 'MJPG';
        else
            % FFmpeg in OpenCV can use OpenH264 for encoding H.264,
            % download binaries and set OPENH264_LIBRARY environment variable
            % https://github.com/opencv/opencv/tree/3.3.1/3rdparty/ffmpeg
            % https://github.com/cisco/openh264/releases
            vidext = 'mp4';
            fourcc = 'H264';
        end
        vidfile = fullfile(tempdir(), ['turing.' vidext]);
        vid = cv.VideoWriter(vidfile, [sz sz], 'FourCC',fourcc);
        assert(vid.isOpened(), 'Could not open output video');
    end

    %%
    % Main loop
    counter = 0;
    while ishghandle(hImg)
        counter = counter + 1;
        if counter > 100, break; end

        % update pattern
        a_lods = cv.buildPyramid(a, 'MaxLevel',nscales);
        for i=1:nscales
            [ms(:,:,i), vs(:,:,i)] = process_scale(a_lods, i);
        end
        [~,mi] = min(vs, [], 3);
        mi = sub2ind([sz sz nscales], R, C, mi);
        a = a + ms(mi) * 0.025;
        a = (a - min(a(:))) / (max(a(:)) - min(a(:)));

        % write video frame
        if write_vid
            frame = repmat(uint8(a*255), [1 1 3]); % 8-bit RGB
            vid.write(frame);
        end

        % show result
        set(hImg, 'CData',a);
        title(sprintf('frame %d',counter));
        drawnow;
    end

    %%
    % Finalize video
    if write_vid
        vid.release();
        fprintf('Video saved: %s\n', vidfile);
        if ispc() && ~mexopencv.isOctave()
            %HACK: WINOPEN not implemented in Octave
            winopen(vidfile);
        end
    end
end

%%
% Helper function

function [m,v] = process_scale(a_lods, lod)
    d = a_lods{lod} - cv.pyrUp(a_lods{lod+1});
    for i=2:lod
        d = cv.pyrUp(d);
    end
    m = sign(d);
    v = cv.GaussianBlur(d.*d, 'KSize',[3 3]);
end

##### SOURCE END #####
-->
   </body>
</html>