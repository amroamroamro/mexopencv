<!DOCTYPE html>
<html>
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   
      <!--This HTML was auto-generated from published MATLAB code.-->
      <title>Sobel Derivatives</title>
      <meta name="generator" content="MATLAB 9.2">
      <link rel="schema.DC" href="http://purl.org/dc/elements/1.1/">
      <meta name="DC.date" content="2017-11-27">
      <meta name="DC.source" content="sobel_derivatives_demo.m">
      <link rel="stylesheet" type="text/css" href="publish_custom.css">
   </head>
   <body>
      <div class="content">
         <h1 id="1">Sobel Derivatives</h1>
         <!--introduction-->
         <p>In this demo, we show how to:</p>
         <div>
            <ul>
               <li>Use the OpenCV function <tt>cv.Sobel</tt> to calculate the derivatives of an   image
               </li>
               <li>Use the OpenCV function <tt>cv.Scharr</tt> to calculate a more accurate   derivative for a kernel of size 3x3
               </li>
            </ul>
         </div>
         <p>Sources:</p>
         <div>
            <ul>
               <li><a href="https://docs.opencv.org/3.2.0/d2/d2c/tutorial_sobel_derivatives.html">https://docs.opencv.org/3.2.0/d2/d2c/tutorial_sobel_derivatives.html</a></li>
               <li><a href="https://github.com/opencv/opencv/blob/3.2.0/samples/cpp/tutorial_code/ImgTrans/Sobel_Demo.cpp">https://github.com/opencv/opencv/blob/3.2.0/samples/cpp/tutorial_code/ImgTrans/Sobel_Demo.cpp</a></li>
            </ul>
         </div>
         <!--/introduction-->
         <h2 id="toc">Contents</h2>
         <div>
            <ul>
               <li><a href="#2">Theory</a></li>
               <li><a href="#3">Sobel Operator</a></li>
               <li><a href="#4">Code</a></li>
            </ul>
         </div>
         <h2 id="2">Theory</h2>
         <p>NOTE: The explanation below belongs to the book <b>Learning OpenCV</b> by Bradski and Kaehler.
         </p>
         <p>We have previously seen applicative examples of convolutions. One of the most important convolutions is the computation of
            derivatives in an image (or an approximation to them). Why may be important the calculus of the derivatives in an image? Let's
            imagine we want to detect the <i>edges</i> present in the image. For instance:
         </p>
         <p><img src="https://docs.opencv.org/3.2.0/Sobel_Derivatives_Tutorial_Theory_0.jpg"></p>
         <p>You can easily notice that in an <i>edge</i>, the pixel intensity <i>changes</i> in a notorious way. A good way to express <i>changes</i> is by using <i>derivatives</i>. A high change in gradient indicates a major change in the image.
         </p>
         <p>To be more graphical, let's assume we have a 1D-image. An edge is shown by the "jump" in intensity in the plot below:</p>
         <p><img src="https://docs.opencv.org/3.2.0/Sobel_Derivatives_Tutorial_Theory_Intensity_Function.jpg"></p>
         <p>The edge "jump" can be seen more easily if we take the first derivative (actually, here appears as a maximum)</p>
         <p><img src="https://docs.opencv.org/3.2.0/Sobel_Derivatives_Tutorial_Theory_dIntensity_Function.jpg"></p>
         <p>So, from the explanation above, we can deduce that a method to detect edges in an image can be performed by locating pixel
            locations where the gradient is higher than its neighbors (or to generalize, higher than a threshold).
         </p>
         <h2 id="3">Sobel Operator</h2>
         <p>The Sobel Operator is a discrete differentiation operator. It computes an approximation of the gradient of an image intensity
            function. The Sobel Operator combines Gaussian smoothing and differentiation.
         </p>
         <p>Assuming that the image to be operated is <img src="sobel_derivatives_demo_eq17419315245227113761.png" alt="$I$" class="equation" width="7" height="10">, we calculate two derivatives:
         </p>
         <div>
            <ul>
               <li><b>Horizontal changes</b>: This is computed by convolving <img src="sobel_derivatives_demo_eq17419315245227113761.png" alt="$I$" class="equation" width="7" height="10"> with a kernel   <img src="sobel_derivatives_demo_eq00201572125125534939.png" alt="$G_{x}$" class="equation" width="17" height="13"> with odd size. For example for a kernel size of 3, <img src="sobel_derivatives_demo_eq00201572125125534939.png" alt="$G_{x}$" class="equation" width="17" height="13"> would   be computed as:
               </li>
            </ul>
         </div>
         <p><img src="sobel_derivatives_demo_eq04666574786809751963.png" alt="$$G_{x} = \left[{\matrix{&#xA;              -1 &amp; 0 &amp; +1 \cr&#xA;              -2 &amp; 0 &amp; +2 \cr&#xA;              -1 &amp; 0 &amp; +1&#xA;          }}\right] * I$$" class="equation" width="158" height="53"></p>
         <div>
            <ul>
               <li><b>Vertical changes</b>: This is computed by convolving <img src="sobel_derivatives_demo_eq17419315245227113761.png" alt="$I$" class="equation" width="7" height="10"> with a kernel   <img src="sobel_derivatives_demo_eq02919576929696158823.png" alt="$G_{y}$" class="equation" width="17" height="15"> with odd size. For example for a kernel size of 3, <img src="sobel_derivatives_demo_eq02919576929696158823.png" alt="$G_{y}$" class="equation" width="17" height="15"> would   be computed as:
               </li>
            </ul>
         </div>
         <p><img src="sobel_derivatives_demo_eq09223113082135733548.png" alt="$$G_{y} = \left[{\matrix{&#xA;              -1 &amp; -2 &amp; -1 \cr&#xA;               0 &amp;  0 &amp;  0 \cr&#xA;              +1 &amp; +2 &amp; +1&#xA;          }}\right] * I$$" class="equation" width="168" height="53"></p>
         <p>At each point of the image we calculate an approximation of the <i>gradient</i> in that point by combining both results above:
         </p>
         <p><img src="sobel_derivatives_demo_eq14238734483444486568.png" alt="$$G = \sqrt{ G_{x}^{2} + G_{y}^{2} }$$" class="equation" width="99" height="27"></p>
         <p>Although sometimes the following simpler equation is used:</p>
         <p><img src="sobel_derivatives_demo_eq16276151840134168166.png" alt="$$G = |G_{x}| + |G_{y}|$$" class="equation" width="99" height="16"></p>
         <p>Note: When the size of the kernel is <tt>3</tt>, the Sobel kernel shown above may produce noticeable inaccuracies (after all, Sobel is only an approximation of the derivative).
            OpenCV addresses this inaccuracy for kernels of size 3 by using the <tt>cv.Scharr</tt> function. This is as fast but more accurate than the standar Sobel function. It implements the following kernels:
         </p>
         <p><img src="sobel_derivatives_demo_eq07565735840016019644.png" alt="$$G_{x} = \left[{\matrix{&#xA;               -3 &amp; 0 &amp;  +3 \cr&#xA;              -10 &amp; 0 &amp; +10 \cr&#xA;               -3 &amp; 0 &amp;  +3&#xA;          }}\right]$$" class="equation" width="146" height="53"></p>
         <p><img src="sobel_derivatives_demo_eq13096381759275009548.png" alt="$$G_{y} = \left[{\matrix{&#xA;              -3 &amp; -10 &amp; -3 \cr&#xA;               0 &amp;   0 &amp;  0 \cr&#xA;              +3 &amp; +10 &amp; +3&#xA;          }}\right]$$" class="equation" width="150" height="53"></p>
         <p>Note: You can check out more information of this function in the OpenCV reference (<tt>cv.Scharr</tt>). Also, in the sample code below, you will notice that above the code for <tt>cv.Sobel</tt> function there is also code for the <tt>cv.Scharr</tt> function commented. Enabling it should give you an idea of how this function works.
         </p>
         <h2 id="4">Code</h2>
         <p>The program below applies the <i>Sobel Operator</i> and generates as output an image with the detected <i>edges</i> bright on a darker background.
         </p>
         <p>load source image</p><pre class="codeinput">src = cv.imread(fullfile(mexopencv.root(),<span class="string">'test'</span>,<span class="string">'lena.jpg'</span>), <span class="string">'Color'</span>,true);</pre><p>apply a Gaussian blur to reduce the noise</p><pre class="codeinput">src = cv.GaussianBlur(src, <span class="string">'KSize'</span>,[3 3]);</pre><p>convert filtered image to grayscale</p><pre class="codeinput">gray = cv.cvtColor(src, <span class="string">'RGB2GRAY'</span>);</pre><p>calculate the derivatives in x and y directions (input is 8-bit, we set the output image depth to 16-bit to avoid overflow)</p><pre class="codeinput"><span class="keyword">if</span> true
    gradx = cv.Sobel(gray, <span class="string">'XOrder'</span>,1, <span class="string">'YOrder'</span>,0, <span class="string">'DDepth'</span>,<span class="string">'int16'</span>);
    grady = cv.Sobel(gray, <span class="string">'XOrder'</span>,0, <span class="string">'YOrder'</span>,1, <span class="string">'DDepth'</span>,<span class="string">'int16'</span>);
<span class="keyword">else</span>
    gradx = cv.Scharr(gray, <span class="string">'XOrder'</span>,1, <span class="string">'YOrder'</span>,0, <span class="string">'DDepth'</span>,<span class="string">'int16'</span>);
    grady = cv.Scharr(gray, <span class="string">'XOrder'</span>,0, <span class="string">'YOrder'</span>,1, <span class="string">'DDepth'</span>,<span class="string">'int16'</span>);
<span class="keyword">end</span></pre><p>take absolute value and convert our partial results back to 8-bit</p><pre class="codeinput">gradxabs = cv.convertScaleAbs(gradx);
gradyabs = cv.convertScaleAbs(grady);</pre><p>approximate the gradient by adding both directional gradients (this is not an exact calculation, but it is good for our purposes)</p><pre class="codeinput">grad = cv.addWeighted(gradxabs,0.5, gradyabs,0.5, 0.0);</pre><p>show result</p><pre class="codeinput">imshow(grad)
title(<span class="string">'Sobel Demo - Simple Edge Detector'</span>)</pre><img src="sobel_derivatives_demo_01.png"><div class="footer">
            <p><a href="https://www.mathworks.com/products/matlab.html">Published with MATLAB&reg; R2017a</a></p>
         </div>
      </div><script type="text/x-mathjax-config">
  // https://stackoverflow.com/a/14631703/97160
  MathJax.Extension.myImg2jax = {
    version: "1.0",
    PreProcess: function (element) {
      var images = element.getElementsByTagName("img");
      for (var i = images.length - 1; i >= 0; i--) {
        var img = images[i];
        if (img.className === "equation") {
          var match = img.alt.match(/^(\$\$?)([\s\S]*)\1$/m);
          if (!match) continue;
          var script = document.createElement("script");
          script.type = "math/tex";
          if (match[1] === "$$") {script.type += ";mode=display"}
          MathJax.HTML.setScript(script, match[2]);
          img.parentNode.replaceChild(script, img);
        }
      }
    }
  };
  MathJax.Hub.Register.PreProcessor(["PreProcess", MathJax.Extension.myImg2jax]);
  </script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-AMS_CHTML"></script>
      <!--
##### SOURCE BEGIN #####
%% Sobel Derivatives
%
% In this demo, we show how to:
%
% * Use the OpenCV function |cv.Sobel| to calculate the derivatives of an
%   image
% * Use the OpenCV function |cv.Scharr| to calculate a more accurate
%   derivative for a kernel of size 3x3
%
% Sources:
%
% * <https://docs.opencv.org/3.2.0/d2/d2c/tutorial_sobel_derivatives.html>
% * <https://github.com/opencv/opencv/blob/3.2.0/samples/cpp/tutorial_code/ImgTrans/Sobel_Demo.cpp>
%

%% Theory
%
% NOTE: The explanation below belongs to the book *Learning OpenCV* by
% Bradski and Kaehler.
%
% We have previously seen applicative examples of convolutions. One of the
% most important convolutions is the computation of derivatives in an image
% (or an approximation to them). Why may be important the calculus of the
% derivatives in an image? Let's imagine we want to detect the _edges_ present
% in the image. For instance:
%
% <<https://docs.opencv.org/3.2.0/Sobel_Derivatives_Tutorial_Theory_0.jpg>>
%
% You can easily notice that in an _edge_, the pixel intensity _changes_ in a
% notorious way. A good way to express _changes_ is by using _derivatives_. A
% high change in gradient indicates a major change in the image.
%
% To be more graphical, let's assume we have a 1D-image. An edge is shown by
% the "jump" in intensity in the plot below:
%
% <<https://docs.opencv.org/3.2.0/Sobel_Derivatives_Tutorial_Theory_Intensity_Function.jpg>>
%
% The edge "jump" can be seen more easily if we take the first derivative
% (actually, here appears as a maximum)
%
% <<https://docs.opencv.org/3.2.0/Sobel_Derivatives_Tutorial_Theory_dIntensity_Function.jpg>>
%
% So, from the explanation above, we can deduce that a method to detect edges
% in an image can be performed by locating pixel locations where the gradient
% is higher than its neighbors (or to generalize, higher than a threshold).
%
%% Sobel Operator
%
% The Sobel Operator is a discrete differentiation operator. It computes an
% approximation of the gradient of an image intensity function. The Sobel
% Operator combines Gaussian smoothing and differentiation.
%
% Assuming that the image to be operated is $I$, we calculate two derivatives:
%
% * *Horizontal changes*: This is computed by convolving $I$ with a kernel
%   $G_{x}$ with odd size. For example for a kernel size of 3, $G_{x}$ would
%   be computed as:
%
% $$G_{x} = \left[{\matrix{
%               -1 & 0 & +1 \cr
%               -2 & 0 & +2 \cr
%               -1 & 0 & +1
%           }}\right] * I$$
%
% * *Vertical changes*: This is computed by convolving $I$ with a kernel
%   $G_{y}$ with odd size. For example for a kernel size of 3, $G_{y}$ would
%   be computed as:
%
% $$G_{y} = \left[{\matrix{
%               -1 & -2 & -1 \cr
%                0 &  0 &  0 \cr
%               +1 & +2 & +1
%           }}\right] * I$$
%
% At each point of the image we calculate an approximation of the _gradient_
% in that point by combining both results above:
%
% $$G = \sqrt{ G_{x}^{2} + G_{y}^{2} }$$
%
% Although sometimes the following simpler equation is used:
%
% $$G = |G_{x}| + |G_{y}|$$
%
% Note: When the size of the kernel is |3|, the Sobel kernel shown above may
% produce noticeable inaccuracies (after all, Sobel is only an approximation
% of the derivative). OpenCV addresses this inaccuracy for kernels of size 3
% by using the |cv.Scharr| function. This is as fast but more accurate than
% the standar Sobel function. It implements the following kernels:
%
% $$G_{x} = \left[{\matrix{
%                -3 & 0 &  +3 \cr
%               -10 & 0 & +10 \cr
%                -3 & 0 &  +3
%           }}\right]$$
%
% $$G_{y} = \left[{\matrix{
%               -3 & -10 & -3 \cr
%                0 &   0 &  0 \cr
%               +3 & +10 & +3
%           }}\right]$$
%
% Note: You can check out more information of this function in the OpenCV
% reference (|cv.Scharr|). Also, in the sample code below, you will notice
% that above the code for |cv.Sobel| function there is also code for the
% |cv.Scharr| function commented. Enabling it should give you an idea of how
% this function works.
%

%% Code
%
% The program below applies the _Sobel Operator_ and generates as output an
% image with the detected _edges_ bright on a darker background.
%

%%
% load source image
src = cv.imread(fullfile(mexopencv.root(),'test','lena.jpg'), 'Color',true);

%%
% apply a Gaussian blur to reduce the noise
src = cv.GaussianBlur(src, 'KSize',[3 3]);

%%
% convert filtered image to grayscale
gray = cv.cvtColor(src, 'RGB2GRAY');

%%
% calculate the derivatives in x and y directions
% (input is 8-bit, we set the output image depth to 16-bit to avoid overflow)
if true
    gradx = cv.Sobel(gray, 'XOrder',1, 'YOrder',0, 'DDepth','int16');
    grady = cv.Sobel(gray, 'XOrder',0, 'YOrder',1, 'DDepth','int16');
else
    gradx = cv.Scharr(gray, 'XOrder',1, 'YOrder',0, 'DDepth','int16');
    grady = cv.Scharr(gray, 'XOrder',0, 'YOrder',1, 'DDepth','int16');
end

%%
% take absolute value and convert our partial results back to 8-bit
gradxabs = cv.convertScaleAbs(gradx);
gradyabs = cv.convertScaleAbs(grady);

%%
% approximate the gradient by adding both directional gradients
% (this is not an exact calculation, but it is good for our purposes)
grad = cv.addWeighted(gradxabs,0.5, gradyabs,0.5, 0.0);

%%
% show result
imshow(grad)
title('Sobel Demo - Simple Edge Detector')

##### SOURCE END #####
--></body>
</html>