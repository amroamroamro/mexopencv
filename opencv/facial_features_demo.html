<!DOCTYPE html>
<html>
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   
      <!--This HTML was auto-generated from published MATLAB code.-->
      <title>Facial Features Detection</title>
      <meta name="generator" content="MATLAB 9.2">
      <link rel="schema.DC" href="http://purl.org/dc/elements/1.1/">
      <meta name="DC.date" content="2017-11-27">
      <meta name="DC.source" content="facial_features_demo.m">
      <link rel="stylesheet" type="text/css" href="publish_custom.css">
   </head>
   <body>
      <div class="content">
         <h1 id="1">Facial Features Detection</h1>
         <p>A program to detect facial feature points using Haarcascade classifiers for face, eyes, nose and mouth.</p>
         <p>The sample demonstrates facial feature points detection using Haarcascade classifiers. The program detects a face and eyes,
            nose and mouth inside the face. The code has been tested on the Japanese Female Facial Expression (JAFFE) database and found
            to give reasonably accurate results.
         </p>
         <p>The classifiers for face and eyes can be downloaded from:</p>
         <div>
            <ul>
               <li><a href="https://github.com/opencv/opencv/tree/master/data/haarcascades">https://github.com/opencv/opencv/tree/master/data/haarcascades</a></li>
            </ul>
         </div>
         <p>The classifiers for nose and mouth can be downloaded from:</p>
         <div>
            <ul>
               <li><a href="https://github.com/opencv/opencv_contrib/tree/master/modules/face/data/cascades">https://github.com/opencv/opencv_contrib/tree/master/modules/face/data/cascades</a></li>
            </ul>
         </div>
         <p>Sources:</p>
         <div>
            <ul>
               <li><a href="https://github.com/opencv/opencv/blob/3.2.0/samples/cpp/facial_features.cpp">https://github.com/opencv/opencv/blob/3.2.0/samples/cpp/facial_features.cpp</a></li>
            </ul>
         </div><pre class="codeinput"><span class="keyword">function</span> facial_features_demo(im)
    <span class="comment">% load input image of a face</span>
    <span class="keyword">if</span> nargin &lt; 1
        im = fullfile(tempdir(), <span class="string">'face.jpg'</span>);
        <span class="keyword">if</span> exist(im, <span class="string">'file'</span>) ~= 2
            <span class="keyword">if</span> true
                url = <span class="string">'https://upload.wikimedia.org/wikipedia/commons/c/c9/Julia_Roberts_Cannes_2016_3.jpg'</span>;
            <span class="keyword">elseif</span> true
                url = <span class="string">'https://upload.wikimedia.org/wikipedia/commons/3/33/Nicolas_Cage_2011_CC.jpg'</span>;
            <span class="keyword">else</span>
                url = <span class="string">'https://upload.wikimedia.org/wikipedia/commons/8/8d/George_Clooney_2016.jpg'</span>;
            <span class="keyword">end</span>
            urlwrite(url, im);
        <span class="keyword">end</span>
        img = cv.imread(im, <span class="string">'Color'</span>,true);
    <span class="keyword">elseif</span> ischar(im)
        img = cv.imread(im, <span class="string">'Color'</span>,true);
    <span class="keyword">else</span>
        img = im;
    <span class="keyword">end</span>

    <span class="comment">% haarcascade classifier files for face, eye, nose, and mouth detection</span>
    <span class="comment">% (only the face is required, others are optional)</span>
    xml_face = fullfile(mexopencv.root(),<span class="string">'test'</span>,<span class="string">'haarcascade_frontalface_alt.xml'</span>);
    xml_eye = fullfile(mexopencv.root(),<span class="string">'test'</span>,<span class="string">'haarcascade_eye_tree_eyeglasses.xml'</span>);
    xml_nose = fullfile(mexopencv.root(),<span class="string">'test'</span>,<span class="string">'haarcascade_mcs_nose.xml'</span>);
    xml_mouth = fullfile(mexopencv.root(),<span class="string">'test'</span>,<span class="string">'haarcascade_mcs_mouth.xml'</span>);

    <span class="comment">% Detect faces and facial features</span>
    out = detectFacialFeatures(img, xml_face, xml_eye, xml_nose, xml_mouth);
    imshow(out), title(<span class="string">'Facial Features'</span>)
<span class="keyword">end</span>

<span class="keyword">function</span> out = detectFacialFeatures(img, xml_face, xml_eye, xml_nose, xml_mouth)
    <span class="comment">% input image as grayscale</span>
    out = img;
    <span class="keyword">if</span> size(img,3) == 3
        img = cv.cvtColor(img, <span class="string">'RGB2GRAY'</span>);
    <span class="keyword">end</span>

    <span class="comment">% detect faces</span>
    opts = {<span class="string">'ScaleFactor'</span>,1.15, <span class="string">'MinNeighbors'</span>,3, <span class="keyword">...</span>
        <span class="string">'ScaleImage'</span>,true, <span class="string">'MinSize'</span>,[30 30]};
    faces = cascadeDetect(img, xml_face, opts{:});

    <span class="comment">% for each face, detect facial features</span>
    opts = {<span class="string">'ScaleFactor'</span>,1.20, <span class="string">'MinNeighbors'</span>,5, <span class="keyword">...</span>
        <span class="string">'ScaleImage'</span>,true, <span class="string">'MinSize'</span>,[30 30]};
    <span class="keyword">for</span> i=1:size(faces,1)
        <span class="comment">% draw face</span>
        face = faces(i,:);
        out = cv.rectangle(out, face, <span class="string">'Color'</span>,[0 0 255], <span class="string">'Thickness'</span>,2);

        <span class="comment">% eyes, nose and mouth will be detected inside the face (ROI)</span>
        roi = cv.Rect.crop(img, face);

        <span class="comment">% minimum object center height, used to filter detections</span>
        <span class="comment">% (mouth is expected to lie below nose, which in turn is below eyes)</span>
        ymin = 0;

        <span class="comment">% detect and draw eyes</span>
        <span class="keyword">if</span> ~isempty(xml_eye)
            eyes = cascadeDetect(roi, xml_eye, opts{:});
            [out, ymin] = drawDetections(out, face, eyes, ymin, [0 255 0]);
        <span class="keyword">end</span>

        <span class="comment">% detect and draw nose</span>
        <span class="keyword">if</span> ~isempty(xml_nose)
            nose = cascadeDetect(roi, xml_nose, opts{:});
            [out, ymin] = drawDetections(out, face, nose, ymin, [0 255 255]);
        <span class="keyword">end</span>

        <span class="comment">% detect and draw mouth</span>
        <span class="keyword">if</span> ~isempty(xml_mouth)
            mouth = cascadeDetect(roi, xml_mouth, opts{:});
            [out, ymin] = drawDetections(out, face, mouth, ymin, [255 0 255]);
        <span class="keyword">end</span>
    <span class="keyword">end</span>
<span class="keyword">end</span>

<span class="keyword">function</span> rects = cascadeDetect(img, xml_file, varargin)
    <span class="comment">% if missing, attempt to download XML file from two possible locations</span>
    <span class="keyword">if</span> exist(xml_file, <span class="string">'file'</span>) ~= 2
        [~, f, ext] = fileparts(xml_file);
        url = <span class="string">'https://cdn.rawgit.com/opencv/opencv_contrib/3.2.0/modules/face/data/cascades/'</span>;
        [~,status] = urlwrite([url f ext], xml_file);
        <span class="keyword">if</span> status == 0
            url = <span class="string">'https://cdn.rawgit.com/opencv/opencv/3.2.0/data/haarcascades/'</span>;
            [~,status] = urlwrite([url f ext], xml_file);
        <span class="keyword">end</span>
        assert(status == 1, <span class="string">'Failed to download'</span>);
    <span class="keyword">end</span>

    <span class="comment">% detect and return Nx4 array of rectangles</span>
    cascade = cv.CascadeClassifier(xml_file);
    rects = cascade.detect(img, varargin{:});
    rects = cat(1, rects{:});
<span class="keyword">end</span>

<span class="keyword">function</span> [out, ymin] = drawDetections(out, face, rects, ymin, clr)
    <span class="comment">% filter detections</span>
    ycenter = rects(:,2) + rects(:,4)/2;
    <span class="keyword">if</span> ymin &gt; 0
        idx = ycenter &gt; ymin;
    <span class="keyword">else</span>
        idx = true(size(rects,1),1);
    <span class="keyword">end</span>
    ymin = max(ycenter(idx,:));

    <span class="comment">% draw rectangle enclosing detection</span>
    r = bsxfun(@plus, rects(idx,:), [face(1:2) 0 0]);
    out = cv.rectangle(out, r, <span class="string">'Color'</span>,clr, <span class="string">'Thickness'</span>,2);

    <span class="comment">% draw center of detection</span>
    c = bsxfun(@plus, rects(idx,1:2) + rects(idx,3:4)/2, face(1:2));
    out = cv.circle(out, c, 3, <span class="string">'Color'</span>,clr, <span class="string">'Thickness'</span>,<span class="string">'Filled'</span>);
<span class="keyword">end</span></pre><pre class="codeoutput">Warning: Image is too big to fit on screen; displaying at 67% 
</pre><img src="facial_features_demo_01.png"><div class="footer">
            <p><a href="https://www.mathworks.com/products/matlab.html">Published with MATLAB&reg; R2017a</a></p>
         </div>
      </div>
      <!--
##### SOURCE BEGIN #####
%% Facial Features Detection
%
% A program to detect facial feature points using Haarcascade classifiers for
% face, eyes, nose and mouth.
%
% The sample demonstrates facial feature points detection using Haarcascade
% classifiers. The program detects a face and eyes, nose and mouth inside the
% face. The code has been tested on the Japanese Female Facial Expression
% (JAFFE) database and found to give reasonably accurate results.
%
% The classifiers for face and eyes can be downloaded from:
%
% * <https://github.com/opencv/opencv/tree/master/data/haarcascades>
%
% The classifiers for nose and mouth can be downloaded from:
%
% * <https://github.com/opencv/opencv_contrib/tree/master/modules/face/data/cascades>
%
% Sources:
%
% * <https://github.com/opencv/opencv/blob/3.2.0/samples/cpp/facial_features.cpp>
%

function facial_features_demo(im)
    % load input image of a face
    if nargin < 1
        im = fullfile(tempdir(), 'face.jpg');
        if exist(im, 'file') ~= 2
            if true
                url = 'https://upload.wikimedia.org/wikipedia/commons/c/c9/Julia_Roberts_Cannes_2016_3.jpg';
            elseif true
                url = 'https://upload.wikimedia.org/wikipedia/commons/3/33/Nicolas_Cage_2011_CC.jpg';
            else
                url = 'https://upload.wikimedia.org/wikipedia/commons/8/8d/George_Clooney_2016.jpg';
            end
            urlwrite(url, im);
        end
        img = cv.imread(im, 'Color',true);
    elseif ischar(im)
        img = cv.imread(im, 'Color',true);
    else
        img = im;
    end

    % haarcascade classifier files for face, eye, nose, and mouth detection
    % (only the face is required, others are optional)
    xml_face = fullfile(mexopencv.root(),'test','haarcascade_frontalface_alt.xml');
    xml_eye = fullfile(mexopencv.root(),'test','haarcascade_eye_tree_eyeglasses.xml');
    xml_nose = fullfile(mexopencv.root(),'test','haarcascade_mcs_nose.xml');
    xml_mouth = fullfile(mexopencv.root(),'test','haarcascade_mcs_mouth.xml');

    % Detect faces and facial features
    out = detectFacialFeatures(img, xml_face, xml_eye, xml_nose, xml_mouth);
    imshow(out), title('Facial Features')
end

function out = detectFacialFeatures(img, xml_face, xml_eye, xml_nose, xml_mouth)
    % input image as grayscale
    out = img;
    if size(img,3) == 3
        img = cv.cvtColor(img, 'RGB2GRAY');
    end

    % detect faces
    opts = {'ScaleFactor',1.15, 'MinNeighbors',3, ...
        'ScaleImage',true, 'MinSize',[30 30]};
    faces = cascadeDetect(img, xml_face, opts{:});

    % for each face, detect facial features
    opts = {'ScaleFactor',1.20, 'MinNeighbors',5, ...
        'ScaleImage',true, 'MinSize',[30 30]};
    for i=1:size(faces,1)
        % draw face
        face = faces(i,:);
        out = cv.rectangle(out, face, 'Color',[0 0 255], 'Thickness',2);

        % eyes, nose and mouth will be detected inside the face (ROI)
        roi = cv.Rect.crop(img, face);

        % minimum object center height, used to filter detections
        % (mouth is expected to lie below nose, which in turn is below eyes)
        ymin = 0;

        % detect and draw eyes
        if ~isempty(xml_eye)
            eyes = cascadeDetect(roi, xml_eye, opts{:});
            [out, ymin] = drawDetections(out, face, eyes, ymin, [0 255 0]);
        end

        % detect and draw nose
        if ~isempty(xml_nose)
            nose = cascadeDetect(roi, xml_nose, opts{:});
            [out, ymin] = drawDetections(out, face, nose, ymin, [0 255 255]);
        end

        % detect and draw mouth
        if ~isempty(xml_mouth)
            mouth = cascadeDetect(roi, xml_mouth, opts{:});
            [out, ymin] = drawDetections(out, face, mouth, ymin, [255 0 255]);
        end
    end
end

function rects = cascadeDetect(img, xml_file, varargin)
    % if missing, attempt to download XML file from two possible locations
    if exist(xml_file, 'file') ~= 2
        [~, f, ext] = fileparts(xml_file);
        url = 'https://cdn.rawgit.com/opencv/opencv_contrib/3.2.0/modules/face/data/cascades/';
        [~,status] = urlwrite([url f ext], xml_file);
        if status == 0
            url = 'https://cdn.rawgit.com/opencv/opencv/3.2.0/data/haarcascades/';
            [~,status] = urlwrite([url f ext], xml_file);
        end
        assert(status == 1, 'Failed to download');
    end

    % detect and return Nx4 array of rectangles
    cascade = cv.CascadeClassifier(xml_file);
    rects = cascade.detect(img, varargin{:});
    rects = cat(1, rects{:});
end

function [out, ymin] = drawDetections(out, face, rects, ymin, clr)
    % filter detections
    ycenter = rects(:,2) + rects(:,4)/2;
    if ymin > 0
        idx = ycenter > ymin;
    else
        idx = true(size(rects,1),1);
    end
    ymin = max(ycenter(idx,:));

    % draw rectangle enclosing detection
    r = bsxfun(@plus, rects(idx,:), [face(1:2) 0 0]);
    out = cv.rectangle(out, r, 'Color',clr, 'Thickness',2);

    % draw center of detection
    c = bsxfun(@plus, rects(idx,1:2) + rects(idx,3:4)/2, face(1:2));
    out = cv.circle(out, c, 3, 'Color',clr, 'Thickness','Filled');
end

##### SOURCE END #####
-->
   </body>
</html>