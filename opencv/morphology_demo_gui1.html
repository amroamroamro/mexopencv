<!DOCTYPE html>
<html>
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   
      <!--This HTML was auto-generated from published MATLAB code.-->
      <title>Erosion and Dilation</title>
      <meta name="generator" content="MATLAB 9.2">
      <link rel="schema.DC" href="http://purl.org/dc/elements/1.1/">
      <meta name="DC.date" content="2017-11-27">
      <meta name="DC.source" content="morphology_demo_gui1.m">
      <link rel="stylesheet" type="text/css" href="publish_custom.css">
   </head>
   <body>
      <div class="content">
         <h1 id="1">Erosion and Dilation</h1>
         <!--introduction-->
         <p>In this sample, you will learn how to apply two very common morphological operators: Erosion and Dilation. For this purpose,
            you will use the following OpenCV functions:
         </p>
         <div>
            <ul>
               <li><a href="matlab:doc('cv.erode')">cv.erode</a></li>
               <li><a href="matlab:doc('cv.dilate')">cv.dilate</a></li>
            </ul>
         </div>
         <p>Sources:</p>
         <div>
            <ul>
               <li><a href="https://docs.opencv.org/3.2.0/db/df6/tutorial_erosion_dilatation.html">https://docs.opencv.org/3.2.0/db/df6/tutorial_erosion_dilatation.html</a></li>
               <li><a href="https://github.com/opencv/opencv/blob/3.2.0/samples/cpp/tutorial_code/ImgProc/Morphology_1.cpp">https://github.com/opencv/opencv/blob/3.2.0/samples/cpp/tutorial_code/ImgProc/Morphology_1.cpp</a></li>
               <li><a href="https://github.com/opencv/opencv/blob/3.2.0/samples/cpp/morphology2.cpp">https://github.com/opencv/opencv/blob/3.2.0/samples/cpp/morphology2.cpp</a></li>
               <li><a href="https://github.com/opencv/opencv/blob/3.2.0/samples/python/morphology.py">https://github.com/opencv/opencv/blob/3.2.0/samples/python/morphology.py</a></li>
            </ul>
         </div>
         <!--/introduction-->
         <h2 id="toc">Contents</h2>
         <div>
            <ul>
               <li><a href="#2">Morphological Operations</a></li>
               <li><a href="#3">1) Dilation</a></li>
               <li><a href="#4">2) Erosion</a></li>
               <li><a href="#5">References</a></li>
               <li><a href="#6">Code</a></li>
            </ul>
         </div>
         <h2 id="2">Morphological Operations</h2>
         <p>In short: A set of operations that process images based on shapes. Morphological operations apply a <i>structuring element</i> to an input image and generate an output image. The most basic morphological operations are: Erosion and Dilation. They have
            a wide array of uses, i.e.:
         </p>
         <div>
            <ul>
               <li>Removing noise</li>
               <li>Isolation of individual elements and joining disparate elements in an   image.</li>
               <li>Finding of intensity bumps or holes in an image</li>
            </ul>
         </div>
         <p>We will explain dilation and erosion briefly, using the following image as an example:</p>
         <p><img src="https://docs.opencv.org/3.2.0/Morphology_1_Tutorial_Theory_Original_Image.png"></p>
         <h2 id="3">1) Dilation</h2>
         <p>This operations consists of convolving an image <img src="morphology_demo_gui1_eq05147331747641807187.png" alt="$A$" class="equation" width="10" height="11"> with some kernel (<img src="morphology_demo_gui1_eq10170753361147586657.png" alt="$B$" class="equation" width="11" height="10">), which can have any shape or size, usually a square or circle. The kernel <img src="morphology_demo_gui1_eq10170753361147586657.png" alt="$B$" class="equation" width="11" height="10"> has a defined <i>anchor point</i>, usually being the center of the kernel. As the kernel <img src="morphology_demo_gui1_eq10170753361147586657.png" alt="$B$" class="equation" width="11" height="10"> is scanned over the image, we compute the maximal pixel value overlapped by <img src="morphology_demo_gui1_eq10170753361147586657.png" alt="$B$" class="equation" width="11" height="10"> and replace the image pixel in the anchor point position with that maximal value. As you can deduce, this maximizing operation
            causes bright regions within an image to "grow" (therefore the name <i>dilation</i>).
         </p>
         <p>Take the above image as an example. Applying dilation we can get:</p>
         <p><img src="https://docs.opencv.org/3.2.0/Morphology_1_Tutorial_Theory_Dilation.png"></p>
         <p>The background (bright) dilates around the black regions of the letter.</p>
         <p>To better grasp the idea and avoid possible confusion, in this other example we have inverted the original image such as the
            object in white is now the letter. We have performed two dilatations with a rectangular structuring element of size <tt>3x3</tt>.
         </p>
         <p><img src="https://docs.opencv.org/3.2.0/Morphology_1_Tutorial_Theory_Dilatation_2.png"></p>
         <p>(Left image: original image inverted, right image: resulting dilatation).</p>
         <p>The dilatation makes the object in white bigger.</p>
         <h2 id="4">2) Erosion</h2>
         <p>This operation is the sister of dilation. It computes a local minimum over the area of given kernel. As the kernel <img src="morphology_demo_gui1_eq10170753361147586657.png" alt="$B$" class="equation" width="11" height="10"> is scanned over the image, we compute the minimal pixel value overlapped by <img src="morphology_demo_gui1_eq10170753361147586657.png" alt="$B$" class="equation" width="11" height="10"> and replace the image pixel under the anchor point with that minimal value.
         </p>
         <p>Analagously to the example for dilation, we can apply the erosion operator to the original image (shown above). You can see
            in the result below that the bright areas of the image (the background, apparently), get thinner, whereas the dark zones (the
            "writing") gets bigger.
         </p>
         <p><img src="https://docs.opencv.org/3.2.0/Morphology_1_Tutorial_Theory_Erosion.png"></p>
         <p>In similar manner, the corresponding image results by applying erosion operation on the inverted original image (two erosions
            with a rectangular structuring element of size <tt>3x3</tt>):
         </p>
         <p><img src="https://docs.opencv.org/3.2.0/Morphology_1_Tutorial_Theory_Erosion_2.png"></p>
         <p>(Left image: original image inverted, right image: resulting erosion).</p>
         <p>The erosion makes the object in white smaller.</p>
         <h2 id="5">References</h2>
         <div>
            <ul>
               <li>"Learning OpenCV" by Bradski and Kaehler.</li>
            </ul>
         </div>
         <h2 id="6">Code</h2><pre class="codeinput"><span class="keyword">function</span> varargout = morphology_demo_gui1(im)
    <span class="comment">% load source image</span>
    <span class="keyword">if</span> nargin &lt; 1
        src = imread(fullfile(mexopencv.root(),<span class="string">'test'</span>,<span class="string">'cat.jpg'</span>));
    <span class="keyword">elseif</span> ischar(im)
        src = imread(im);
    <span class="keyword">else</span>
        src = im;
    <span class="keyword">end</span>

    <span class="comment">% create the UI</span>
    h = buildGUI(src);
    <span class="keyword">if</span> nargout &gt; 0, varargout{1} = h; <span class="keyword">end</span>
<span class="keyword">end</span>

<span class="keyword">function</span> onChange(~,~,h)
    <span class="comment">%ONCHANGE  Event handler for UI controls</span>

    <span class="comment">% retrieve current values from UI controls</span>
    ksize = round(get(h.slid, <span class="string">'Value'</span>));
    funcIdx = get(h.pop(1), <span class="string">'Value'</span>);
    shapeIdx = get(h.pop(2), <span class="string">'Value'</span>);
    set(h.txt, <span class="string">'String'</span>,sprintf(<span class="string">'%2d'</span>,ksize));

    <span class="comment">% options (structuring element shape and morphological operation)</span>
    shapes = {<span class="string">'Rect'</span>, <span class="string">'Cross'</span>, <span class="string">'Ellipse'</span>};
    <span class="keyword">if</span> ~mexopencv.isOctave()
        fhandles = {@cv.erode, @cv.dilate, @(I,varargin)I};
    <span class="keyword">else</span>
        <span class="comment">%HACK: Octave doesnt support function handles to package methods</span>
        fhandles = { <span class="keyword">...</span>
            @(varargin) cv.erode(varargin{:}), <span class="keyword">...</span>
            @(varargin) cv.dilate(varargin{:}), <span class="keyword">...</span>
            @(I,varargin) I
        };
    <span class="keyword">end</span>

    <span class="comment">% apply the specified morphological operation</span>
    elem = cv.getStructuringElement(<span class="string">'Shape'</span>,shapes{shapeIdx}, <span class="keyword">...</span>
        <span class="string">'KSize'</span>,[ksize ksize]*2+1, <span class="string">'Anchor'</span>,[ksize ksize]);
    dst = feval(fhandles{funcIdx}, h.src, <span class="string">'Element'</span>,elem);

    <span class="comment">% show result</span>
    set(h.img, <span class="string">'CData'</span>,dst);
    drawnow;
<span class="keyword">end</span>

<span class="keyword">function</span> h = buildGUI(img)
    <span class="comment">%BUILDGUI  Creates the UI</span>

    <span class="comment">% parameters</span>
    ksize = 3;
    max_ksize = 21;
    sz = size(img);
    sz(2) = max(sz(2), 250);  <span class="comment">% minimum figure width</span>

    <span class="comment">% build the user interface (no resizing to keep it simple)</span>
    h = struct();
    h.src = img;
    h.fig = figure(<span class="string">'Name'</span>,<span class="string">'Dilation/Erosion Demo'</span>, <span class="keyword">...</span>
        <span class="string">'NumberTitle'</span>,<span class="string">'off'</span>, <span class="string">'Menubar'</span>,<span class="string">'none'</span>, <span class="string">'Resize'</span>,<span class="string">'off'</span>, <span class="keyword">...</span>
        <span class="string">'Position'</span>,[200 200 sz(2) sz(1)+29]);
    <span class="keyword">if</span> ~mexopencv.isOctave()
        <span class="comment">%HACK: not implemented in Octave</span>
        movegui(h.fig, <span class="string">'center'</span>);
    <span class="keyword">end</span>
    h.ax = axes(<span class="string">'Parent'</span>,h.fig, <span class="string">'Units'</span>,<span class="string">'pixels'</span>, <span class="string">'Position'</span>,[1 30 sz(2) sz(1)]);
    <span class="keyword">if</span> ~mexopencv.isOctave()
        h.img = imshow(img, <span class="string">'Parent'</span>,h.ax);
    <span class="keyword">else</span>
        <span class="comment">%HACK: https://savannah.gnu.org/bugs/index.php?45473</span>
        axes(h.ax);
        h.img = imshow(img);
    <span class="keyword">end</span>
    h.pop(1) = uicontrol(<span class="string">'Parent'</span>,h.fig, <span class="string">'Style'</span>,<span class="string">'popupmenu'</span>, <span class="keyword">...</span>
       <span class="string">'Position'</span>,[5 5 70 20], <span class="string">'String'</span>, {<span class="string">'Erosion'</span>,<span class="string">'Dilation'</span>,<span class="string">'-None-'</span>});
    h.pop(2) = uicontrol(<span class="string">'Parent'</span>,h.fig, <span class="string">'Style'</span>,<span class="string">'popupmenu'</span>, <span class="keyword">...</span>
       <span class="string">'Position'</span>,[75 5 70 20], <span class="string">'String'</span>,{<span class="string">'Rect'</span>,<span class="string">'Cross'</span>,<span class="string">'Ellipse'</span>});
    h.slid = uicontrol(<span class="string">'Parent'</span>,h.fig, <span class="string">'Style'</span>,<span class="string">'slider'</span>, <span class="string">'Value'</span>,ksize, <span class="keyword">...</span>
        <span class="string">'Min'</span>,1, <span class="string">'Max'</span>,max_ksize, <span class="string">'SliderStep'</span>,[1 5]./(max_ksize-1), <span class="keyword">...</span>
        <span class="string">'Position'</span>,[150 5 sz(2)-150-20-5 20]);
    h.txt = uicontrol(<span class="string">'Parent'</span>,h.fig, <span class="string">'Style'</span>,<span class="string">'text'</span>, <span class="string">'FontSize'</span>,11, <span class="keyword">...</span>
        <span class="string">'Position'</span>,[sz(2)-20-5 5 20 20], <span class="string">'String'</span>,num2str(ksize));

    <span class="comment">% hook event handlers, and trigger default start</span>
    set([h.slid, h.pop], <span class="string">'Callback'</span>,{@onChange,h}, <span class="keyword">...</span>
        <span class="string">'Interruptible'</span>,<span class="string">'off'</span>, <span class="string">'BusyAction'</span>,<span class="string">'cancel'</span>);
    onChange([],[],h);
<span class="keyword">end</span></pre><img src="morphology_demo_gui1_01.png"><div class="footer">
            <p><a href="https://www.mathworks.com/products/matlab.html">Published with MATLAB&reg; R2017a</a></p>
         </div>
      </div><script type="text/x-mathjax-config">
  // https://stackoverflow.com/a/14631703/97160
  MathJax.Extension.myImg2jax = {
    version: "1.0",
    PreProcess: function (element) {
      var images = element.getElementsByTagName("img");
      for (var i = images.length - 1; i >= 0; i--) {
        var img = images[i];
        if (img.className === "equation") {
          var match = img.alt.match(/^(\$\$?)([\s\S]*)\1$/m);
          if (!match) continue;
          var script = document.createElement("script");
          script.type = "math/tex";
          if (match[1] === "$$") {script.type += ";mode=display"}
          MathJax.HTML.setScript(script, match[2]);
          img.parentNode.replaceChild(script, img);
        }
      }
    }
  };
  MathJax.Hub.Register.PreProcessor(["PreProcess", MathJax.Extension.myImg2jax]);
  </script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-AMS_CHTML"></script>
      <!--
##### SOURCE BEGIN #####
%% Erosion and Dilation
%
% In this sample, you will learn how to apply two very common morphological
% operators: Erosion and Dilation. For this purpose, you will use the
% following OpenCV functions:
%
% * <matlab:doc('cv.erode') cv.erode>
% * <matlab:doc('cv.dilate') cv.dilate>
%
% Sources:
%
% * <https://docs.opencv.org/3.2.0/db/df6/tutorial_erosion_dilatation.html>
% * <https://github.com/opencv/opencv/blob/3.2.0/samples/cpp/tutorial_code/ImgProc/Morphology_1.cpp>
% * <https://github.com/opencv/opencv/blob/3.2.0/samples/cpp/morphology2.cpp>
% * <https://github.com/opencv/opencv/blob/3.2.0/samples/python/morphology.py>
%

%% Morphological Operations
%
% In short: A set of operations that process images based on shapes.
% Morphological operations apply a _structuring element_ to an input image and
% generate an output image. The most basic morphological operations are:
% Erosion and Dilation. They have a wide array of uses, i.e.:
%
% * Removing noise
% * Isolation of individual elements and joining disparate elements in an
%   image.
% * Finding of intensity bumps or holes in an image
%
% We will explain dilation and erosion briefly, using the following image as
% an example:
%
% <<https://docs.opencv.org/3.2.0/Morphology_1_Tutorial_Theory_Original_Image.png>>
%
%% 1) Dilation
%
% This operations consists of convolving an image $A$ with some kernel ($B$),
% which can have any shape or size, usually a square or circle. The kernel $B$
% has a defined _anchor point_, usually being the center of the kernel. As the
% kernel $B$ is scanned over the image, we compute the maximal pixel value
% overlapped by $B$ and replace the image pixel in the anchor point position
% with that maximal value. As you can deduce, this maximizing operation causes
% bright regions within an image to "grow" (therefore the name _dilation_).
%
% Take the above image as an example. Applying dilation we can get:
%
% <<https://docs.opencv.org/3.2.0/Morphology_1_Tutorial_Theory_Dilation.png>>
%
% The background (bright) dilates around the black regions of the letter.
%
% To better grasp the idea and avoid possible confusion, in this other example
% we have inverted the original image such as the object in white is now the
% letter. We have performed two dilatations with a rectangular structuring
% element of size |3x3|.
%
% <<https://docs.opencv.org/3.2.0/Morphology_1_Tutorial_Theory_Dilatation_2.png>>
%
% (Left image: original image inverted, right image: resulting dilatation).
%
% The dilatation makes the object in white bigger.
%
%% 2) Erosion
%
% This operation is the sister of dilation. It computes a local minimum over
% the area of given kernel. As the kernel $B$ is scanned over the image, we
% compute the minimal pixel value overlapped by $B$ and replace the image
% pixel under the anchor point with that minimal value.
%
% Analagously to the example for dilation, we can apply the erosion operator
% to the original image (shown above). You can see in the result below that
% the bright areas of the image (the background, apparently), get thinner,
% whereas the dark zones (the "writing") gets bigger.
%
% <<https://docs.opencv.org/3.2.0/Morphology_1_Tutorial_Theory_Erosion.png>>
%
% In similar manner, the corresponding image results by applying erosion
% operation on the inverted original image (two erosions with a rectangular
% structuring element of size |3x3|):
%
% <<https://docs.opencv.org/3.2.0/Morphology_1_Tutorial_Theory_Erosion_2.png>>
%
% (Left image: original image inverted, right image: resulting erosion).
%
% The erosion makes the object in white smaller.
%
%% References
%
% * "Learning OpenCV" by Bradski and Kaehler.
%

%% Code

function varargout = morphology_demo_gui1(im)
    % load source image
    if nargin < 1
        src = imread(fullfile(mexopencv.root(),'test','cat.jpg'));
    elseif ischar(im)
        src = imread(im);
    else
        src = im;
    end

    % create the UI
    h = buildGUI(src);
    if nargout > 0, varargout{1} = h; end
end

function onChange(~,~,h)
    %ONCHANGE  Event handler for UI controls

    % retrieve current values from UI controls
    ksize = round(get(h.slid, 'Value'));
    funcIdx = get(h.pop(1), 'Value');
    shapeIdx = get(h.pop(2), 'Value');
    set(h.txt, 'String',sprintf('%2d',ksize));

    % options (structuring element shape and morphological operation)
    shapes = {'Rect', 'Cross', 'Ellipse'};
    if ~mexopencv.isOctave()
        fhandles = {@cv.erode, @cv.dilate, @(I,varargin)I};
    else
        %HACK: Octave doesnt support function handles to package methods
        fhandles = { ...
            @(varargin) cv.erode(varargin{:}), ...
            @(varargin) cv.dilate(varargin{:}), ...
            @(I,varargin) I
        };
    end

    % apply the specified morphological operation
    elem = cv.getStructuringElement('Shape',shapes{shapeIdx}, ...
        'KSize',[ksize ksize]*2+1, 'Anchor',[ksize ksize]);
    dst = feval(fhandles{funcIdx}, h.src, 'Element',elem);

    % show result
    set(h.img, 'CData',dst);
    drawnow;
end

function h = buildGUI(img)
    %BUILDGUI  Creates the UI

    % parameters
    ksize = 3;
    max_ksize = 21;
    sz = size(img);
    sz(2) = max(sz(2), 250);  % minimum figure width

    % build the user interface (no resizing to keep it simple)
    h = struct();
    h.src = img;
    h.fig = figure('Name','Dilation/Erosion Demo', ...
        'NumberTitle','off', 'Menubar','none', 'Resize','off', ...
        'Position',[200 200 sz(2) sz(1)+29]);
    if ~mexopencv.isOctave()
        %HACK: not implemented in Octave
        movegui(h.fig, 'center');
    end
    h.ax = axes('Parent',h.fig, 'Units','pixels', 'Position',[1 30 sz(2) sz(1)]);
    if ~mexopencv.isOctave()
        h.img = imshow(img, 'Parent',h.ax);
    else
        %HACK: https://savannah.gnu.org/bugs/index.php?45473
        axes(h.ax);
        h.img = imshow(img);
    end
    h.pop(1) = uicontrol('Parent',h.fig, 'Style','popupmenu', ...
       'Position',[5 5 70 20], 'String', {'Erosion','Dilation','-None-'});
    h.pop(2) = uicontrol('Parent',h.fig, 'Style','popupmenu', ...
       'Position',[75 5 70 20], 'String',{'Rect','Cross','Ellipse'});
    h.slid = uicontrol('Parent',h.fig, 'Style','slider', 'Value',ksize, ...
        'Min',1, 'Max',max_ksize, 'SliderStep',[1 5]./(max_ksize-1), ...
        'Position',[150 5 sz(2)-150-20-5 20]);
    h.txt = uicontrol('Parent',h.fig, 'Style','text', 'FontSize',11, ...
        'Position',[sz(2)-20-5 5 20 20], 'String',num2str(ksize));

    % hook event handlers, and trigger default start
    set([h.slid, h.pop], 'Callback',{@onChange,h}, ...
        'Interruptible','off', 'BusyAction','cancel');
    onChange([],[],h);
end

##### SOURCE END #####
--></body>
</html>