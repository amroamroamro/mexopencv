<!DOCTYPE html>
<html>
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   
      <!--This HTML was auto-generated from published MATLAB code.-->
      <title>Back Projection</title>
      <meta name="generator" content="MATLAB 9.2">
      <link rel="schema.DC" href="http://purl.org/dc/elements/1.1/">
      <meta name="DC.date" content="2017-11-27">
      <meta name="DC.source" content="backproject_demo_gui.m">
      <link rel="stylesheet" type="text/css" href="publish_custom.css">
   </head>
   <body>
      <div class="content">
         <h1 id="1">Back Projection</h1>
         <!--introduction-->
         <p>In this demo, we will learn:</p>
         <div>
            <ul>
               <li>What is Back Projection and why it is useful</li>
               <li>How to use the OpenCV function <tt>cv.calcBackProject</tt> to calculate Back   Projection
               </li>
            </ul>
         </div>
         <p>Sources:</p>
         <div>
            <ul>
               <li><a href="https://docs.opencv.org/3.2.0/da/d7f/tutorial_back_projection.html">https://docs.opencv.org/3.2.0/da/d7f/tutorial_back_projection.html</a></li>
               <li><a href="https://docs.opencv.org/3.2.0/dc/df6/tutorial_py_histogram_backprojection.html">https://docs.opencv.org/3.2.0/dc/df6/tutorial_py_histogram_backprojection.html</a></li>
               <li><a href="https://github.com/opencv/opencv/blob/3.2.0/samples/cpp/tutorial_code/Histograms_Matching/calcBackProject_Demo1.cpp">https://github.com/opencv/opencv/blob/3.2.0/samples/cpp/tutorial_code/Histograms_Matching/calcBackProject_Demo1.cpp</a></li>
               <li><a href="https://github.com/opencv/opencv/blob/3.2.0/samples/cpp/tutorial_code/Histograms_Matching/calcBackProject_Demo2.cpp">https://github.com/opencv/opencv/blob/3.2.0/samples/cpp/tutorial_code/Histograms_Matching/calcBackProject_Demo2.cpp</a></li>
            </ul>
         </div>
         <!--/introduction-->
         <h2 id="toc">Contents</h2>
         <div>
            <ul>
               <li><a href="#2">Theory</a></li>
               <li><a href="#3">Code</a></li>
               <li><a href="#4">Helper functions</a></li>
               <li><a href="#5">UI and callbacks</a></li>
            </ul>
         </div>
         <h2 id="2">Theory</h2>
         <p>Back Projection is a way of recording how well the pixels of a given image fit the distribution of pixels in a histogram model.
            To make it simpler, for Back Projection, you calculate the histogram model of a feature and then use it to find this feature
            in an image. Application example: If you have a histogram of flesh color (say, a Hue-Saturation histogram), then you can use
            it to find flesh color areas in an image.
         </p>
         <p>We explain how it works by using the skin example. Let's say you have gotten a skin histogram (Hue-Saturation) based on the
            image below. The histogram besides is going to be our <i>model histogram</i> (which we know represents a sample of skin tonality). You applied some mask to capture only the histogram of the skin area:
         </p>
         <p><img src="https://docs.opencv.org/3.2.0/Back_Projection_Theory0.jpg"></p>
         <p><img src="https://docs.opencv.org/3.2.0/Back_Projection_Theory1.jpg"></p>
         <p>Now, let's imagine that you get another hand image (test Image) like the one below, with its respective histogram:</p>
         <p><img src="https://docs.opencv.org/3.2.0/Back_Projection_Theory2.jpg"></p>
         <p><img src="https://docs.opencv.org/3.2.0/Back_Projection_Theory3.jpg"></p>
         <p>What we want to do is to use our <i>model histogram</i> (that we know represents a skin tonality) to detect skin areas in our test image. Here are the steps
         </p>
         <div>
            <ul>
               <li>In each pixel of our test image (i.e. <img src="backproject_demo_gui_eq14827595236947239807.png" alt="$p(i,j)$" class="equation" width="37" height="15"> ), collect the data and   find the correspondent bin location for that pixel (i.e.   <img src="backproject_demo_gui_eq13097309030649836463.png" alt="$( h_{i,j}, s_{i,j} )$" class="equation" width="55" height="16"> ).
               </li>
               <li>Lookup the <i>model histogram</i> in the correspondent bin,   <img src="backproject_demo_gui_eq13097309030649836463.png" alt="$( h_{i,j}, s_{i,j} )$" class="equation" width="55" height="16">, and read the bin value.
               </li>
               <li>Store this bin value in a new image (<i>BackProjection</i>). Also, you may   consider to normalize the <i>model histogram</i> first, so the output for the   test image can be visible for you.
               </li>
               <li>Applying the steps above, we get the following BackProjection image for   our test image:</li>
            </ul>
         </div>
         <p><img src="https://docs.opencv.org/3.2.0/Back_Projection_Theory4.jpg"></p>
         <div>
            <ul>
               <li>In terms of statistics, the values stored in <i>BackProjection</i> represent   the <i>probability</i> that a pixel in <i>test image</i> belongs to a skin area,   based on the <i>model histogram</i> that we use. For instance in our test   image, the brighter areas are more probable to be skin area (as they   actually are),
                  whereas the darker areas have less probability (notice that   these "dark" areas belong to surfaces that have some shadow
                  on it, which   in turns affects the detection).
               </li>
            </ul>
         </div>
         <h2 id="3">Code</h2>
         <p>The steps:</p>
         <div>
            <ul>
               <li>Load an image</li>
               <li>Convert the original to HSV format and separate only <i>Hue</i> channel to be   used for the Histogram
               </li>
               <li>Let the user to enter the number of bins to be used in the calculation of   the histogram.</li>
               <li>Calculate the histogram (and update it if the bins change) and the   backprojection of the same image.</li>
               <li>Display the backprojection and the histogram in windows.</li>
            </ul>
         </div>
         <p>The code in this sample doesn't implement the basic version explained above. In fact it improves the process by building a
            2D H-S histograms and using <tt>cv.floodFill</tt> to define a mask for the skin area. For more, you can also checkout the classical camshift sample in <tt>camshift_demo_gui.m</tt>.
         </p><pre class="codeinput"><span class="keyword">function</span> varargout = backproject_demo_gui()
    <span class="comment">% load images (base image and test image)</span>
    imgs = loadImages();

    <span class="comment">% create the UI</span>
    h = buildGUI(imgs);
    <span class="keyword">if</span> nargout &gt; 0, varargout{1} = h; <span class="keyword">end</span>
<span class="keyword">end</span></pre><h2 id="4">Helper functions</h2><pre class="codeinput"><span class="keyword">function</span> imgs = loadImages()
    <span class="comment">%LOADIMAGES  Load source and target images</span>

    <span class="comment">% source and target images</span>
    im = {
        <span class="string">'https://docs.opencv.org/3.2.0/Histogram_Comparison_Source_0.jpg'</span>
        <span class="string">'https://docs.opencv.org/3.2.0/Histogram_Comparison_Source_1.jpg'</span>
    };
    imgs = cell(size(im));
    <span class="keyword">for</span> i=1:numel(im)
        <span class="comment">% download if necessary</span>
        [~,name,ext] = fileparts(im{i});
        fname = fullfile(mexopencv.root(), <span class="string">'test'</span>, [name ext]);
        <span class="keyword">if</span> exist(fname, <span class="string">'file'</span>) ~= 2
            disp(<span class="string">'Downloading image...'</span>)
            urlwrite(im{i}, fname);
        <span class="keyword">end</span>
        <span class="comment">% load image</span>
        imgs{i} = cv.imread(fname, <span class="string">'Color'</span>,true);
        <span class="comment">% upsample, images are a bit small</span>
        s = 1.5;
        imgs{i} = cv.resize(imgs{i}, s, s);
    <span class="keyword">end</span>
<span class="keyword">end</span>

<span class="keyword">function</span> pt = getSeedPoint(img)
    <span class="comment">%GETSEEDPOINT  Prompt user for flood-fill seed point</span>
    <span class="comment">%</span>
    <span class="comment">% See also: ginput, getpts, impixel, waitforbuttonpress, CurrentPoint</span>
    <span class="comment">%</span>

    sz = [size(img,2) size(img,1)];
    pt0 = round(sz/2);
    valid = @(p) ~isempty(p) &amp;&amp; all((p(:) &gt; 0) &amp; (p(:) &lt;= sz(:)));

    <span class="keyword">if</span> ~mexopencv.isOctave()
        <span class="comment">% display image, and prompt user for seed point</span>
        fig = figure(<span class="string">'Menubar'</span>,<span class="string">'none'</span>, <span class="string">'WindowStyle'</span>,<span class="string">'Modal'</span>);
        imshow(img), axis <span class="string">on</span>
        title(<span class="string">'Select seed point'</span>), xlabel(<span class="string">'X'</span>), ylabel(<span class="string">'Y'</span>)
        <span class="keyword">try</span>
            <span class="keyword">while</span> true
                [x,y] = ginput(1);
                pt = round([x y]);
                <span class="keyword">if</span> valid(pt), <span class="keyword">break</span>; <span class="keyword">end</span>
            <span class="keyword">end</span>
        <span class="keyword">catch</span>
            pt = pt0;
        <span class="keyword">end</span>
        <span class="keyword">if</span> ishghandle(fig), close(fig); <span class="keyword">end</span>
    <span class="keyword">elseif</span> true
        <span class="comment">%HACK: for some reason, Octave never returns from GINPUT in code above</span>
        <span class="comment">% fallback to using an input dialog to prompt for seed point</span>
        <span class="keyword">while</span> true
            str = arrayfun(@num2str, pt0, <span class="string">'UniformOutput'</span>,false);
            str = inputdlg({<span class="string">'seed.x'</span>,<span class="string">'seed.y'</span>}, <span class="string">'Seed Point'</span>, 1, str);
            pt = str2double(str);
            <span class="keyword">if</span> valid(pt), <span class="keyword">break</span>; <span class="keyword">end</span>
        <span class="keyword">end</span>
    <span class="keyword">else</span>
        <span class="comment">%pt = pt0;</span>
        pt = [120 100];
    <span class="keyword">end</span>
<span class="keyword">end</span>

<span class="keyword">function</span> mask = floodFillMask(img, seed, lo, up)
    <span class="comment">%FLOODFILLMASK  Flood-fill source image to create mask over object</span>

    <span class="comment">% create mask image (padded by 1 pixel in both directions)</span>
    sz = size(img);
    mask = zeros(sz(1:2) + 2, <span class="string">'uint8'</span>);

    <span class="comment">% flood-fill the mask image starting at the seed</span>
    [~,~,~,mask] = cv.floodFill(img, seed, [120 120 120], <span class="keyword">...</span>
        <span class="string">'Mask'</span>,mask, <span class="string">'MaskOnly'</span>,true, <span class="string">'MaskFillValue'</span>,255, <span class="keyword">...</span>
        <span class="string">'LoDiff'</span>,[lo lo lo], <span class="string">'UpDiff'</span>,[up up up], <span class="keyword">...</span>
        <span class="string">'FixedRange'</span>,true, <span class="string">'Connectivity'</span>,8);
    mask = mask(2:end-1,2:end-1);

    <span class="keyword">if</span> true
        <span class="comment">% process the mask (morphological closing)</span>
        el = cv.getStructuringElement(<span class="string">'Shape'</span>,<span class="string">'Ellipse'</span>, <span class="string">'KSize'</span>,[5 5]);
        mask = cv.morphologyEx(mask, <span class="string">'Close'</span>, <span class="string">'Element'</span>,el);
    <span class="keyword">end</span>
<span class="keyword">end</span>

<span class="keyword">function</span> [histo, hue] = computeHistogram(img, mask, nbins)
    <span class="comment">%COMPUTEHISTOGRAM  Compute hue/saturation histogram</span>

    <span class="keyword">if</span> nargin &lt; 2, mask = []; <span class="keyword">end</span>
    <span class="keyword">if</span> nargin &lt; 3, nbins = [30 32]; <span class="keyword">end</span>

    <span class="comment">% convert source image to HSV colorspace</span>
    imgHSV = cv.cvtColor(img, <span class="string">'RGB2HSV'</span>);
    <span class="keyword">if</span> nargout &gt; 1
        hue = imgHSV(:,:,1);
    <span class="keyword">end</span>

    <span class="comment">% compute H-S histogram of source image, with mask indicating object</span>
    ranges = {[0 180], [0 256]};
    histo = cv.calcHist(imgHSV, ranges, <span class="string">'HistSize'</span>,nbins, <span class="string">'Uniform'</span>,true, <span class="keyword">...</span><span class="comment">.</span>
        <span class="string">'Channels'</span>,[0 1], <span class="string">'Mask'</span>,mask);

    <span class="comment">% normalize it to [0,255] range</span>
    histo = cv.normalize(histo, <span class="string">'NormType'</span>,<span class="string">'MinMax'</span>, <span class="string">'Alpha'</span>,0, <span class="string">'Beta'</span>,255);
<span class="keyword">end</span>

<span class="keyword">function</span> [prob,mask] = computeBackprojection(img, histo)
    <span class="comment">%COMPUTEBACKPROJECTION  Target image backproject</span>

    <span class="comment">% convert target image to HSV colorspace</span>
    imgHSV = cv.cvtColor(img, <span class="string">'RGB2HSV'</span>);

    <span class="comment">% backproject the target image using source histogram</span>
    ranges = {[0 180], [0 256]};
    prob = cv.calcBackProject(imgHSV, histo, ranges, <span class="string">'Uniform'</span>,true, <span class="keyword">...</span>
        <span class="string">'Channels'</span>,[0 1]);

    <span class="keyword">if</span> nargout &gt; 1
        <span class="comment">% process backprojection to extract object in target image</span>
        el = cv.getStructuringElement(<span class="string">'Shape'</span>,<span class="string">'Ellipse'</span>, <span class="string">'KSize'</span>,[7 7]);
        mask = cv.filter2D(prob, el);
        mask = cv.morphologyEx(mask, <span class="string">'Close'</span>, <span class="string">'Element'</span>,el, <span class="string">'Iterations'</span>,3);
        mask = cv.threshold(mask, <span class="string">'Otsu'</span>);
    <span class="keyword">end</span>
<span class="keyword">end</span>

<span class="keyword">function</span> out = createOutputImage(img, mask)
    <span class="comment">%CREATEOUTPUTIMAGE  Combine image and mask for output</span>

    maskRGB = cv.cvtColor(mask, <span class="string">'GRAY2RGB'</span>);
    <span class="keyword">if</span> true
        <span class="comment">% overlay mask with transparency</span>
        <span class="keyword">if</span> true
            maskRGB(:,:,3) = 0;
            overlay = cv.bitwise_or(img, maskRGB);
        <span class="keyword">elseif</span> true
            maskRGB(:,:,3) = 0;
            overlay = cv.copyTo(maskRGB, <span class="string">'Dest'</span>,img, <span class="string">'Mask'</span>,mask);
        <span class="keyword">else</span>
            mask = logical(mask);
            R = img(:,:,1); R(mask) = 255;
            G = img(:,:,2); G(mask) = 255;
            B = img(:,:,2); B(mask) = 0;
            overlay = cat(3, R, G, B);
        <span class="keyword">end</span>
        a = 0.4;
        out = cv.addWeighted(overlay,a, img,1-a, 0.0);
    <span class="keyword">elseif</span> true
        <span class="comment">% cut-out mask region</span>
        out = cv.bitwise_and(img, maskRGB);
    <span class="keyword">else</span>
        <span class="comment">% binary mask</span>
        out = maskRGB;
    <span class="keyword">end</span>
<span class="keyword">end</span>

<span class="keyword">function</span> showHistogram(histo)
    <span class="comment">%SHOWHISTOGRAM  Display 2D histogram</span>

    ranges = {[0 180], [0 256]};
    figure, imagesc(histo, <span class="string">'YData'</span>,ranges{1}, <span class="string">'XData'</span>,ranges{2})
    ylabel(<span class="string">'Hue'</span>), xlabel(<span class="string">'Saturation'</span>), title(<span class="string">'H-S histogram'</span>)
    colormap <span class="string">gray</span>
<span class="keyword">end</span>

<span class="keyword">function</span> img = drawTitle(img, str)
    <span class="comment">%DRAWTITLE  Draw title on output image</span>

    img = cv.putText(img, str, [10 20], <span class="keyword">...</span>
        <span class="string">'FontScale'</span>,0.5, <span class="string">'Color'</span>,[255 255 0], <span class="string">'LineType'</span>,<span class="string">'AA'</span>);
<span class="keyword">end</span>

<span class="keyword">function</span> [outSrc, outBackprob, outTarget] = process(h, seed, lo, up)
    <span class="comment">%PROCESS  Run algorithm steps</span>

    <span class="comment">% flood-fill source image starting at seed to create object mask</span>
    maskSrc = floodFillMask(h.src, seed, lo, up);
    outSrc = createOutputImage(h.src, maskSrc);

    <span class="comment">% compute 2D histogram of masked object in source, and backproject target</span>
    histo = computeHistogram(h.src, maskSrc);
    [outBackprob,maskTarget] = computeBackprojection(h.target, histo);
    outTarget = createOutputImage(h.target, maskTarget);

    <span class="comment">% overlay titles on output images</span>
    outSrc = drawTitle(outSrc, <span class="string">'Source'</span>);
    outBackprob = drawTitle(outBackprob, <span class="string">'Backprojection'</span>);
    outTarget = drawTitle(outTarget, <span class="string">'Target'</span>);
<span class="keyword">end</span></pre><img src="backproject_demo_gui_01.png"><h2 id="5">UI and callbacks</h2><pre class="codeinput"><span class="keyword">function</span> onType(~,e,h)
    <span class="comment">%ONTYPE  Event handler for key press on figure</span>

    <span class="keyword">switch</span> e.Key
        <span class="keyword">case</span> {<span class="string">'q'</span>, <span class="string">'escape'</span>}
            close(h.fig);
    <span class="keyword">end</span>
<span class="keyword">end</span>

<span class="keyword">function</span> onChange(~,~,h)
    <span class="comment">%ONCHANGE  Event handler for slider</span>

    <span class="comment">% fetch and update threshold values</span>
    lo = round(get(h.slid(1), <span class="string">'Value'</span>));
    up = round(get(h.slid(2), <span class="string">'Value'</span>));
    set(h.txt(1), <span class="string">'String'</span>,sprintf(<span class="string">'LoDiff: %3d'</span>,lo));
    set(h.txt(2), <span class="string">'String'</span>,sprintf(<span class="string">'UpDiff: %3d'</span>,up));

    <span class="comment">% get current seed point</span>
    x = get(h.lin, <span class="string">'XData'</span>);
    y = get(h.lin, <span class="string">'YData'</span>);
    seed = [x(1) y(1)];
    <span class="keyword">if</span> any(isnan(seed))
        <span class="comment">% user didn't specify a seed point yet</span>
        <span class="keyword">return</span>;
    <span class="keyword">end</span>

    <span class="comment">% apply new values and show results</span>
    [outSrc, outBackprob, outTarget] = process(h, seed, lo, up);
    set(h.img(1), <span class="string">'CData'</span>,outSrc);
    set(h.img(2), <span class="string">'CData'</span>,outBackprob);
    set(h.img(3), <span class="string">'CData'</span>,outTarget);
<span class="keyword">end</span>

<span class="keyword">function</span> onClick(~,~,h)
    <span class="comment">%ONCLICK  Event handler for button</span>

    <span class="comment">% prompt user for a new seed point in source image</span>
    seed = getSeedPoint(h.src);
    set(h.lin, <span class="string">'XData'</span>,seed(1), <span class="string">'YData'</span>,seed(2));
    set(h.txt(3), <span class="string">'String'</span>,sprintf(<span class="string">'x=%d, y=%d'</span>,seed));

    <span class="comment">% get current threshold values</span>
    lo = round(get(h.slid(1), <span class="string">'Value'</span>));
    up = round(get(h.slid(2), <span class="string">'Value'</span>));

    <span class="comment">% apply new values and show results</span>
    [outSrc, outBackprob, outTarget] = process(h, seed, lo, up);
    set(h.img(1), <span class="string">'CData'</span>,outSrc);
    set(h.img(2), <span class="string">'CData'</span>,outBackprob);
    set(h.img(3), <span class="string">'CData'</span>,outTarget);
<span class="keyword">end</span>

<span class="keyword">function</span> h = buildGUI(imgs)
    <span class="comment">%BUILDGUI  Creates the UI</span>

    <span class="comment">% vis props</span>
    sz = cellfun(@size, imgs, <span class="string">'UniformOutput'</span>,false);
    sz = cat(1, sz{:});
    H = max(sz(:,1));
    W = sz(1,2) + sz(2,2)*2;

    <span class="comment">% flood-fill options (seed and low/high thresholds)</span>
    seed = [0 0];
    lo = 20;
    up = 20;

    <span class="comment">% overlay titles</span>
    img2 = zeros(size(imgs{2},1), size(imgs{2},2), <span class="string">'uint8'</span>);
    img1 = drawTitle(imgs{1}, <span class="string">'Source'</span>);
    img2 = drawTitle(img2, <span class="string">'Backprojection'</span>);
    img3 = drawTitle(imgs{2}, <span class="string">'Target'</span>);

    <span class="comment">% build the user interface (no resizing to keep it simple)</span>
    h = struct();
    h.src = imgs{1};
    h.target = imgs{2};
    h.fig = figure(<span class="string">'Name'</span>,<span class="string">'Backpoject Demo'</span>, <span class="string">'NumberTitle'</span>,<span class="string">'off'</span>, <span class="keyword">...</span>
        <span class="string">'Menubar'</span>,<span class="string">'none'</span>, <span class="string">'Resize'</span>,<span class="string">'off'</span>, <span class="string">'Position'</span>,[200 200 W H+60-1]);
    <span class="keyword">if</span> ~mexopencv.isOctave()
        <span class="comment">%HACK: not implemented in Octave</span>
        movegui(h.fig, <span class="string">'center'</span>);
    <span class="keyword">end</span>
    h.ax(1) = axes(<span class="string">'Parent'</span>,h.fig, <span class="keyword">...</span>
        <span class="string">'Units'</span>,<span class="string">'pixels'</span>, <span class="string">'Position'</span>,[1 60 sz(1,2) sz(1,1)]);
    h.ax(2) = axes(<span class="string">'Parent'</span>,h.fig, <span class="keyword">...</span>
        <span class="string">'Units'</span>,<span class="string">'pixels'</span>, <span class="string">'Position'</span>,[sz(1,2)+1 60 sz(2,2) sz(2,1)]);
    h.ax(3) = axes(<span class="string">'Parent'</span>,h.fig, <span class="keyword">...</span>
        <span class="string">'Units'</span>,<span class="string">'pixels'</span>, <span class="string">'Position'</span>,[sz(1,2)+sz(2,2)+1 60 sz(2,2) sz(2,1)]);
    <span class="keyword">if</span> ~mexopencv.isOctave()
        h.img(1) = imshow(img1, <span class="string">'Parent'</span>,h.ax(1));
        h.img(2) = imshow(img2, <span class="string">'Parent'</span>,h.ax(2));
        h.img(3) = imshow(img3, <span class="string">'Parent'</span>,h.ax(3));
    <span class="keyword">else</span>
        <span class="comment">%HACK: https://savannah.gnu.org/bugs/index.php?45473</span>
        axes(h.ax(1)); h.img(1) = imshow(img1);
        axes(h.ax(2)); h.img(2) = imshow(img2);
        axes(h.ax(3)); h.img(3) = imshow(img3);
    <span class="keyword">end</span>
    opts = {<span class="string">'FontSize'</span>,11, <span class="string">'HorizontalAlignment'</span>,<span class="string">'right'</span>};
    h.lin = line(NaN, NaN, <span class="string">'Parent'</span>,h.ax(1), <span class="string">'Color'</span>,<span class="string">'g'</span>, <span class="keyword">...</span>
        <span class="string">'LineWidth'</span>,2, <span class="string">'LineStyle'</span>,<span class="string">'none'</span>, <span class="string">'Marker'</span>,<span class="string">'x'</span>, <span class="string">'MarkerSize'</span>,10);
    h.but = uicontrol(<span class="string">'Parent'</span>,h.fig, <span class="string">'Style'</span>,<span class="string">'pushbutton'</span>, <span class="keyword">...</span>
        <span class="string">'Position'</span>,[5 30 80 20], <span class="string">'String'</span>,<span class="string">'New Seed'</span>);
    h.txt(1) = uicontrol(<span class="string">'Parent'</span>,h.fig, <span class="string">'Style'</span>,<span class="string">'text'</span>, opts{:}, <span class="keyword">...</span>
        <span class="string">'Position'</span>,[90 5 80 20], <span class="string">'String'</span>,sprintf(<span class="string">'LoDiff: %3d'</span>,lo));
    h.txt(2) = uicontrol(<span class="string">'Parent'</span>,h.fig, <span class="string">'Style'</span>,<span class="string">'text'</span>, opts{:}, <span class="keyword">...</span>
        <span class="string">'Position'</span>,[90 30 80 20], <span class="string">'String'</span>,sprintf(<span class="string">'UpDiff: %3d'</span>,up));
    h.txt(3) = uicontrol(<span class="string">'Parent'</span>,h.fig, <span class="string">'Style'</span>,<span class="string">'text'</span>, <span class="string">'FontSize'</span>,8, <span class="keyword">...</span>
        <span class="string">'Position'</span>,[5 5 80 20], <span class="string">'Enable'</span>,<span class="string">'off'</span>, <span class="keyword">...</span>
        <span class="string">'String'</span>,sprintf(<span class="string">'x=%d, y=%d'</span>,seed));
    h.slid(1) = uicontrol(<span class="string">'Parent'</span>,h.fig, <span class="string">'Style'</span>,<span class="string">'slider'</span>, <span class="string">'Value'</span>,lo, <span class="keyword">...</span>
        <span class="string">'Min'</span>,0, <span class="string">'Max'</span>,255, <span class="string">'SliderStep'</span>,[1 10]./(255-0), <span class="keyword">...</span>
        <span class="string">'Position'</span>,[170 5 W-170-5 20]);
    h.slid(2) = uicontrol(<span class="string">'Parent'</span>,h.fig, <span class="string">'Style'</span>,<span class="string">'slider'</span>, <span class="string">'Value'</span>,up, <span class="keyword">...</span>
        <span class="string">'Min'</span>,0, <span class="string">'Max'</span>,255, <span class="string">'SliderStep'</span>,[1 10]./(255-0), <span class="keyword">...</span>
        <span class="string">'Position'</span>,[170 30 W-170-5 20]);

    <span class="comment">% hook event handlers</span>
    opts = {<span class="string">'Interruptible'</span>,<span class="string">'off'</span>, <span class="string">'BusyAction'</span>,<span class="string">'cancel'</span>};
    set(h.fig, <span class="string">'WindowKeyPressFcn'</span>,{@onType,h}, opts{:});
    set(h.slid, <span class="string">'Callback'</span>,{@onChange,h}, opts{:});
    set(h.but, <span class="string">'Callback'</span>,{@onClick,h}, opts{:});
<span class="keyword">end</span></pre><div class="footer">
            <p><a href="https://www.mathworks.com/products/matlab.html">Published with MATLAB&reg; R2017a</a></p>
         </div>
      </div><script type="text/x-mathjax-config">
  // https://stackoverflow.com/a/14631703/97160
  MathJax.Extension.myImg2jax = {
    version: "1.0",
    PreProcess: function (element) {
      var images = element.getElementsByTagName("img");
      for (var i = images.length - 1; i >= 0; i--) {
        var img = images[i];
        if (img.className === "equation") {
          var match = img.alt.match(/^(\$\$?)([\s\S]*)\1$/m);
          if (!match) continue;
          var script = document.createElement("script");
          script.type = "math/tex";
          if (match[1] === "$$") {script.type += ";mode=display"}
          MathJax.HTML.setScript(script, match[2]);
          img.parentNode.replaceChild(script, img);
        }
      }
    }
  };
  MathJax.Hub.Register.PreProcessor(["PreProcess", MathJax.Extension.myImg2jax]);
  </script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-AMS_CHTML"></script>
      <!--
##### SOURCE BEGIN #####
%% Back Projection
%
% In this demo, we will learn:
%
% * What is Back Projection and why it is useful
% * How to use the OpenCV function |cv.calcBackProject| to calculate Back
%   Projection
%
% Sources:
%
% * <https://docs.opencv.org/3.2.0/da/d7f/tutorial_back_projection.html>
% * <https://docs.opencv.org/3.2.0/dc/df6/tutorial_py_histogram_backprojection.html>
% * <https://github.com/opencv/opencv/blob/3.2.0/samples/cpp/tutorial_code/Histograms_Matching/calcBackProject_Demo1.cpp>
% * <https://github.com/opencv/opencv/blob/3.2.0/samples/cpp/tutorial_code/Histograms_Matching/calcBackProject_Demo2.cpp>
%

%% Theory
%
% Back Projection is a way of recording how well the pixels of a given image
% fit the distribution of pixels in a histogram model. To make it simpler, for
% Back Projection, you calculate the histogram model of a feature and then use
% it to find this feature in an image. Application example: If you have a
% histogram of flesh color (say, a Hue-Saturation histogram), then you can
% use it to find flesh color areas in an image.
%
% We explain how it works by using the skin example.
% Let's say you have gotten a skin histogram (Hue-Saturation) based on the
% image below. The histogram besides is going to be our _model histogram_
% (which we know represents a sample of skin tonality). You applied some mask
% to capture only the histogram of the skin area:
%
% <<https://docs.opencv.org/3.2.0/Back_Projection_Theory0.jpg>>
%
% <<https://docs.opencv.org/3.2.0/Back_Projection_Theory1.jpg>>
%
% Now, let's imagine that you get another hand image (test Image) like the one
% below, with its respective histogram:
%
% <<https://docs.opencv.org/3.2.0/Back_Projection_Theory2.jpg>>
%
% <<https://docs.opencv.org/3.2.0/Back_Projection_Theory3.jpg>>
%
% What we want to do is to use our _model histogram_ (that we know represents
% a skin tonality) to detect skin areas in our test image. Here are the steps
%
% * In each pixel of our test image (i.e. $p(i,j)$ ), collect the data and
%   find the correspondent bin location for that pixel (i.e.
%   $( h_{i,j}, s_{i,j} )$ ).
% * Lookup the _model histogram_ in the correspondent bin,
%   $( h_{i,j}, s_{i,j} )$, and read the bin value.
% * Store this bin value in a new image (_BackProjection_). Also, you may
%   consider to normalize the _model histogram_ first, so the output for the
%   test image can be visible for you.
% * Applying the steps above, we get the following BackProjection image for
%   our test image:
%
% <<https://docs.opencv.org/3.2.0/Back_Projection_Theory4.jpg>>
%
% * In terms of statistics, the values stored in _BackProjection_ represent
%   the _probability_ that a pixel in _test image_ belongs to a skin area,
%   based on the _model histogram_ that we use. For instance in our test
%   image, the brighter areas are more probable to be skin area (as they
%   actually are), whereas the darker areas have less probability (notice that
%   these "dark" areas belong to surfaces that have some shadow on it, which
%   in turns affects the detection).
%

%% Code
%
% The steps:
%
% * Load an image
% * Convert the original to HSV format and separate only _Hue_ channel to be
%   used for the Histogram
% * Let the user to enter the number of bins to be used in the calculation of
%   the histogram.
% * Calculate the histogram (and update it if the bins change) and the
%   backprojection of the same image.
% * Display the backprojection and the histogram in windows.
%
% The code in this sample doesn't implement the basic version explained above.
% In fact it improves the process by building a 2D H-S histograms and
% using |cv.floodFill| to define a mask for the skin area. For more, you can
% also checkout the classical camshift sample in |camshift_demo_gui.m|.
%

function varargout = backproject_demo_gui()
    % load images (base image and test image)
    imgs = loadImages();

    % create the UI
    h = buildGUI(imgs);
    if nargout > 0, varargout{1} = h; end
end

%% Helper functions

function imgs = loadImages()
    %LOADIMAGES  Load source and target images

    % source and target images
    im = {
        'https://docs.opencv.org/3.2.0/Histogram_Comparison_Source_0.jpg'
        'https://docs.opencv.org/3.2.0/Histogram_Comparison_Source_1.jpg'
    };
    imgs = cell(size(im));
    for i=1:numel(im)
        % download if necessary
        [~,name,ext] = fileparts(im{i});
        fname = fullfile(mexopencv.root(), 'test', [name ext]);
        if exist(fname, 'file') ~= 2
            disp('Downloading image...')
            urlwrite(im{i}, fname);
        end
        % load image
        imgs{i} = cv.imread(fname, 'Color',true);
        % upsample, images are a bit small
        s = 1.5;
        imgs{i} = cv.resize(imgs{i}, s, s);
    end
end

function pt = getSeedPoint(img)
    %GETSEEDPOINT  Prompt user for flood-fill seed point
    %
    % See also: ginput, getpts, impixel, waitforbuttonpress, CurrentPoint
    %

    sz = [size(img,2) size(img,1)];
    pt0 = round(sz/2);
    valid = @(p) ~isempty(p) && all((p(:) > 0) & (p(:) <= sz(:)));

    if ~mexopencv.isOctave()
        % display image, and prompt user for seed point
        fig = figure('Menubar','none', 'WindowStyle','Modal');
        imshow(img), axis on
        title('Select seed point'), xlabel('X'), ylabel('Y')
        try
            while true
                [x,y] = ginput(1);
                pt = round([x y]);
                if valid(pt), break; end
            end
        catch
            pt = pt0;
        end
        if ishghandle(fig), close(fig); end
    elseif true
        %HACK: for some reason, Octave never returns from GINPUT in code above
        % fallback to using an input dialog to prompt for seed point
        while true
            str = arrayfun(@num2str, pt0, 'UniformOutput',false);
            str = inputdlg({'seed.x','seed.y'}, 'Seed Point', 1, str);
            pt = str2double(str);
            if valid(pt), break; end
        end
    else
        %pt = pt0;
        pt = [120 100];
    end
end

function mask = floodFillMask(img, seed, lo, up)
    %FLOODFILLMASK  Flood-fill source image to create mask over object

    % create mask image (padded by 1 pixel in both directions)
    sz = size(img);
    mask = zeros(sz(1:2) + 2, 'uint8');

    % flood-fill the mask image starting at the seed
    [~,~,~,mask] = cv.floodFill(img, seed, [120 120 120], ...
        'Mask',mask, 'MaskOnly',true, 'MaskFillValue',255, ...
        'LoDiff',[lo lo lo], 'UpDiff',[up up up], ...
        'FixedRange',true, 'Connectivity',8);
    mask = mask(2:end-1,2:end-1);

    if true
        % process the mask (morphological closing)
        el = cv.getStructuringElement('Shape','Ellipse', 'KSize',[5 5]);
        mask = cv.morphologyEx(mask, 'Close', 'Element',el);
    end
end

function [histo, hue] = computeHistogram(img, mask, nbins)
    %COMPUTEHISTOGRAM  Compute hue/saturation histogram

    if nargin < 2, mask = []; end
    if nargin < 3, nbins = [30 32]; end

    % convert source image to HSV colorspace
    imgHSV = cv.cvtColor(img, 'RGB2HSV');
    if nargout > 1
        hue = imgHSV(:,:,1);
    end

    % compute H-S histogram of source image, with mask indicating object
    ranges = {[0 180], [0 256]};
    histo = cv.calcHist(imgHSV, ranges, 'HistSize',nbins, 'Uniform',true, ....
        'Channels',[0 1], 'Mask',mask);

    % normalize it to [0,255] range
    histo = cv.normalize(histo, 'NormType','MinMax', 'Alpha',0, 'Beta',255);
end

function [prob,mask] = computeBackprojection(img, histo)
    %COMPUTEBACKPROJECTION  Target image backproject

    % convert target image to HSV colorspace
    imgHSV = cv.cvtColor(img, 'RGB2HSV');

    % backproject the target image using source histogram
    ranges = {[0 180], [0 256]};
    prob = cv.calcBackProject(imgHSV, histo, ranges, 'Uniform',true, ...
        'Channels',[0 1]);

    if nargout > 1
        % process backprojection to extract object in target image
        el = cv.getStructuringElement('Shape','Ellipse', 'KSize',[7 7]);
        mask = cv.filter2D(prob, el);
        mask = cv.morphologyEx(mask, 'Close', 'Element',el, 'Iterations',3);
        mask = cv.threshold(mask, 'Otsu');
    end
end

function out = createOutputImage(img, mask)
    %CREATEOUTPUTIMAGE  Combine image and mask for output

    maskRGB = cv.cvtColor(mask, 'GRAY2RGB');
    if true
        % overlay mask with transparency
        if true
            maskRGB(:,:,3) = 0;
            overlay = cv.bitwise_or(img, maskRGB);
        elseif true
            maskRGB(:,:,3) = 0;
            overlay = cv.copyTo(maskRGB, 'Dest',img, 'Mask',mask);
        else
            mask = logical(mask);
            R = img(:,:,1); R(mask) = 255;
            G = img(:,:,2); G(mask) = 255;
            B = img(:,:,2); B(mask) = 0;
            overlay = cat(3, R, G, B);
        end
        a = 0.4;
        out = cv.addWeighted(overlay,a, img,1-a, 0.0);
    elseif true
        % cut-out mask region
        out = cv.bitwise_and(img, maskRGB);
    else
        % binary mask
        out = maskRGB;
    end
end

function showHistogram(histo)
    %SHOWHISTOGRAM  Display 2D histogram

    ranges = {[0 180], [0 256]};
    figure, imagesc(histo, 'YData',ranges{1}, 'XData',ranges{2})
    ylabel('Hue'), xlabel('Saturation'), title('H-S histogram')
    colormap gray
end

function img = drawTitle(img, str)
    %DRAWTITLE  Draw title on output image

    img = cv.putText(img, str, [10 20], ...
        'FontScale',0.5, 'Color',[255 255 0], 'LineType','AA');
end

function [outSrc, outBackprob, outTarget] = process(h, seed, lo, up)
    %PROCESS  Run algorithm steps

    % flood-fill source image starting at seed to create object mask
    maskSrc = floodFillMask(h.src, seed, lo, up);
    outSrc = createOutputImage(h.src, maskSrc);

    % compute 2D histogram of masked object in source, and backproject target
    histo = computeHistogram(h.src, maskSrc);
    [outBackprob,maskTarget] = computeBackprojection(h.target, histo);
    outTarget = createOutputImage(h.target, maskTarget);

    % overlay titles on output images
    outSrc = drawTitle(outSrc, 'Source');
    outBackprob = drawTitle(outBackprob, 'Backprojection');
    outTarget = drawTitle(outTarget, 'Target');
end

%% UI and callbacks

function onType(~,e,h)
    %ONTYPE  Event handler for key press on figure

    switch e.Key
        case {'q', 'escape'}
            close(h.fig);
    end
end

function onChange(~,~,h)
    %ONCHANGE  Event handler for slider

    % fetch and update threshold values
    lo = round(get(h.slid(1), 'Value'));
    up = round(get(h.slid(2), 'Value'));
    set(h.txt(1), 'String',sprintf('LoDiff: %3d',lo));
    set(h.txt(2), 'String',sprintf('UpDiff: %3d',up));

    % get current seed point
    x = get(h.lin, 'XData');
    y = get(h.lin, 'YData');
    seed = [x(1) y(1)];
    if any(isnan(seed))
        % user didn't specify a seed point yet
        return;
    end

    % apply new values and show results
    [outSrc, outBackprob, outTarget] = process(h, seed, lo, up);
    set(h.img(1), 'CData',outSrc);
    set(h.img(2), 'CData',outBackprob);
    set(h.img(3), 'CData',outTarget);
end

function onClick(~,~,h)
    %ONCLICK  Event handler for button

    % prompt user for a new seed point in source image
    seed = getSeedPoint(h.src);
    set(h.lin, 'XData',seed(1), 'YData',seed(2));
    set(h.txt(3), 'String',sprintf('x=%d, y=%d',seed));

    % get current threshold values
    lo = round(get(h.slid(1), 'Value'));
    up = round(get(h.slid(2), 'Value'));

    % apply new values and show results
    [outSrc, outBackprob, outTarget] = process(h, seed, lo, up);
    set(h.img(1), 'CData',outSrc);
    set(h.img(2), 'CData',outBackprob);
    set(h.img(3), 'CData',outTarget);
end

function h = buildGUI(imgs)
    %BUILDGUI  Creates the UI

    % vis props
    sz = cellfun(@size, imgs, 'UniformOutput',false);
    sz = cat(1, sz{:});
    H = max(sz(:,1));
    W = sz(1,2) + sz(2,2)*2;

    % flood-fill options (seed and low/high thresholds)
    seed = [0 0];
    lo = 20;
    up = 20;

    % overlay titles
    img2 = zeros(size(imgs{2},1), size(imgs{2},2), 'uint8');
    img1 = drawTitle(imgs{1}, 'Source');
    img2 = drawTitle(img2, 'Backprojection');
    img3 = drawTitle(imgs{2}, 'Target');

    % build the user interface (no resizing to keep it simple)
    h = struct();
    h.src = imgs{1};
    h.target = imgs{2};
    h.fig = figure('Name','Backpoject Demo', 'NumberTitle','off', ...
        'Menubar','none', 'Resize','off', 'Position',[200 200 W H+60-1]);
    if ~mexopencv.isOctave()
        %HACK: not implemented in Octave
        movegui(h.fig, 'center');
    end
    h.ax(1) = axes('Parent',h.fig, ...
        'Units','pixels', 'Position',[1 60 sz(1,2) sz(1,1)]);
    h.ax(2) = axes('Parent',h.fig, ...
        'Units','pixels', 'Position',[sz(1,2)+1 60 sz(2,2) sz(2,1)]);
    h.ax(3) = axes('Parent',h.fig, ...
        'Units','pixels', 'Position',[sz(1,2)+sz(2,2)+1 60 sz(2,2) sz(2,1)]);
    if ~mexopencv.isOctave()
        h.img(1) = imshow(img1, 'Parent',h.ax(1));
        h.img(2) = imshow(img2, 'Parent',h.ax(2));
        h.img(3) = imshow(img3, 'Parent',h.ax(3));
    else
        %HACK: https://savannah.gnu.org/bugs/index.php?45473
        axes(h.ax(1)); h.img(1) = imshow(img1);
        axes(h.ax(2)); h.img(2) = imshow(img2);
        axes(h.ax(3)); h.img(3) = imshow(img3);
    end
    opts = {'FontSize',11, 'HorizontalAlignment','right'};
    h.lin = line(NaN, NaN, 'Parent',h.ax(1), 'Color','g', ...
        'LineWidth',2, 'LineStyle','none', 'Marker','x', 'MarkerSize',10);
    h.but = uicontrol('Parent',h.fig, 'Style','pushbutton', ...
        'Position',[5 30 80 20], 'String','New Seed');
    h.txt(1) = uicontrol('Parent',h.fig, 'Style','text', opts{:}, ...
        'Position',[90 5 80 20], 'String',sprintf('LoDiff: %3d',lo));
    h.txt(2) = uicontrol('Parent',h.fig, 'Style','text', opts{:}, ...
        'Position',[90 30 80 20], 'String',sprintf('UpDiff: %3d',up));
    h.txt(3) = uicontrol('Parent',h.fig, 'Style','text', 'FontSize',8, ...
        'Position',[5 5 80 20], 'Enable','off', ...
        'String',sprintf('x=%d, y=%d',seed));
    h.slid(1) = uicontrol('Parent',h.fig, 'Style','slider', 'Value',lo, ...
        'Min',0, 'Max',255, 'SliderStep',[1 10]./(255-0), ...
        'Position',[170 5 W-170-5 20]);
    h.slid(2) = uicontrol('Parent',h.fig, 'Style','slider', 'Value',up, ...
        'Min',0, 'Max',255, 'SliderStep',[1 10]./(255-0), ...
        'Position',[170 30 W-170-5 20]);

    % hook event handlers
    opts = {'Interruptible','off', 'BusyAction','cancel'};
    set(h.fig, 'WindowKeyPressFcn',{@onType,h}, opts{:});
    set(h.slid, 'Callback',{@onChange,h}, opts{:});
    set(h.but, 'Callback',{@onClick,h}, opts{:});
end

##### SOURCE END #####
--></body>
</html>