<!DOCTYPE html>
<html>
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   
      <!--This HTML was auto-generated from published MATLAB code.-->
      <title>svm_hog_ocr_digits_demo</title>
      <meta name="generator" content="MATLAB 9.2">
      <link rel="schema.DC" href="http://purl.org/dc/elements/1.1/">
      <meta name="DC.date" content="2017-11-27">
      <meta name="DC.source" content="svm_hog_ocr_digits_demo.m">
      <link rel="stylesheet" type="text/css" href="publish_custom.css">
   </head>
   <body>
      <div class="content">
         <h2 id="toc">Contents</h2>
         <div>
            <ul>
               <li><a href="#1">OCR of hand-written digits using HoG and SVM</a></li>
               <li><a href="#2">Data</a></li>
               <li><a href="#5">HoG</a></li>
               <li><a href="#8">Classification</a></li>
               <li><a href="#15">Helper functions</a></li>
            </ul>
         </div>
         <h2 id="1">OCR of hand-written digits using HoG and SVM</h2>
         <p>In this tutorial, we will build an SVM classifer to recognize hand-written digits (0 to 9), using Histogram of Oriented Gradients
            (HOG) as feature vectors.
         </p>
         <p>For additional resources, see this <a href="https://www.youtube.com/watch?v=0Zib1YEE4LU">HoG video lecture</a>.
         </p>
         <p>Sources:</p>
         <div>
            <ul>
               <li><a href="https://docs.opencv.org/3.2.0/dd/d3b/tutorial_py_svm_opencv.html">https://docs.opencv.org/3.2.0/dd/d3b/tutorial_py_svm_opencv.html</a></li>
               <li><a href="https://github.com/opencv/opencv/blob/3.2.0/samples/python/digits.py">https://github.com/opencv/opencv/blob/3.2.0/samples/python/digits.py</a></li>
               <li><a href="https://www.mathworks.com/help/vision/examples/digit-classification-using-hog-features.html">https://www.mathworks.com/help/vision/examples/digit-classification-using-hog-features.html</a></li>
            </ul>
         </div><pre class="codeinput"><span class="keyword">function</span> svm_hog_ocr_digits_demo()</pre><h2 id="2">Data</h2>
         <p>Load MNIST handwritten digits (5000 images) (params in this demo are hardcoded assuming 20x20 images)</p><pre class="codeinput">    [imgs, labels, img] = load_mnist_digits();
    assert(numel(imgs)==5000 &amp;&amp; isequal(size(imgs{1}),[20 20]));</pre><p>Show a portion of the big image</p><pre class="codeinput">    imshow(img(1:350,1:450))
    <span class="comment">%imtool(img)</span></pre><img src="svm_hog_ocr_digits_demo_01.png"><p>Show a sample of an image before and after deskew is applied</p><pre class="codeinput">    figure
    subplot(121), imshow(imgs{1}), title(<span class="string">'original'</span>)
    subplot(122), imshow(deskew(imgs{1})), title(<span class="string">'deskewed'</span>)</pre><img src="svm_hog_ocr_digits_demo_02.png"><h2 id="5">HoG</h2>
         <p>choose an HoG implementation to use: OpenCV, MATLAB, or a simple custom one</p><pre class="codeinput">    HOG_ALG = <span class="string">'opencv'</span>;
    HOG_ALG = validatestring(HOG_ALG, {<span class="string">'custom'</span>, <span class="string">'matlab'</span>, <span class="string">'opencv'</span>});</pre><p>HoG features are stored in a matrix, one row per image</p><pre class="codeinput">    <span class="keyword">switch</span> HOG_ALG
        <span class="keyword">case</span> <span class="string">'custom'</span>
            nbins = 16;          <span class="comment">% number of bins to quantize gradient angles</span>
            nfeats = 4 * nbins;  <span class="comment">% feature length</span>
        <span class="keyword">case</span> <span class="string">'matlab'</span>
            opts = {<span class="string">'CellSize'</span>,[10 10], <span class="string">'BlockSize'</span>,[2 2], <span class="keyword">...</span>
                <span class="string">'NumBins'</span>,9, <span class="string">'UseSignedOrientation'</span>,true};
            nfeats = numel(extractHOGFeatures(imgs{1}, opts{:}));
        <span class="keyword">case</span> <span class="string">'opencv'</span>
            <span class="comment">% create HOG object</span>
            opts = {<span class="string">'WinSize'</span>,[20 20], <span class="string">'BlockSize'</span>,[10 10], <span class="keyword">...</span>
                <span class="string">'BlockStride'</span>,[5 5], <span class="string">'CellSize'</span>,[10 10], <span class="keyword">...</span>
                <span class="string">'NBins'</span>,9, <span class="string">'SignedGradient'</span>,true};
            <span class="comment">%opts = [opts, 'GammaCorrection',false];</span>
            hog = cv.HOGDescriptor(opts{:});
            nfeats = numel(hog.compute(imgs{1}));
            display(hog)
    <span class="keyword">end</span>
    descs = zeros(numel(imgs), nfeats, <span class="string">'single'</span>);</pre><pre class="codeoutput">hog = 
  HOGDescriptor with properties:

                   id: 4
              WinSize: [20 20]
            BlockSize: [10 10]
          BlockStride: [5 5]
             CellSize: [10 10]
                NBins: 9
        DerivAperture: 1
             WinSigma: -1
    HistogramNormType: 'L2Hys'
       L2HysThreshold: 0.2000
      GammaCorrection: 0
              NLevels: 64
       SignedGradient: 1
          SvmDetector: [1&times;0 single]
</pre><p>Process images and compute HOG descriptors for each</p><pre class="codeinput">    tic
    disp(<span class="string">'Extracting...'</span>)
    <span class="keyword">for</span> i=1:numel(imgs)
        <span class="comment">% deskew image</span>
        img = deskew(imgs{i});
        <span class="comment">%img = cv.threshold(img, 'Otsu');</span>

        <span class="comment">% compute HOG descriptors flattened as a vector</span>
        <span class="keyword">switch</span> HOG_ALG
            <span class="keyword">case</span> <span class="string">'custom'</span>
                descs(i,:) = my_hog(img, nbins);
            <span class="keyword">case</span> <span class="string">'matlab'</span>
                descs(i,:) = extractHOGFeatures(img, opts{:});
            <span class="keyword">case</span> <span class="string">'opencv'</span>
                d = hog.compute(img).'; <span class="comment">% returns a matrix, one row per window</span>
                descs(i,:) = d(:);
        <span class="keyword">end</span>
    <span class="keyword">end</span>
    toc</pre><pre class="codeoutput">Extracting...
Elapsed time is 3.625383 seconds.
</pre><h2 id="8">Classification</h2>
         <p>Create multi-class linear SVM classifier</p><pre class="codeinput">    svm = cv.SVM();
    svm.Type = <span class="string">'C_SVC'</span>;
    svm.KernelType = <span class="string">'Linear'</span>;
    svm.C = 0.5;  <span class="comment">% or do a trainAuto grid search to find optimal C</span>
    display(svm)</pre><pre class="codeoutput">svm = 
  SVM with properties:

              id: 6
            Type: 'C_SVC'
      KernelType: 'Linear'
          Degree: 0
           Gamma: 1
           Coef0: 0
               C: 0.5000
              Nu: 0
               P: 0
    ClassWeights: []
    TermCriteria: [1&times;1 struct]
</pre><p>split data samples and corresponding labels</p><pre class="codeinput">    labels = int32(labels(:));
    N = 2500;  <span class="comment">% fix(numel(labels)/2)</span>
    whos <span class="string">descs</span> <span class="string">labels</span>
    <span class="keyword">if</span> ~mexopencv.isOctave() &amp;&amp; mexopencv.require(<span class="string">'stats'</span>)
        <span class="comment">% train/test split</span>
        tabulate(labels(1:N))
        tabulate(labels(N+1:end))
    <span class="keyword">end</span></pre><pre class="codeoutput">  Name           Size              Bytes  Class     Attributes

  descs       5000x81            1620000  single              
  labels      5000x1               20000  int32               

  Value    Count   Percent
      0      250     10.00%
      1      250     10.00%
      2      250     10.00%
      3      250     10.00%
      4      250     10.00%
      5      250     10.00%
      6      250     10.00%
      7      250     10.00%
      8      250     10.00%
      9      250     10.00%
  Value    Count   Percent
      0      250     10.00%
      1      250     10.00%
      2      250     10.00%
      3      250     10.00%
      4      250     10.00%
      5      250     10.00%
      6      250     10.00%
      7      250     10.00%
      8      250     10.00%
      9      250     10.00%
</pre><p>use half as training data</p><pre class="codeinput">    tic
    disp(<span class="string">'Training...'</span>)
    svm.train(descs(1:N,:), labels(1:N));
    toc</pre><pre class="codeoutput">Training...
Elapsed time is 0.088898 seconds.
</pre><p>the other half for testing</p><pre class="codeinput">    tic
    disp(<span class="string">'Testing...'</span>)
    yhat = svm.predict(descs(N+1:end,:));
    toc
    <span class="comment">%TODO: https://savannah.gnu.org/bugs/?50716</span></pre><pre class="codeoutput">Testing...
Elapsed time is 0.006316 seconds.
</pre><p>performance on test set</p><pre class="codeinput">    acc = nnz(yhat == labels(N+1:end));
    confmat = accumarray([labels(N+1:end), yhat]+1, 1);
    display(confmat)
    fprintf(<span class="string">'Accuracy = %f%%\n'</span>, (acc/N)*100);</pre><pre class="codeoutput">confmat =
   249     0     0     0     0     0     1     0     0     0
     0   246     1     1     0     0     0     2     0     0
     0     1   236     8     1     0     0     4     0     0
     0     0     0   242     0     0     0     5     2     1
     0     0     0     0   245     0     0     0     0     5
     0     0     0     0     0   249     0     0     1     0
     0     0     1     0     0     0   249     0     0     0
     0     1     5     1     0     0     0   239     2     2
     0     1     1     1     0     2     2     0   241     2
     0     1     0     0     0     1     0     8     0   240
Accuracy = 97.440000%
</pre><p>Show some of the wrong predictions</p><pre class="codeinput">    idx = (yhat ~= labels(N+1:end));
    fprintf(<span class="string">'Number of wrong predictions = %d / %d\n'</span>, nnz(idx), N);
    figure
    idx = find(idx, 3*3, <span class="string">'first'</span>);
    <span class="keyword">for</span> i=1:numel(idx)
        ii = idx(i);
        subplot(3,3,i), imshow(imgs{ii+N})
        title(sprintf(<span class="string">'%d \\rightarrow %d'</span>, labels(ii+N), yhat(ii)))
    <span class="keyword">end</span></pre><pre class="codeoutput">Number of wrong predictions = 64 / 2500
</pre><img src="svm_hog_ocr_digits_demo_03.png"><pre class="codeinput"><span class="keyword">end</span></pre><h2 id="15">Helper functions</h2><pre class="codeinput"><span class="keyword">function</span> [imgs, labels, img] = load_mnist_digits()
    <span class="comment">% Load MNIST handwritten digits, one big image</span>
    fname = fullfile(mexopencv.root(), <span class="string">'test'</span>, <span class="string">'digits.png'</span>);
    <span class="keyword">if</span> exist(fname, <span class="string">'file'</span>) ~= 2
        disp(<span class="string">'Downloading image...'</span>)
        url = <span class="string">'https://cdn.rawgit.com/opencv/opencv/3.2.0/samples/data/digits.png'</span>;
        urlwrite(url, fname);
    <span class="keyword">end</span>
    img = cv.imread(fname, <span class="string">'Grayscale'</span>,true);

    <span class="comment">% split it into 5000 small images (500 from each 0:9 digits),</span>
    <span class="comment">% each image is 20x20 pixels</span>
    [h,w] = size(img);
    imgs = mat2cell(img, ones(1,50)*h/50, ones(1,100)*w/100);
    imgs = reshape(imgs', 500, [])';  <span class="comment">% cell array of size 10x500</span>
    labels = repmat((0:9)', 1, 500);  <span class="comment">% each row is one digit</span>
<span class="keyword">end</span>

<span class="keyword">function</span> img = deskew(img)
    <span class="comment">% deskew image using its second order moments</span>
    sz = 20;
    m = cv.moments(img);
    <span class="keyword">if</span> abs(m.mu02) &gt; 0.2  <span class="comment">% 0.01</span>
        skew = m.mu11 / m.mu02;
        M = [1 skew -0.5*sz*skew; 0 1 0];
        img = cv.warpAffine(img, M, <span class="string">'DSize'</span>,[sz sz], <span class="string">'WarpInverse'</span>,true);
    <span class="keyword">end</span>
<span class="keyword">end</span>

<span class="keyword">function</span> histo = my_hog(img, nbins)
    <span class="comment">% this is a simplified implementation of HoG descriptors</span>
    <span class="comment">% (fixed 10x10 cells, 1 block, no overlapping, no block normalization)</span>

    <span class="comment">% number of orientation histogram bins</span>
    <span class="keyword">if</span> nargin &lt; 2, nbins = 16; <span class="keyword">end</span>

    <span class="comment">% compute image gradient (its magnitude and direction)</span>
    gx = cv.Sobel(img, <span class="string">'DDepth'</span>,<span class="string">'single'</span>, <span class="string">'XOrder'</span>,1, <span class="string">'YOrder'</span>,0);
    gy = cv.Sobel(img, <span class="string">'DDepth'</span>,<span class="string">'single'</span>, <span class="string">'XOrder'</span>,0, <span class="string">'YOrder'</span>,1);
    mag = hypot(gx, gy);
    ang = atan2(gy, gx) + pi;  <span class="comment">% directions in [0,2*pi] (signed gradient)</span>

    <span class="comment">% quantize directions into 16 bins</span>
    bins = fix((nbins-1) * ang/(2*pi)) + 1; <span class="comment">% bin indices in [1,16] inclusive</span>

    <span class="comment">% divide 20x20 image into 4 10x10 cells, and in each,</span>
    <span class="comment">% accumulate gradient magnitudes inside each direction bin</span>
    <span class="comment">% (binned orientations each weighted by its magnitude contribution)</span>
    bb = mat2cell(bins, [10 10], [10 10]);
    mm = mat2cell(mag, [10 10], [10 10]);
    histo = cell(size(bb));
    <span class="keyword">for</span> i=1:numel(bb)
        H = accumarray(bb{i}(:), mm{i}(:), [nbins 1]);
        <span class="keyword">if</span> false &amp;&amp; any(H)
            <span class="comment">% transform histogram to space with Hellinger metric</span>
            H = sqrt(H ./ sum(H));
            H = H ./ norm(H);
        <span class="keyword">end</span>
        histo{i} = H;
    <span class="keyword">end</span>

    <span class="comment">% stack features from cells into one tall vector of length 4*16</span>
    histo = cat(1, histo{:});
<span class="keyword">end</span></pre><div class="footer">
            <p><a href="https://www.mathworks.com/products/matlab.html">Published with MATLAB&reg; R2017a</a></p>
         </div>
      </div>
      <!--
##### SOURCE BEGIN #####
%% OCR of hand-written digits using HoG and SVM
%
% In this tutorial, we will build an SVM classifer to recognize
% hand-written digits (0 to 9), using Histogram of Oriented Gradients (HOG)
% as feature vectors.
%
% For additional resources, see this
% <https://www.youtube.com/watch?v=0Zib1YEE4LU HoG video lecture>.
%
% Sources:
%
% * <https://docs.opencv.org/3.2.0/dd/d3b/tutorial_py_svm_opencv.html>
% * <https://github.com/opencv/opencv/blob/3.2.0/samples/python/digits.py>
% * <https://www.mathworks.com/help/vision/examples/digit-classification-using-hog-features.html>
%

function svm_hog_ocr_digits_demo()
    %% Data
    % Load MNIST handwritten digits (5000 images)
    % (params in this demo are hardcoded assuming 20x20 images)
    [imgs, labels, img] = load_mnist_digits();
    assert(numel(imgs)==5000 && isequal(size(imgs{1}),[20 20]));

    %%
    % Show a portion of the big image
    imshow(img(1:350,1:450))
    %imtool(img)

    %%
    % Show a sample of an image before and after deskew is applied
    figure
    subplot(121), imshow(imgs{1}), title('original')
    subplot(122), imshow(deskew(imgs{1})), title('deskewed')

    %% HoG
    % choose an HoG implementation to use: OpenCV, MATLAB, or a simple custom one
    HOG_ALG = 'opencv';
    HOG_ALG = validatestring(HOG_ALG, {'custom', 'matlab', 'opencv'});

    %%
    % HoG features are stored in a matrix, one row per image
    switch HOG_ALG
        case 'custom'
            nbins = 16;          % number of bins to quantize gradient angles
            nfeats = 4 * nbins;  % feature length
        case 'matlab'
            opts = {'CellSize',[10 10], 'BlockSize',[2 2], ...
                'NumBins',9, 'UseSignedOrientation',true};
            nfeats = numel(extractHOGFeatures(imgs{1}, opts{:}));
        case 'opencv'
            % create HOG object
            opts = {'WinSize',[20 20], 'BlockSize',[10 10], ...
                'BlockStride',[5 5], 'CellSize',[10 10], ...
                'NBins',9, 'SignedGradient',true};
            %opts = [opts, 'GammaCorrection',false];
            hog = cv.HOGDescriptor(opts{:});
            nfeats = numel(hog.compute(imgs{1}));
            display(hog)
    end
    descs = zeros(numel(imgs), nfeats, 'single');

    %%
    % Process images and compute HOG descriptors for each
    tic
    disp('Extracting...')
    for i=1:numel(imgs)
        % deskew image
        img = deskew(imgs{i});
        %img = cv.threshold(img, 'Otsu');

        % compute HOG descriptors flattened as a vector
        switch HOG_ALG
            case 'custom'
                descs(i,:) = my_hog(img, nbins);
            case 'matlab'
                descs(i,:) = extractHOGFeatures(img, opts{:});
            case 'opencv'
                d = hog.compute(img).'; % returns a matrix, one row per window
                descs(i,:) = d(:);
        end
    end
    toc

    %% Classification
    % Create multi-class linear SVM classifier
    svm = cv.SVM();
    svm.Type = 'C_SVC';
    svm.KernelType = 'Linear';
    svm.C = 0.5;  % or do a trainAuto grid search to find optimal C
    display(svm)

    %%
    % split data samples and corresponding labels
    labels = int32(labels(:));
    N = 2500;  % fix(numel(labels)/2)
    whos descs labels
    if ~mexopencv.isOctave() && mexopencv.require('stats')
        % train/test split
        tabulate(labels(1:N))
        tabulate(labels(N+1:end))
    end

    %%
    % use half as training data
    tic
    disp('Training...')
    svm.train(descs(1:N,:), labels(1:N));
    toc

    %%
    % the other half for testing
    tic
    disp('Testing...')
    yhat = svm.predict(descs(N+1:end,:));
    toc
    %TODO: https://savannah.gnu.org/bugs/?50716

    %%
    % performance on test set
    acc = nnz(yhat == labels(N+1:end));
    confmat = accumarray([labels(N+1:end), yhat]+1, 1);
    display(confmat)
    fprintf('Accuracy = %f%%\n', (acc/N)*100);

    %%
    % Show some of the wrong predictions
    idx = (yhat ~= labels(N+1:end));
    fprintf('Number of wrong predictions = %d / %d\n', nnz(idx), N);
    figure
    idx = find(idx, 3*3, 'first');
    for i=1:numel(idx)
        ii = idx(i);
        subplot(3,3,i), imshow(imgs{ii+N})
        title(sprintf('%d \\rightarrow %d', labels(ii+N), yhat(ii)))
    end
end

%% Helper functions

function [imgs, labels, img] = load_mnist_digits()
    % Load MNIST handwritten digits, one big image
    fname = fullfile(mexopencv.root(), 'test', 'digits.png');
    if exist(fname, 'file') ~= 2
        disp('Downloading image...')
        url = 'https://cdn.rawgit.com/opencv/opencv/3.2.0/samples/data/digits.png';
        urlwrite(url, fname);
    end
    img = cv.imread(fname, 'Grayscale',true);

    % split it into 5000 small images (500 from each 0:9 digits),
    % each image is 20x20 pixels
    [h,w] = size(img);
    imgs = mat2cell(img, ones(1,50)*h/50, ones(1,100)*w/100);
    imgs = reshape(imgs', 500, [])';  % cell array of size 10x500
    labels = repmat((0:9)', 1, 500);  % each row is one digit
end

function img = deskew(img)
    % deskew image using its second order moments
    sz = 20;
    m = cv.moments(img);
    if abs(m.mu02) > 0.2  % 0.01
        skew = m.mu11 / m.mu02;
        M = [1 skew -0.5*sz*skew; 0 1 0];
        img = cv.warpAffine(img, M, 'DSize',[sz sz], 'WarpInverse',true);
    end
end

function histo = my_hog(img, nbins)
    % this is a simplified implementation of HoG descriptors
    % (fixed 10x10 cells, 1 block, no overlapping, no block normalization)

    % number of orientation histogram bins
    if nargin < 2, nbins = 16; end

    % compute image gradient (its magnitude and direction)
    gx = cv.Sobel(img, 'DDepth','single', 'XOrder',1, 'YOrder',0);
    gy = cv.Sobel(img, 'DDepth','single', 'XOrder',0, 'YOrder',1);
    mag = hypot(gx, gy);
    ang = atan2(gy, gx) + pi;  % directions in [0,2*pi] (signed gradient)

    % quantize directions into 16 bins
    bins = fix((nbins-1) * ang/(2*pi)) + 1; % bin indices in [1,16] inclusive

    % divide 20x20 image into 4 10x10 cells, and in each,
    % accumulate gradient magnitudes inside each direction bin
    % (binned orientations each weighted by its magnitude contribution)
    bb = mat2cell(bins, [10 10], [10 10]);
    mm = mat2cell(mag, [10 10], [10 10]);
    histo = cell(size(bb));
    for i=1:numel(bb)
        H = accumarray(bb{i}(:), mm{i}(:), [nbins 1]);
        if false && any(H)
            % transform histogram to space with Hellinger metric
            H = sqrt(H ./ sum(H));
            H = H ./ norm(H);
        end
        histo{i} = H;
    end

    % stack features from cells into one tall vector of length 4*16
    histo = cat(1, histo{:});
end

##### SOURCE END #####
-->
   </body>
</html>