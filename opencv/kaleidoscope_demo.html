<!DOCTYPE html>
<html>
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   
      <!--This HTML was auto-generated from published MATLAB code.-->
      <title>kaleidoscope_demo</title>
      <meta name="generator" content="MATLAB 9.2">
      <link rel="schema.DC" href="http://purl.org/dc/elements/1.1/">
      <meta name="DC.date" content="2018-02-20">
      <meta name="DC.source" content="kaleidoscope_demo.m">
      <link rel="stylesheet" type="text/css" href="publish_custom.css">
   </head>
   <body>
      <div class="content">
         <h2 id="toc">Contents</h2>
         <div>
            <ul>
               <li><a href="#1">Kaleidoscopic Reflections</a></li>
               <li><a href="#2">Kaleidoscope functions</a></li>
               <li><a href="#3">Helper functions</a></li>
            </ul>
         </div>
         <h2 id="1">Kaleidoscopic Reflections</h2>
         <p>Inspired by: <a href="https://www.csh.rit.edu/~pat/hack/quickies/kaleid/">https://www.csh.rit.edu/~pat/hack/quickies/kaleid/</a></p><pre class="codeinput"><span class="keyword">function</span> kaleidoscope_demo(k, iters, doImg)
    <span class="comment">% kaleidoscope options</span>
    <span class="keyword">if</span> nargin &lt; 1, k = 4; <span class="keyword">end</span>      <span class="comment">% n-folds (n=4*k)</span>
    <span class="keyword">if</span> nargin &lt; 2, iters = 1; <span class="keyword">end</span>  <span class="comment">% recursive level: 1, 2, ..</span>
    <span class="keyword">if</span> nargin &lt; 3, doImg = true; <span class="keyword">end</span>
    validateattributes(k, {<span class="string">'numeric'</span>}, {<span class="string">'scalar'</span>, <span class="string">'integer'</span>, <span class="string">'&gt;='</span>,1, <span class="string">'&lt;='</span>,4}, 1);
    validateattributes(iters, {<span class="string">'numeric'</span>}, {<span class="string">'scalar'</span>, <span class="string">'integer'</span>, <span class="string">'positive'</span>}, 2);
    validateattributes(doImg, {<span class="string">'numeric'</span>, <span class="string">'logical'</span>}, {<span class="string">'scalar'</span>, <span class="string">'binary'</span>}, 3);
    kaleidoscope = @(img) kaleidoscope_wrapper(img, k, iters);

    <span class="comment">% run demo</span>
    <span class="keyword">if</span> doImg
        <span class="comment">%img = imread(which('peppers.png'));</span>
        <span class="comment">%img = imread(fullfile(mexopencv.root(),'test','lena.jpg'));</span>
        img = imread(fullfile(mexopencv.root(),<span class="string">'test'</span>,<span class="string">'fruits.jpg'</span>));
        demo_image(kaleidoscope, img);
    <span class="keyword">else</span>
        cap = cv.VideoCapture(0);
        assert(cap.isOpened());
        demo_video(kaleidoscope, cap);
        cap.release();
    <span class="keyword">end</span>
<span class="keyword">end</span>

<span class="keyword">function</span> demo_image(kaleidoscope, img)
    <span class="comment">% input image must be square-sized</span>
    sz = 400;
    img = cv.resize(img, [sz sz]);

    <span class="comment">% animation by repeating a number of times</span>
    hImg = imshow(img);
    <span class="keyword">for</span> i=1:81  <span class="comment">% sz/(10/2)+1</span>
        <span class="comment">% each time offset the input image with wrap-around padding</span>
        of = (i-1)*10;
        <span class="keyword">if</span> true
            im = cv.copyMakeBorder(img, [of 0 0 of], <span class="string">'BorderType'</span>,<span class="string">'Reflect101'</span>);
            im = im(1:end-of,of+1:end,:);
        <span class="keyword">else</span>
            im = circshift(img, [of -of]);
        <span class="keyword">end</span>

        <span class="comment">% show kaleidoscope effect</span>
        out = kaleidoscope(im);
        set(hImg, <span class="string">'CData'</span>,out)
        drawnow
    <span class="keyword">end</span>
<span class="keyword">end</span>

<span class="keyword">function</span> demo_video(kaleidoscope, cap)
    <span class="comment">% video stream</span>
    sz = 400;
    img = cap.read();
    assert(~isempty(img));
    img = cv.resize(img, [sz sz]);

    hImg = imshow(img);
    <span class="keyword">while</span> ishghandle(hImg)
        <span class="comment">% grab new frame</span>
        img = cap.read();
        <span class="keyword">if</span> isempty(img), <span class="keyword">break</span>; <span class="keyword">end</span>
        img = cv.resize(img, [sz sz]);

        <span class="comment">% show kaleidoscope effect</span>
        out = kaleidoscope(img);
        set(hImg, <span class="string">'CData'</span>,out)
        drawnow
    <span class="keyword">end</span>
<span class="keyword">end</span></pre><h2 id="2">Kaleidoscope functions</h2><pre class="codeinput"><span class="keyword">function</span> out = kaleidoscope_4folds(img, flag)
    <span class="comment">% take full image (pattern fills a square)</span>
    out = img;

    <span class="comment">% tile (mirror and repeat) this pattern 4 times to get 4-fold symmetry</span>
    <span class="keyword">if</span> nargin &lt; 2 || flag, out = cv.rotate(out, <span class="string">'180'</span>); <span class="keyword">end</span>
    out = image_tile(out);
<span class="keyword">end</span>

<span class="keyword">function</span> out = kaleidoscope_8folds(img, flag)
    <span class="comment">% extract wedge (divide square into 2 folds, take top one)</span>
    sz = size(img, 1);  <span class="comment">% assumes a square image</span>
    <span class="keyword">if</span> true
        mask = zeros(sz, <span class="string">'uint8'</span>);
        mask = cv.fillConvexPoly(mask, [0 0; sz sz; sz 0], <span class="string">'Color'</span>,255);
    <span class="keyword">else</span>
        mask = triu(ones(sz, <span class="string">'uint8'</span>) * 255);
    <span class="keyword">end</span>
    q1 = image_crop(img, mask);

    <span class="comment">% create other wedge (transpose and h-flip)</span>
    q2 = cv.flip(cv.rotate(q1, <span class="string">'90CW'</span>), 1);

    <span class="comment">% merge the two wedges (pattern fills a square)</span>
    out = image_merge(q1, q2);

    <span class="comment">% tile (mirror and repeat) this pattern 4 times to get 8-fold symmetry</span>
    <span class="keyword">if</span> nargin &lt; 2 || flag, out = cv.rotate(out, <span class="string">'180'</span>); <span class="keyword">end</span>
    out = image_tile(out);
<span class="keyword">end</span>

<span class="keyword">function</span> out = kaleidoscope_12folds(img, flag)
    <span class="comment">% extract wedge (divide square into 3 folds, take middle one)</span>
    sz = size(img, 1);  <span class="comment">% assumes a square image</span>
    s = round(sz * tand(30));
    mask = zeros(sz, <span class="string">'uint8'</span>);
    mask = cv.fillConvexPoly(mask, [0 0; s sz; sz sz; sz s], <span class="string">'Color'</span>,255);
    q1 = image_crop(img, mask);

    <span class="comment">% create other two wedges (transpose, h-flip, and rotate +/- 30 degrees)</span>
    q = cv.flip(cv.rotate(q1, <span class="string">'90CW'</span>), 1);
    q2 = image_rotate(q, -30);
    q3 = image_rotate(q, +30);

    <span class="comment">% merge the three wedges (pattern fills a square)</span>
    out = image_merge(image_merge(q1, q2), q3);

    <span class="comment">% tile (mirror and repeat) this pattern 4 times to get 12-fold symmetry</span>
    <span class="keyword">if</span> nargin &lt; 2 || flag, out = cv.rotate(out, <span class="string">'180'</span>); <span class="keyword">end</span>
    out = image_tile(out);
<span class="keyword">end</span>

<span class="keyword">function</span> out = kaleidoscope_16folds(img, flag)
    <span class="comment">% extract wedge (divide square into 4 folds, take middle-top one)</span>
    sz = size(img, 1);  <span class="comment">% assumes a square image</span>
    s = round(sz * tand(22.5));
    mask = zeros(sz, <span class="string">'uint8'</span>);
    mask = cv.fillConvexPoly(mask, [0 0; sz sz; sz s], <span class="string">'Color'</span>,255);
    q1 = image_crop(img, mask);

    <span class="comment">% create bottom wedge (rotate 45 degrees), and merge</span>
    q2 = image_rotate(q1, -45);
    q12 = image_merge(q1, q2);

    <span class="comment">% create other two wedges (transpose and h-flip), and merge</span>
    q34 = cv.flip(cv.rotate(q12, <span class="string">'90CW'</span>), 1);
    out = image_merge(q12, q34);

    <span class="comment">% tile (mirror and repeat) this pattern 4 times to get 16-fold symmetry</span>
    <span class="keyword">if</span> nargin &lt; 2 || flag, out = cv.rotate(out, <span class="string">'180'</span>); <span class="keyword">end</span>
    out = image_tile(out);
<span class="keyword">end</span></pre><h2 id="3">Helper functions</h2><pre class="codeinput"><span class="keyword">function</span> out = kaleidoscope_wrapper(img, k, iters)
    <span class="keyword">switch</span> k
        <span class="keyword">case</span> 1
            kaleidoscope_nfolds = @kaleidoscope_4folds;
        <span class="keyword">case</span> 2
            kaleidoscope_nfolds = @kaleidoscope_8folds;
        <span class="keyword">case</span> 3
            kaleidoscope_nfolds = @kaleidoscope_12folds;
        <span class="keyword">case</span> 4
            kaleidoscope_nfolds = @kaleidoscope_16folds;
    <span class="keyword">end</span>

    <span class="comment">% build kaleidoscope</span>
    out = kaleidoscope_nfolds(img);
    <span class="keyword">for</span> n=2:iters
        <span class="comment">% apply recursively for more fun</span>
        out = kaleidoscope_nfolds(out, false);
    <span class="keyword">end</span>
<span class="keyword">end</span>

<span class="keyword">function</span> out = image_crop(img, mask)
    <span class="keyword">if</span> true
        out = cv.copyTo(img, <span class="string">'Mask'</span>,mask);
    <span class="keyword">elseif</span> true
        out = cv.bitwise_and(img, uint8(255), <span class="string">'Mask'</span>,mask);
    <span class="keyword">else</span>
        out = bsxfun(@times, img, uint8(mask~=0));
    <span class="keyword">end</span>
<span class="keyword">end</span>

<span class="keyword">function</span> out = image_rotate(img, angl)
    T = cv.getRotationMatrix2D([0 0], angl, 1);
    out = cv.warpAffine(img, T);
<span class="keyword">end</span>

<span class="keyword">function</span> out = image_merge(img1, img2)
    <span class="keyword">if</span> true
        out = cv.bitwise_or(img1, img2);
    <span class="keyword">elseif</span> true
        out = cv.addWeighted(img1,1, img2,1, 0);
    <span class="keyword">else</span>
        out = img1 + img2;
    <span class="keyword">end</span>
<span class="keyword">end</span>

<span class="keyword">function</span> out = image_tile(img)
    <span class="comment">% downsample first so that output has same size as input</span>
    out = cv.resize(img, 0.5, 0.5, <span class="string">'Interpolation'</span>,<span class="string">'Area'</span>);
    out = [out, cv.flip(out, 1)];
    out = [out; cv.flip(out, 0)];
<span class="keyword">end</span></pre><img src="kaleidoscope_demo_01.png"><div class="footer">
            <p><a href="https://www.mathworks.com/products/matlab.html">Published with MATLAB&reg; R2017a</a></p>
         </div>
      </div>
      <!--
##### SOURCE BEGIN #####
%% Kaleidoscopic Reflections
%
% Inspired by:
% <https://www.csh.rit.edu/~pat/hack/quickies/kaleid/>
%

function kaleidoscope_demo(k, iters, doImg)
    % kaleidoscope options
    if nargin < 1, k = 4; end      % n-folds (n=4*k)
    if nargin < 2, iters = 1; end  % recursive level: 1, 2, ..
    if nargin < 3, doImg = true; end
    validateattributes(k, {'numeric'}, {'scalar', 'integer', '>=',1, '<=',4}, 1);
    validateattributes(iters, {'numeric'}, {'scalar', 'integer', 'positive'}, 2);
    validateattributes(doImg, {'numeric', 'logical'}, {'scalar', 'binary'}, 3);
    kaleidoscope = @(img) kaleidoscope_wrapper(img, k, iters);

    % run demo
    if doImg
        %img = imread(which('peppers.png'));
        %img = imread(fullfile(mexopencv.root(),'test','lena.jpg'));
        img = imread(fullfile(mexopencv.root(),'test','fruits.jpg'));
        demo_image(kaleidoscope, img);
    else
        cap = cv.VideoCapture(0);
        assert(cap.isOpened());
        demo_video(kaleidoscope, cap);
        cap.release();
    end
end

function demo_image(kaleidoscope, img)
    % input image must be square-sized
    sz = 400;
    img = cv.resize(img, [sz sz]);

    % animation by repeating a number of times
    hImg = imshow(img);
    for i=1:81  % sz/(10/2)+1
        % each time offset the input image with wrap-around padding
        of = (i-1)*10;
        if true
            im = cv.copyMakeBorder(img, [of 0 0 of], 'BorderType','Reflect101');
            im = im(1:end-of,of+1:end,:);
        else
            im = circshift(img, [of -of]);
        end

        % show kaleidoscope effect
        out = kaleidoscope(im);
        set(hImg, 'CData',out)
        drawnow
    end
end

function demo_video(kaleidoscope, cap)
    % video stream
    sz = 400;
    img = cap.read();
    assert(~isempty(img));
    img = cv.resize(img, [sz sz]);

    hImg = imshow(img);
    while ishghandle(hImg)
        % grab new frame
        img = cap.read();
        if isempty(img), break; end
        img = cv.resize(img, [sz sz]);

        % show kaleidoscope effect
        out = kaleidoscope(img);
        set(hImg, 'CData',out)
        drawnow
    end
end

%% Kaleidoscope functions

function out = kaleidoscope_4folds(img, flag)
    % take full image (pattern fills a square)
    out = img;

    % tile (mirror and repeat) this pattern 4 times to get 4-fold symmetry
    if nargin < 2 || flag, out = cv.rotate(out, '180'); end
    out = image_tile(out);
end

function out = kaleidoscope_8folds(img, flag)
    % extract wedge (divide square into 2 folds, take top one)
    sz = size(img, 1);  % assumes a square image
    if true
        mask = zeros(sz, 'uint8');
        mask = cv.fillConvexPoly(mask, [0 0; sz sz; sz 0], 'Color',255);
    else
        mask = triu(ones(sz, 'uint8') * 255);
    end
    q1 = image_crop(img, mask);

    % create other wedge (transpose and h-flip)
    q2 = cv.flip(cv.rotate(q1, '90CW'), 1);

    % merge the two wedges (pattern fills a square)
    out = image_merge(q1, q2);

    % tile (mirror and repeat) this pattern 4 times to get 8-fold symmetry
    if nargin < 2 || flag, out = cv.rotate(out, '180'); end
    out = image_tile(out);
end

function out = kaleidoscope_12folds(img, flag)
    % extract wedge (divide square into 3 folds, take middle one)
    sz = size(img, 1);  % assumes a square image
    s = round(sz * tand(30));
    mask = zeros(sz, 'uint8');
    mask = cv.fillConvexPoly(mask, [0 0; s sz; sz sz; sz s], 'Color',255);
    q1 = image_crop(img, mask);

    % create other two wedges (transpose, h-flip, and rotate +/- 30 degrees)
    q = cv.flip(cv.rotate(q1, '90CW'), 1);
    q2 = image_rotate(q, -30);
    q3 = image_rotate(q, +30);

    % merge the three wedges (pattern fills a square)
    out = image_merge(image_merge(q1, q2), q3);

    % tile (mirror and repeat) this pattern 4 times to get 12-fold symmetry
    if nargin < 2 || flag, out = cv.rotate(out, '180'); end
    out = image_tile(out);
end

function out = kaleidoscope_16folds(img, flag)
    % extract wedge (divide square into 4 folds, take middle-top one)
    sz = size(img, 1);  % assumes a square image
    s = round(sz * tand(22.5));
    mask = zeros(sz, 'uint8');
    mask = cv.fillConvexPoly(mask, [0 0; sz sz; sz s], 'Color',255);
    q1 = image_crop(img, mask);

    % create bottom wedge (rotate 45 degrees), and merge
    q2 = image_rotate(q1, -45);
    q12 = image_merge(q1, q2);

    % create other two wedges (transpose and h-flip), and merge
    q34 = cv.flip(cv.rotate(q12, '90CW'), 1);
    out = image_merge(q12, q34);

    % tile (mirror and repeat) this pattern 4 times to get 16-fold symmetry
    if nargin < 2 || flag, out = cv.rotate(out, '180'); end
    out = image_tile(out);
end

%% Helper functions

function out = kaleidoscope_wrapper(img, k, iters)
    switch k
        case 1
            kaleidoscope_nfolds = @kaleidoscope_4folds;
        case 2
            kaleidoscope_nfolds = @kaleidoscope_8folds;
        case 3
            kaleidoscope_nfolds = @kaleidoscope_12folds;
        case 4
            kaleidoscope_nfolds = @kaleidoscope_16folds;
    end

    % build kaleidoscope
    out = kaleidoscope_nfolds(img);
    for n=2:iters
        % apply recursively for more fun
        out = kaleidoscope_nfolds(out, false);
    end
end

function out = image_crop(img, mask)
    if true
        out = cv.copyTo(img, 'Mask',mask);
    elseif true
        out = cv.bitwise_and(img, uint8(255), 'Mask',mask);
    else
        out = bsxfun(@times, img, uint8(mask~=0));
    end
end

function out = image_rotate(img, angl)
    T = cv.getRotationMatrix2D([0 0], angl, 1);
    out = cv.warpAffine(img, T);
end

function out = image_merge(img1, img2)
    if true
        out = cv.bitwise_or(img1, img2);
    elseif true
        out = cv.addWeighted(img1,1, img2,1, 0);
    else
        out = img1 + img2;
    end
end

function out = image_tile(img)
    % downsample first so that output has same size as input
    out = cv.resize(img, 0.5, 0.5, 'Interpolation','Area');
    out = [out, cv.flip(out, 1)];
    out = [out; cv.flip(out, 0)];
end

##### SOURCE END #####
-->
   </body>
</html>