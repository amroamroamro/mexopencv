<!DOCTYPE html>
<html>
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   
      <!--This HTML was auto-generated from published MATLAB code.-->
      <title>Histogram Calculation</title>
      <meta name="generator" content="MATLAB 9.2">
      <link rel="schema.DC" href="http://purl.org/dc/elements/1.1/">
      <meta name="DC.date" content="2017-11-27">
      <meta name="DC.source" content="histogram_calculation_demo.m">
      <link rel="stylesheet" type="text/css" href="publish_custom.css">
   </head>
   <body>
      <div class="content">
         <h1 id="1">Histogram Calculation</h1>
         <!--introduction-->
         <p>In this demo, we show how to:</p>
         <div>
            <ul>
               <li>Divide an image into its correspondent planes</li>
               <li>Calculate histograms of arrays of images by using the OpenCV function   <tt>cv.calcHist</tt></li>
            </ul>
         </div>
         <p>Sources:</p>
         <div>
            <ul>
               <li><a href="https://docs.opencv.org/3.2.0/d8/dbc/tutorial_histogram_calculation.html">https://docs.opencv.org/3.2.0/d8/dbc/tutorial_histogram_calculation.html</a></li>
               <li><a href="https://github.com/opencv/opencv/blob/3.2.0/samples/cpp/tutorial_code/Histograms_Matching/calcHist_Demo.cpp">https://github.com/opencv/opencv/blob/3.2.0/samples/cpp/tutorial_code/Histograms_Matching/calcHist_Demo.cpp</a></li>
            </ul>
         </div>
         <!--/introduction-->
         <h2 id="toc">Contents</h2>
         <div>
            <ul>
               <li><a href="#2">Theory</a></li>
               <li><a href="#3">Code</a></li>
            </ul>
         </div>
         <h2 id="2">Theory</h2>
         <p>Histograms are collected <i>counts</i> of data organized into a set of predefined <i>bins</i>. When we say <i>data</i> we are not restricting it to be intensity values. The data collected can be whatever feature you find useful to describe
            your image.
         </p>
         <p>Let's see an example. Imagine that a matrix contains information of an image (i.e. intensity in the range <img src="histogram_calculation_demo_eq06393464618449940940.png" alt="$0-255$" class="equation" width="46" height="11">):
         </p>
         <p><img src="https://docs.opencv.org/3.2.0/Histogram_Calculation_Theory_Hist0.jpg"></p>
         <p>What happens if we want to <i>count</i> this data in an organized way? Since we know that the <i>range</i> of information value for this case is 256 values, we can segment our range in subparts (called <b>bins</b>) like:
         </p>
         <p><img src="histogram_calculation_demo_eq17362623247820329195.png" alt="$$[0, 255] = { [0, 15] \cup [16, 31] \cup ....\cup [240,255] }$$" class="equation" width="265" height="15"></p>
         <p><img src="histogram_calculation_demo_eq18049143680807853953.png" alt="$$range = { bin_{1} \cup bin_{2} \cup ....\cup bin_{n = 15} }$$" class="equation" width="219" height="14"></p>
         <p>and we can keep count of the number of pixels that fall in the range of each <img src="histogram_calculation_demo_eq03853229788370535323.png" alt="$bin_{i}$" class="equation" width="23" height="13">. Applying this to the example above we get the image below (axis x represents the bins and axis y the number of pixels in
            each of them).
         </p>
         <p><img src="https://docs.opencv.org/3.2.0/Histogram_Calculation_Theory_Hist1.jpg"></p>
         <p>This was just a simple example of how an histogram works and why it is useful. An histogram can keep count not only of color
            intensities, but of whatever image features that we want to measure (i.e. gradients, directions, etc).
         </p>
         <p>Let's identify some parts of the histogram:</p>
         <div>
            <ul>
               <li><b>dims</b>: The number of parameters you want to collect data of. In our   example, <tt>dims = 1</tt> because we are only counting the intensity values of   each pixel (in a grayscale image).
               </li>
               <li><b>bins</b>: It is the number of <b>subdivisions</b> in each dim. In our example,   <tt>bins = 16</tt></li>
               <li><b>range</b>: The limits for the values to be measured. In this case:   <tt>range = [0,255]</tt></li>
            </ul>
         </div>
         <p>What if you want to count two features? In this case your resulting histogram would be a 3D plot (in which x and y would be
            <img src="histogram_calculation_demo_eq06495944430455760772.png" alt="$bin_{x}$" class="equation" width="26" height="13"> and <img src="histogram_calculation_demo_eq03843865934501610105.png" alt="$bin_{y}$" class="equation" width="25" height="15"> for each feature and z would be the number of counts for each combination of <img src="histogram_calculation_demo_eq12983337873909419337.png" alt="$(bin_{x}, bin_{y})$" class="equation" width="69" height="16">. The same would apply for more features (of course it gets trickier).
         </p>
         <p>For simple purposes, OpenCV implements the function <tt>cv.calcHist</tt>, which calculates the histogram of a set of arrays (usually images or image planes). It can operate with up to 32 dimensions.
            We will see it in the code below!
         </p>
         <h2 id="3">Code</h2>
         <p>This program:</p>
         <div>
            <ul>
               <li>Loads an image</li>
               <li>Splits the image into its R, G and B planes</li>
               <li>Calculate the Histogram of each 1-channel plane by calling the function   <tt>cv.calcHist</tt></li>
               <li>Plot the three histograms in a window</li>
            </ul>
         </div>
         <p>Load source 8-bit color image</p><pre class="codeinput">img = cv.imread(fullfile(mexopencv.root(), <span class="string">'test'</span>, <span class="string">'fruits.jpg'</span>), <span class="keyword">...</span>
    <span class="string">'Color'</span>,true, <span class="string">'ReduceScale'</span>,2);
imshow(img), title(<span class="string">'Source'</span>)</pre><img src="histogram_calculation_demo_01.png"><p>Calculate histogram over each channel, 8-bit values are between [0,255]</p><pre class="codeinput">counts = zeros(256,3);
<span class="keyword">for</span> i=1:3
    I = img(:,:,i);
    <span class="keyword">if</span> true
        <span class="comment">% intervals: [0,1), [1,2), ..., [254,255), [255,256)</span>
        counts(:,i) = cv.calcHist(I, [0 256], <span class="string">'HistSize'</span>,256, <span class="string">'Uniform'</span>,true);
    <span class="keyword">elseif</span> mexopencv.require(<span class="string">'images'</span>)
        <span class="comment">% intervals: [-0.5,0.5), [0.5,1.5), ..., [253.5,254.5), [254.5,255.5)</span>
        counts(:,i) = imhist(I, 256);
    <span class="keyword">elseif</span> ~mexopencv.isOctave()
        <span class="comment">% intervals: [0,1), [1,2), ..., [254,255), [255,256]</span>
        counts(:,i) = histcounts(double(I), 0:256);
    <span class="keyword">elseif</span> true
        <span class="comment">% intervals: [0,1), [1,2), ..., [254,255), [255,255]</span>
        counts(:,i) = histc(double(I(:)), 0:255);
    <span class="keyword">elseif</span> true
        counts(:,i) = accumarray(double(I(:))+1, 1, [256 1]);
    <span class="keyword">else</span>
        counts(:,i) = full(sparse(double(I(:))+1, 1, 1, 256, 1));
    <span class="keyword">end</span>
<span class="keyword">end</span></pre><p>Plot 1</p><pre class="codeinput">clrs = 255*eye(3);  <span class="comment">% BGR</span>
out = zeros([300 512 3],<span class="string">'uint8'</span>);
sz = size(out);
X = (1:256)' * round(sz(2) / 256);
Y = sz(1) - round(counts / max(counts(:)) * sz(1));
<span class="keyword">for</span> i=1:3
    out = cv.polylines(out, [X Y(:,i)], <span class="keyword">...</span>
        <span class="string">'Closed'</span>,false, <span class="string">'Color'</span>,clrs(i,:), <span class="string">'Thickness'</span>,2, <span class="string">'LineType'</span>,<span class="string">'AA'</span>);
<span class="keyword">end</span>
figure, imshow(out), title(<span class="string">'Histogram'</span>)</pre><img src="histogram_calculation_demo_02.png"><p>Plot 2</p><pre class="codeinput">clrs = {<span class="string">'r'</span>; <span class="string">'g'</span>; <span class="string">'b'</span>};
a = [1.0, 0.7, 0.7];
<span class="keyword">if</span> ~mexopencv.isOctave()
    <span class="comment">%HACK: Octave doesn't have histogram function yet</span>
    figure
    <span class="keyword">for</span> i=1:3
        histogram(<span class="string">'BinEdges'</span>,0:256, <span class="string">'BinCounts'</span>,counts(:,i), <span class="keyword">...</span>
            <span class="string">'FaceColor'</span>,clrs{i}, <span class="string">'EdgeColor'</span>,<span class="string">'none'</span>, <span class="string">'FaceAlpha'</span>,a(i))
        hold <span class="string">on</span>
    <span class="keyword">end</span>
    hold <span class="string">off</span>, axis([0 256 0 Inf]), grid <span class="string">on</span>
    xlabel(<span class="string">'Intensities'</span>), ylabel(<span class="string">'Counts'</span>), title(<span class="string">'Histogram'</span>)
<span class="keyword">end</span></pre><img src="histogram_calculation_demo_03.png"><p>Plot 3</p><pre class="codeinput">figure
hh = plot(0:255, counts); hold <span class="string">on</span>
<span class="keyword">for</span> i=1:3
    h = bar(0:255, counts(:,i), <span class="string">'histc'</span>);
    <span class="keyword">if</span> mexopencv.isOctave()
        <span class="comment">%HACK: Octave returns hggroup containing the patch object</span>
        h = get(h, <span class="string">'Children'</span>);
    <span class="keyword">end</span>
    <span class="comment">%NOTE: FaceAlpha in Octave causes patch to become fully transparent</span>
    set(h, <span class="string">'EdgeColor'</span>,<span class="string">'none'</span>, <span class="string">'FaceColor'</span>,clrs{i}, <span class="string">'FaceAlpha'</span>,0.25)
    set(hh(i), <span class="string">'Color'</span>,clrs{i}, <span class="string">'LineWidth'</span>,2)
<span class="keyword">end</span>
hold <span class="string">off</span>, axis([0 255 0 Inf]), grid <span class="string">on</span>
xlabel(<span class="string">'Intensities'</span>), ylabel(<span class="string">'Counts'</span>), title(<span class="string">'Histogram'</span>)
legend(hh, upper(clrs))</pre><img src="histogram_calculation_demo_04.png"><p>Plot 4</p><pre class="codeinput">figure
<span class="keyword">for</span> i=1:3
    subplot(3,1,i)
    h = bar(0:255, counts(:,i), <span class="string">'histc'</span>);
    <span class="keyword">if</span> mexopencv.isOctave()
        <span class="comment">%HACK: Octave returns hggroup containing the patch object</span>
        h = get(h, <span class="string">'Children'</span>);
        <span class="comment">%HACK: Octave creates very dense xticks 0:255</span>
        set(gca, <span class="string">'XTick'</span>,0:50:255)
    <span class="keyword">end</span>
    <span class="keyword">if</span> true
        <span class="comment">% gradient color</span>
        clr = zeros(1,256,3);
        clr(:,:,i) = (0:255)/255;
        set(h, <span class="string">'EdgeColor'</span>,<span class="string">'none'</span>, <span class="string">'CData'</span>,clr)
    <span class="keyword">else</span>
        <span class="comment">% flat color</span>
        set(h, <span class="string">'EdgeColor'</span>,<span class="string">'none'</span>, <span class="string">'FaceColor'</span>,clrs{i})
    <span class="keyword">end</span>
    axis([0 255 0 max(counts(:))]), grid <span class="string">on</span>
    ylabel(upper(clrs{i}))
    <span class="keyword">if</span> i==1, title(<span class="string">'Histogram'</span>); <span class="keyword">end</span>
<span class="keyword">end</span>
xlabel(<span class="string">'Intensities'</span>)</pre><img src="histogram_calculation_demo_05.png"><div class="footer">
            <p><a href="https://www.mathworks.com/products/matlab.html">Published with MATLAB&reg; R2017a</a></p>
         </div>
      </div><script type="text/x-mathjax-config">
  // https://stackoverflow.com/a/14631703/97160
  MathJax.Extension.myImg2jax = {
    version: "1.0",
    PreProcess: function (element) {
      var images = element.getElementsByTagName("img");
      for (var i = images.length - 1; i >= 0; i--) {
        var img = images[i];
        if (img.className === "equation") {
          var match = img.alt.match(/^(\$\$?)([\s\S]*)\1$/m);
          if (!match) continue;
          var script = document.createElement("script");
          script.type = "math/tex";
          if (match[1] === "$$") {script.type += ";mode=display"}
          MathJax.HTML.setScript(script, match[2]);
          img.parentNode.replaceChild(script, img);
        }
      }
    }
  };
  MathJax.Hub.Register.PreProcessor(["PreProcess", MathJax.Extension.myImg2jax]);
  </script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-AMS_CHTML"></script>
      <!--
##### SOURCE BEGIN #####
%% Histogram Calculation
%
% In this demo, we show how to:
%
% * Divide an image into its correspondent planes
% * Calculate histograms of arrays of images by using the OpenCV function
%   |cv.calcHist|
%
% Sources:
%
% * <https://docs.opencv.org/3.2.0/d8/dbc/tutorial_histogram_calculation.html>
% * <https://github.com/opencv/opencv/blob/3.2.0/samples/cpp/tutorial_code/Histograms_Matching/calcHist_Demo.cpp>
%

%% Theory
%
% Histograms are collected _counts_ of data organized into a set of predefined
% _bins_. When we say _data_ we are not restricting it to be intensity values.
% The data collected can be whatever feature you find useful to describe your
% image.
%
% Let's see an example. Imagine that a matrix contains information of an image
% (i.e. intensity in the range $0-255$):
%
% <<https://docs.opencv.org/3.2.0/Histogram_Calculation_Theory_Hist0.jpg>>
%
% What happens if we want to _count_ this data in an organized way? Since we
% know that the _range_ of information value for this case is 256 values, we
% can segment our range in subparts (called *bins*) like:
%
% $$[0, 255] = { [0, 15] \cup [16, 31] \cup ....\cup [240,255] }$$
%
% $$range = { bin_{1} \cup bin_{2} \cup ....\cup bin_{n = 15} }$$
%
% and we can keep count of the number of pixels that fall in the range of each
% $bin_{i}$. Applying this to the example above we get the image below
% (axis x represents the bins and axis y the number of pixels in each of them).
%
% <<https://docs.opencv.org/3.2.0/Histogram_Calculation_Theory_Hist1.jpg>>
%
% This was just a simple example of how an histogram works and why it is
% useful. An histogram can keep count not only of color intensities, but of
% whatever image features that we want to measure (i.e. gradients, directions,
% etc).
%
% Let's identify some parts of the histogram:
%
% * *dims*: The number of parameters you want to collect data of. In our
%   example, |dims = 1| because we are only counting the intensity values of
%   each pixel (in a grayscale image).
% * *bins*: It is the number of *subdivisions* in each dim. In our example,
%   |bins = 16|
% * *range*: The limits for the values to be measured. In this case:
%   |range = [0,255]|
%
% What if you want to count two features? In this case your resulting
% histogram would be a 3D plot (in which x and y would be $bin_{x}$ and
% $bin_{y}$ for each feature and z would be the number of counts for each
% combination of $(bin_{x}, bin_{y})$. The same would apply for more features
% (of course it gets trickier).
%
% For simple purposes, OpenCV implements the function |cv.calcHist|, which
% calculates the histogram of a set of arrays (usually images or image planes).
% It can operate with up to 32 dimensions. We will see it in the code below!
%

%% Code
%
% This program:
%
% * Loads an image
% * Splits the image into its R, G and B planes
% * Calculate the Histogram of each 1-channel plane by calling the function
%   |cv.calcHist|
% * Plot the three histograms in a window
%

%%
% Load source 8-bit color image
img = cv.imread(fullfile(mexopencv.root(), 'test', 'fruits.jpg'), ...
    'Color',true, 'ReduceScale',2);
imshow(img), title('Source')

%%
% Calculate histogram over each channel, 8-bit values are between [0,255]
counts = zeros(256,3);
for i=1:3
    I = img(:,:,i);
    if true
        % intervals: [0,1), [1,2), ..., [254,255), [255,256)
        counts(:,i) = cv.calcHist(I, [0 256], 'HistSize',256, 'Uniform',true);
    elseif mexopencv.require('images')
        % intervals: [-0.5,0.5), [0.5,1.5), ..., [253.5,254.5), [254.5,255.5)
        counts(:,i) = imhist(I, 256);
    elseif ~mexopencv.isOctave()
        % intervals: [0,1), [1,2), ..., [254,255), [255,256]
        counts(:,i) = histcounts(double(I), 0:256);
    elseif true
        % intervals: [0,1), [1,2), ..., [254,255), [255,255]
        counts(:,i) = histc(double(I(:)), 0:255);
    elseif true
        counts(:,i) = accumarray(double(I(:))+1, 1, [256 1]);
    else
        counts(:,i) = full(sparse(double(I(:))+1, 1, 1, 256, 1));
    end
end

%%
% Plot 1
clrs = 255*eye(3);  % BGR
out = zeros([300 512 3],'uint8');
sz = size(out);
X = (1:256)' * round(sz(2) / 256);
Y = sz(1) - round(counts / max(counts(:)) * sz(1));
for i=1:3
    out = cv.polylines(out, [X Y(:,i)], ...
        'Closed',false, 'Color',clrs(i,:), 'Thickness',2, 'LineType','AA');
end
figure, imshow(out), title('Histogram')

%%
% Plot 2
clrs = {'r'; 'g'; 'b'};
a = [1.0, 0.7, 0.7];
if ~mexopencv.isOctave()
    %HACK: Octave doesn't have histogram function yet
    figure
    for i=1:3
        histogram('BinEdges',0:256, 'BinCounts',counts(:,i), ...
            'FaceColor',clrs{i}, 'EdgeColor','none', 'FaceAlpha',a(i))
        hold on
    end
    hold off, axis([0 256 0 Inf]), grid on
    xlabel('Intensities'), ylabel('Counts'), title('Histogram')
end

%%
% Plot 3
figure
hh = plot(0:255, counts); hold on
for i=1:3
    h = bar(0:255, counts(:,i), 'histc');
    if mexopencv.isOctave()
        %HACK: Octave returns hggroup containing the patch object
        h = get(h, 'Children');
    end
    %NOTE: FaceAlpha in Octave causes patch to become fully transparent
    set(h, 'EdgeColor','none', 'FaceColor',clrs{i}, 'FaceAlpha',0.25)
    set(hh(i), 'Color',clrs{i}, 'LineWidth',2)
end
hold off, axis([0 255 0 Inf]), grid on
xlabel('Intensities'), ylabel('Counts'), title('Histogram')
legend(hh, upper(clrs))

%%
% Plot 4
figure
for i=1:3
    subplot(3,1,i)
    h = bar(0:255, counts(:,i), 'histc');
    if mexopencv.isOctave()
        %HACK: Octave returns hggroup containing the patch object
        h = get(h, 'Children');
        %HACK: Octave creates very dense xticks 0:255
        set(gca, 'XTick',0:50:255)
    end
    if true
        % gradient color
        clr = zeros(1,256,3);
        clr(:,:,i) = (0:255)/255;
        set(h, 'EdgeColor','none', 'CData',clr)
    else
        % flat color
        set(h, 'EdgeColor','none', 'FaceColor',clrs{i})
    end
    axis([0 255 0 max(counts(:))]), grid on
    ylabel(upper(clrs{i}))
    if i==1, title('Histogram'); end
end
xlabel('Intensities')

##### SOURCE END #####
--></body>
</html>