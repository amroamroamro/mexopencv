<!DOCTYPE html>
<html>
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   
      <!--This HTML was auto-generated from published MATLAB code.-->
      <title>Image Pyramids</title>
      <meta name="generator" content="MATLAB 9.2">
      <link rel="schema.DC" href="http://purl.org/dc/elements/1.1/">
      <meta name="DC.date" content="2017-11-27">
      <meta name="DC.source" content="pyramids_demo_gui.m">
      <link rel="stylesheet" type="text/css" href="publish_custom.css">
   </head>
   <body>
      <div class="content">
         <h1 id="1">Image Pyramids</h1>
         <!--introduction-->
         <p>In this demo, we show how to use the functions <tt>cv.pyrUp</tt> and <tt>cv.pyrDown</tt> to downsample or upsample a given image.
         </p>
         <p>Sources:</p>
         <div>
            <ul>
               <li><a href="https://docs.opencv.org/3.2.0/d4/d1f/tutorial_pyramids.html">https://docs.opencv.org/3.2.0/d4/d1f/tutorial_pyramids.html</a></li>
               <li><a href="https://github.com/opencv/opencv/blob/3.2.0/samples/cpp/tutorial_code/ImgProc/Pyramids.cpp">https://github.com/opencv/opencv/blob/3.2.0/samples/cpp/tutorial_code/ImgProc/Pyramids.cpp</a></li>
            </ul>
         </div>
         <!--/introduction-->
         <h2 id="toc">Contents</h2>
         <div>
            <ul>
               <li><a href="#2">Theory</a></li>
               <li><a href="#3">Image Pyramid</a></li>
               <li><a href="#4">Gaussian Pyramid</a></li>
               <li><a href="#5">Code</a></li>
            </ul>
         </div>
         <h2 id="2">Theory</h2>
         <p>The explanation below belongs to the book <i>Learning OpenCV</i> by Bradski and Kaehler.
         </p>
         <p>Usually we need to convert an image to a size different than its original. For this, there are two possible options:</p>
         <div>
            <ol>
               <li><i>Upsize</i> the image (zoom in) or
               </li>
               <li><i>Downsize</i> it (zoom out).
               </li>
            </ol>
         </div>
         <p>Although there is a <i>geometric transformation</i> function in OpenCV that literally resize an image <tt>cv.resize</tt>, in this section we analyze first the use of <b>Image Pyramids</b>, which are widely applied in a huge range of vision applications.
         </p>
         <h2 id="3">Image Pyramid</h2>
         <p>An image pyramid is a collection of images - all arising from a single original image - that are successively downsampled
            until some desired stopping point is reached.
         </p>
         <p>There are two common kinds of image pyramids:</p>
         <div>
            <ul>
               <li><b>Gaussian pyramid:</b> Used to downsample images
               </li>
               <li><b>Laplacian pyramid:</b> Used to reconstruct an upsampled image from an image   lower in the pyramid (with less resolution)
               </li>
            </ul>
         </div>
         <p>In this tutorial we'll use the <i>Gaussian pyramid</i>.
         </p>
         <h2 id="4">Gaussian Pyramid</h2>
         <p>Imagine the pyramid as a set of layers in which the higher the layer, the smaller the size.</p>
         <p><img src="https://docs.opencv.org/3.2.0/Pyramids_Tutorial_Pyramid_Theory.png"></p>
         <p>Every layer is numbered from bottom to top, so layer <img src="pyramids_demo_gui_eq11837992631851276636.png" alt="$(i+1)$" class="equation" width="40" height="15"> (denoted as <img src="pyramids_demo_gui_eq17686092874748121281.png" alt="$G_{i+1}$" class="equation" width="27" height="14"> is smaller than layer <img src="pyramids_demo_gui_eq05671228016298599287.png" alt="$i$" class="equation" width="5" height="11"> (<img src="pyramids_demo_gui_eq02545535202119026461.png" alt="$G_{i}$" class="equation" width="15" height="13">).
         </p>
         <p>To produce layer <img src="pyramids_demo_gui_eq11837992631851276636.png" alt="$(i+1)$" class="equation" width="40" height="15"> in the Gaussian pyramid, we do the following:
         </p>
         <div>
            <ul>
               <li>Convolve <img src="pyramids_demo_gui_eq02545535202119026461.png" alt="$G_{i}$" class="equation" width="15" height="13"> with a Gaussian kernel:
               </li>
            </ul>
         </div>
         <p><img src="pyramids_demo_gui_eq07664723024023534617.png" alt="$$&#xA;\frac{1}{16} \left[\matrix{&#xA;1 &amp;  4 &amp;  6 &amp;  4 &amp; 1 \cr&#xA;4 &amp; 16 &amp; 24 &amp; 16 &amp; 4 \cr&#xA;6 &amp; 24 &amp; 36 &amp; 24 &amp; 6 \cr&#xA;4 &amp; 16 &amp; 24 &amp; 16 &amp; 4 \cr&#xA;1 &amp;  4 &amp;  6 &amp;  4 &amp; 1&#xA;}\right]&#xA;$$" class="equation" width="156" height="81"></p>
         <div>
            <ul>
               <li>Remove every even-numbered row and column.</li>
            </ul>
         </div>
         <p>You can easily notice that the resulting image will be exactly one-quarter the area of its predecessor. Iterating this process
            on the input image <img src="pyramids_demo_gui_eq04937585287152333993.png" alt="$G_{0}$" class="equation" width="16" height="13"> (original image) produces the entire pyramid.
         </p>
         <p>The procedure above was useful to downsample an image. What if we want to make it bigger? columns filled with zeros (<img src="pyramids_demo_gui_eq00202142981986870057.png" alt="$0$" class="equation" width="7" height="11">)
         </p>
         <div>
            <ul>
               <li>First, upsize the image to twice the original in each dimension, wit the   new even rows and</li>
               <li>Perform a convolution with the same kernel shown above (multiplied by 4)   to approximate the values of the "missing pixels"</li>
            </ul>
         </div>
         <p>These two procedures (downsampling and upsampling as explained above) are implemented by the OpenCV functions <tt>cv.pyrUp</tt> and <tt>cv.pyrDown</tt>, as we will see in an example with the code below.
         </p>
         <p>NOTE: When we reduce the size of an image, we are actually <i>losing</i> information of the image.
         </p>
         <h2 id="5">Code</h2><pre class="codeinput"><span class="keyword">function</span> varargout = pyramids_demo_gui(im)
    <span class="comment">% load source image</span>
    <span class="keyword">if</span> nargin &lt; 1
        src = imread(fullfile(mexopencv.root(),<span class="string">'test'</span>,<span class="string">'cat.jpg'</span>));
    <span class="keyword">elseif</span> ischar(im)
        src = imread(im);
    <span class="keyword">else</span>
        src = im;
    <span class="keyword">end</span>

    <span class="comment">% create the UI</span>
    h = buildGUI(src);
    <span class="keyword">if</span> nargout &gt; 0, varargout{1} = h; <span class="keyword">end</span>
<span class="keyword">end</span>

<span class="keyword">function</span> onType(~,e,h)
    <span class="comment">%ONTYPE  Event handler for key press on figure</span>

    <span class="comment">% handle keys</span>
    <span class="keyword">switch</span> e.Key
        <span class="keyword">case</span> <span class="string">'h'</span>
            helpdlg({
                <span class="string">'Hot keys:'</span>
                <span class="string">'h - this help dialog'</span>
                <span class="string">'q - quit the program'</span>
                <span class="string">'r - reset'</span>
                <span class="string">'u - upsample'</span>
                <span class="string">'d - downsample'</span>
                <span class="string">'p - toggle pan (wont respond to keys while on)'</span>
                <span class="string">'s - save current image'</span>
            });

        <span class="keyword">case</span> {<span class="string">'q'</span>, <span class="string">'escape'</span>}
            <span class="comment">% quit</span>
            close(h.fig);

        <span class="keyword">case</span> <span class="string">'r'</span>
            <span class="comment">% reset</span>
            displayImage(h, h.src);

        <span class="keyword">case</span> <span class="string">'u'</span>
            <span class="comment">% upsample</span>
            onChange(h.btn(1), [], h);

        <span class="keyword">case</span> <span class="string">'d'</span>
            <span class="comment">% downsample</span>
            onChange(h.btn(2), [], h);

        <span class="keyword">case</span> <span class="string">'p'</span>
            <span class="comment">% toggle panning</span>
            set(h.btn(3), <span class="string">'Value'</span>,1);
            onPan([], [], h);

        <span class="keyword">case</span> {<span class="string">'s'</span>, <span class="string">'space'</span>}
            <span class="comment">% save image</span>
            img = get(h.img, <span class="string">'CData'</span>);
            fname = fullfile(tempdir(), <span class="keyword">...</span>
                sprintf(<span class="string">'out_%s.png'</span>, datestr(now(),<span class="string">'yyyymmddTHHMMSS'</span>)));
            cv.imwrite(fname, img);
            disp([<span class="string">'Saved '</span> fname]);
    <span class="keyword">end</span>
<span class="keyword">end</span>

<span class="keyword">function</span> onPan(~,~,h)
    <span class="comment">%ONPAN  Event handler for UI controls</span>

    <span class="keyword">if</span> mexopencv.isOctave();
        <span class="comment">%HACK: pan not implemented in Octave</span>
        <span class="keyword">return</span>;
    <span class="keyword">end</span>

    <span class="comment">% toggle panning on/off</span>
    <span class="comment">% we also disable/restore keypress callback (not permitted while panning)</span>
    <span class="keyword">if</span> logical(get(h.btn(3), <span class="string">'Value'</span>))
        set(h.fig, <span class="string">'WindowKeyPressFcn'</span>,<span class="string">''</span>);
        set(h.pan, <span class="string">'Enable'</span>,<span class="string">'on'</span>);
    <span class="keyword">else</span>
        set(h.pan, <span class="string">'Enable'</span>,<span class="string">'off'</span>);
        set(h.fig, <span class="string">'WindowKeyPressFcn'</span>,{@onType,h});
    <span class="keyword">end</span>
<span class="keyword">end</span>

<span class="keyword">function</span> onChange(o,~,h)
    <span class="comment">%ONCHANGE  Event handler for UI controls</span>

    <span class="comment">% current image</span>
    img = get(h.img, <span class="string">'CData'</span>);

    <span class="comment">% perform upsampling/downsampling</span>
    sz = [size(img,2) size(img,1)];
    <span class="keyword">switch</span> o
        <span class="keyword">case</span> h.btn(1)
            img = cv.pyrUp(img, <span class="string">'DstSize'</span>,sz*2);
        <span class="keyword">case</span> h.btn(2)
            img = cv.pyrDown(img, <span class="string">'DstSize'</span>,round(sz/2));
    <span class="keyword">end</span>

    <span class="comment">% show result</span>
    displayImage(h, img);
<span class="keyword">end</span>

<span class="keyword">function</span> displayImage(h, img)
    <span class="comment">%DISPLAYIMAGE  Update image</span>

    set(h.img, <span class="string">'CData'</span>,img);
    set(h.txt, <span class="string">'String'</span>,sprintf(<span class="string">'(%dx%d)'</span>, size(img,2), size(img,1)));
    drawnow;
<span class="keyword">end</span>

<span class="keyword">function</span> h = buildGUI(img)
    <span class="comment">%BUILDGUI  Creates the UI</span>

    <span class="comment">% parameters</span>
    sz = size(img);
    sz(2) = max(sz(2), 280);  <span class="comment">% minimum figure width</span>

    <span class="comment">% build the user interface (no resizing to keep it simple)</span>
    h = struct();
    h.src = img;
    h.fig = figure(<span class="string">'Name'</span>,<span class="string">'Pyramids Demo'</span>, <span class="keyword">...</span>
        <span class="string">'NumberTitle'</span>,<span class="string">'off'</span>, <span class="string">'Menubar'</span>,<span class="string">'none'</span>, <span class="string">'Resize'</span>,<span class="string">'off'</span>, <span class="keyword">...</span>
        <span class="string">'Position'</span>,[200 200 sz(2) sz(1)+29]);
    <span class="keyword">if</span> ~mexopencv.isOctave()
        <span class="comment">%HACK: not implemented in Octave</span>
        movegui(h.fig, <span class="string">'center'</span>);
    <span class="keyword">end</span>
    h.ax = axes(<span class="string">'Parent'</span>,h.fig, <span class="string">'Units'</span>,<span class="string">'pixels'</span>, <span class="string">'Position'</span>,[1 30 sz(2) sz(1)]);
    <span class="keyword">if</span> ~mexopencv.isOctave()
        h.img = imshow(img, <span class="string">'Parent'</span>,h.ax);
    <span class="keyword">else</span>
        <span class="comment">%HACK: https://savannah.gnu.org/bugs/index.php?45473</span>
        axes(h.ax);
        h.img = imshow(img);
    <span class="keyword">end</span>
    h.btn(1) = uicontrol(<span class="string">'Parent'</span>,h.fig, <span class="string">'Style'</span>,<span class="string">'pushbutton'</span>, <span class="keyword">...</span>
        <span class="string">'Position'</span>,[5 5 60 20], <span class="string">'String'</span>,<span class="string">'Up'</span>);
    h.btn(2) = uicontrol(<span class="string">'Parent'</span>,h.fig, <span class="string">'Style'</span>,<span class="string">'pushbutton'</span>, <span class="keyword">...</span>
        <span class="string">'Position'</span>,[70 5 60 20], <span class="string">'String'</span>,<span class="string">'Down'</span>);
    h.btn(3) = uicontrol(<span class="string">'Parent'</span>,h.fig, <span class="string">'Style'</span>,<span class="string">'togglebutton'</span>, <span class="keyword">...</span>
        <span class="string">'Position'</span>,[135 5 60 20], <span class="string">'String'</span>,<span class="string">'Pan'</span>);
    h.txt = uicontrol(<span class="string">'Parent'</span>,h.fig, <span class="string">'Style'</span>,<span class="string">'text'</span>, <span class="string">'FontSize'</span>,8, <span class="keyword">...</span>
        <span class="string">'Position'</span>,[200 5 80 20], <span class="string">'HorizontalAlignment'</span>,<span class="string">'Left'</span>, <span class="keyword">...</span>
        <span class="string">'String'</span>,sprintf(<span class="string">'(%dx%d)'</span>, size(img,2), size(img,1)));
    <span class="keyword">if</span> ~mexopencv.isOctave();
        <span class="comment">%HACK: pan not implemented in Octave</span>
        h.pan = pan(h.fig);
    <span class="keyword">end</span>

    <span class="comment">% hook event handlers</span>
    opts = {<span class="string">'Interruptible'</span>,<span class="string">'off'</span>, <span class="string">'BusyAction'</span>,<span class="string">'cancel'</span>};
    set(h.fig, <span class="string">'WindowKeyPressFcn'</span>,{@onType,h}, opts{:});
    set(h.btn(1:2), <span class="string">'Callback'</span>,{@onChange,h}, opts{:});
    set(h.btn(3), <span class="string">'Callback'</span>,{@onPan,h}, opts{:})
<span class="keyword">end</span></pre><img src="pyramids_demo_gui_01.png"><div class="footer">
            <p><a href="https://www.mathworks.com/products/matlab.html">Published with MATLAB&reg; R2017a</a></p>
         </div>
      </div><script type="text/x-mathjax-config">
  // https://stackoverflow.com/a/14631703/97160
  MathJax.Extension.myImg2jax = {
    version: "1.0",
    PreProcess: function (element) {
      var images = element.getElementsByTagName("img");
      for (var i = images.length - 1; i >= 0; i--) {
        var img = images[i];
        if (img.className === "equation") {
          var match = img.alt.match(/^(\$\$?)([\s\S]*)\1$/m);
          if (!match) continue;
          var script = document.createElement("script");
          script.type = "math/tex";
          if (match[1] === "$$") {script.type += ";mode=display"}
          MathJax.HTML.setScript(script, match[2]);
          img.parentNode.replaceChild(script, img);
        }
      }
    }
  };
  MathJax.Hub.Register.PreProcessor(["PreProcess", MathJax.Extension.myImg2jax]);
  </script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-AMS_CHTML"></script>
      <!--
##### SOURCE BEGIN #####
%% Image Pyramids
%
% In this demo, we show how to use the functions |cv.pyrUp| and |cv.pyrDown|
% to downsample or upsample a given image.
%
% Sources:
%
% * <https://docs.opencv.org/3.2.0/d4/d1f/tutorial_pyramids.html>
% * <https://github.com/opencv/opencv/blob/3.2.0/samples/cpp/tutorial_code/ImgProc/Pyramids.cpp>
%

%% Theory
%
% The explanation below belongs to the book _Learning OpenCV_ by
% Bradski and Kaehler.
%
% Usually we need to convert an image to a size different than its original.
% For this, there are two possible options:
%
% # _Upsize_ the image (zoom in) or
% # _Downsize_ it (zoom out).
%
% Although there is a _geometric transformation_ function in OpenCV that
% literally resize an image |cv.resize|, in this section we analyze first the
% use of *Image Pyramids*, which are widely applied in a huge range of vision
% applications.
%

%% Image Pyramid
%
% An image pyramid is a collection of images - all arising from a single
% original image - that are successively downsampled until some desired
% stopping point is reached.
%
% There are two common kinds of image pyramids:
%
% * *Gaussian pyramid:* Used to downsample images
% * *Laplacian pyramid:* Used to reconstruct an upsampled image from an image
%   lower in the pyramid (with less resolution)
%
% In this tutorial we'll use the _Gaussian pyramid_.
%

%% Gaussian Pyramid
%
% Imagine the pyramid as a set of layers in which the higher the layer, the
% smaller the size.
%
% <<https://docs.opencv.org/3.2.0/Pyramids_Tutorial_Pyramid_Theory.png>>
%
% Every layer is numbered from bottom to top, so layer $(i+1)$ (denoted as
% $G_{i+1}$ is smaller than layer $i$ ($G_{i}$).
%
% To produce layer $(i+1)$ in the Gaussian pyramid, we do the following:
%
% * Convolve $G_{i}$ with a Gaussian kernel:
%
% $$
% \frac{1}{16} \left[\matrix{
% 1 &  4 &  6 &  4 & 1 \cr
% 4 & 16 & 24 & 16 & 4 \cr
% 6 & 24 & 36 & 24 & 6 \cr
% 4 & 16 & 24 & 16 & 4 \cr
% 1 &  4 &  6 &  4 & 1
% }\right]
% $$
%
% * Remove every even-numbered row and column.
%
% You can easily notice that the resulting image will be exactly one-quarter
% the area of its predecessor. Iterating this process on the input image
% $G_{0}$ (original image) produces the entire pyramid.
%
% The procedure above was useful to downsample an image. What if we want to
% make it bigger? columns filled with zeros ($0$)
%
% * First, upsize the image to twice the original in each dimension, wit the
%   new even rows and
% * Perform a convolution with the same kernel shown above (multiplied by 4)
%   to approximate the values of the "missing pixels"
%
% These two procedures (downsampling and upsampling as explained above) are
% implemented by the OpenCV functions |cv.pyrUp| and |cv.pyrDown|, as we will
% see in an example with the code below.
%
% NOTE: When we reduce the size of an image, we are actually _losing_
% information of the image.
%

%% Code

function varargout = pyramids_demo_gui(im)
    % load source image
    if nargin < 1
        src = imread(fullfile(mexopencv.root(),'test','cat.jpg'));
    elseif ischar(im)
        src = imread(im);
    else
        src = im;
    end

    % create the UI
    h = buildGUI(src);
    if nargout > 0, varargout{1} = h; end
end

function onType(~,e,h)
    %ONTYPE  Event handler for key press on figure

    % handle keys
    switch e.Key
        case 'h'
            helpdlg({
                'Hot keys:'
                'h - this help dialog'
                'q - quit the program'
                'r - reset'
                'u - upsample'
                'd - downsample'
                'p - toggle pan (wont respond to keys while on)'
                's - save current image'
            });

        case {'q', 'escape'}
            % quit
            close(h.fig);

        case 'r'
            % reset
            displayImage(h, h.src);

        case 'u'
            % upsample
            onChange(h.btn(1), [], h);

        case 'd'
            % downsample
            onChange(h.btn(2), [], h);

        case 'p'
            % toggle panning
            set(h.btn(3), 'Value',1);
            onPan([], [], h);

        case {'s', 'space'}
            % save image
            img = get(h.img, 'CData');
            fname = fullfile(tempdir(), ...
                sprintf('out_%s.png', datestr(now(),'yyyymmddTHHMMSS')));
            cv.imwrite(fname, img);
            disp(['Saved ' fname]);
    end
end

function onPan(~,~,h)
    %ONPAN  Event handler for UI controls

    if mexopencv.isOctave();
        %HACK: pan not implemented in Octave
        return;
    end

    % toggle panning on/off
    % we also disable/restore keypress callback (not permitted while panning)
    if logical(get(h.btn(3), 'Value'))
        set(h.fig, 'WindowKeyPressFcn','');
        set(h.pan, 'Enable','on');
    else
        set(h.pan, 'Enable','off');
        set(h.fig, 'WindowKeyPressFcn',{@onType,h});
    end
end

function onChange(o,~,h)
    %ONCHANGE  Event handler for UI controls

    % current image
    img = get(h.img, 'CData');

    % perform upsampling/downsampling
    sz = [size(img,2) size(img,1)];
    switch o
        case h.btn(1)
            img = cv.pyrUp(img, 'DstSize',sz*2);
        case h.btn(2)
            img = cv.pyrDown(img, 'DstSize',round(sz/2));
    end

    % show result
    displayImage(h, img);
end

function displayImage(h, img)
    %DISPLAYIMAGE  Update image

    set(h.img, 'CData',img);
    set(h.txt, 'String',sprintf('(%dx%d)', size(img,2), size(img,1)));
    drawnow;
end

function h = buildGUI(img)
    %BUILDGUI  Creates the UI

    % parameters
    sz = size(img);
    sz(2) = max(sz(2), 280);  % minimum figure width

    % build the user interface (no resizing to keep it simple)
    h = struct();
    h.src = img;
    h.fig = figure('Name','Pyramids Demo', ...
        'NumberTitle','off', 'Menubar','none', 'Resize','off', ...
        'Position',[200 200 sz(2) sz(1)+29]);
    if ~mexopencv.isOctave()
        %HACK: not implemented in Octave
        movegui(h.fig, 'center');
    end
    h.ax = axes('Parent',h.fig, 'Units','pixels', 'Position',[1 30 sz(2) sz(1)]);
    if ~mexopencv.isOctave()
        h.img = imshow(img, 'Parent',h.ax);
    else
        %HACK: https://savannah.gnu.org/bugs/index.php?45473
        axes(h.ax);
        h.img = imshow(img);
    end
    h.btn(1) = uicontrol('Parent',h.fig, 'Style','pushbutton', ...
        'Position',[5 5 60 20], 'String','Up');
    h.btn(2) = uicontrol('Parent',h.fig, 'Style','pushbutton', ...
        'Position',[70 5 60 20], 'String','Down');
    h.btn(3) = uicontrol('Parent',h.fig, 'Style','togglebutton', ...
        'Position',[135 5 60 20], 'String','Pan');
    h.txt = uicontrol('Parent',h.fig, 'Style','text', 'FontSize',8, ...
        'Position',[200 5 80 20], 'HorizontalAlignment','Left', ...
        'String',sprintf('(%dx%d)', size(img,2), size(img,1)));
    if ~mexopencv.isOctave();
        %HACK: pan not implemented in Octave
        h.pan = pan(h.fig);
    end

    % hook event handlers
    opts = {'Interruptible','off', 'BusyAction','cancel'};
    set(h.fig, 'WindowKeyPressFcn',{@onType,h}, opts{:});
    set(h.btn(1:2), 'Callback',{@onChange,h}, opts{:});
    set(h.btn(3), 'Callback',{@onPan,h}, opts{:})
end

##### SOURCE END #####
--></body>
</html>