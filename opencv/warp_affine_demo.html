<!DOCTYPE html>
<html>
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   
      <!--This HTML was auto-generated from published MATLAB code.-->
      <title>Image Affine Transformation</title>
      <meta name="generator" content="MATLAB 9.2">
      <link rel="schema.DC" href="http://purl.org/dc/elements/1.1/">
      <meta name="DC.date" content="2017-11-27">
      <meta name="DC.source" content="warp_affine_demo.m">
      <link rel="stylesheet" type="text/css" href="publish_custom.css">
   </head>
   <body>
      <div class="content">
         <h1 id="1">Image Affine Transformation</h1>
         <!--introduction-->
         <p>In this demo, we show how to:</p>
         <div>
            <ul>
               <li>Use the OpenCV function <tt>cv.warpAffine</tt> to implement simple remapping   routines
               </li>
               <li>Use the OpenCV function <tt>cv.getRotationMatrix2D</tt> to obtain a 2x3 rotation   matrix
               </li>
            </ul>
         </div>
         <p>Sources:</p>
         <div>
            <ul>
               <li><a href="https://docs.opencv.org/3.2.0/d4/d61/tutorial_warp_affine.html">https://docs.opencv.org/3.2.0/d4/d61/tutorial_warp_affine.html</a></li>
               <li><a href="https://github.com/opencv/opencv/blob/3.2.0/samples/cpp/tutorial_code/ImgTrans/Geometric_Transforms_Demo.cpp">https://github.com/opencv/opencv/blob/3.2.0/samples/cpp/tutorial_code/ImgTrans/Geometric_Transforms_Demo.cpp</a></li>
            </ul>
         </div>
         <!--/introduction-->
         <h2 id="toc">Contents</h2>
         <div>
            <ul>
               <li><a href="#2">Theory</a></li>
               <li><a href="#3">Code</a></li>
            </ul>
         </div>
         <h2 id="2">Theory</h2>
         <p>An affine transformation is any transformation that can be expressed in the form of a <i>matrix multiplication</i> (linear transformation) followed by a <i>vector addition</i> (translation).
         </p>
         <p>From the above, we can use an affine transformation to express:</p>
         <div>
            <ul>
               <li>Rotations (linear transformation)</li>
               <li>Translations (vector addition)</li>
               <li>Scale operations (linear transformation)</li>
            </ul>
         </div>
         <p>you can see that, in essence, an affine transformation represents a <b>relation</b> between two images.
         </p>
         <p>The usual way to represent an affine transformation is by using a 2x3 matrix.</p>
         <p><img src="warp_affine_demo_eq12006825387709476050.png" alt="$$&#xA;A = \left[{\matrix{&#xA;        a_{00} &amp; a_{01} \cr&#xA;        a_{10} &amp; a_{11}&#xA;    }}\right]_{2 \times 2}&#xA;\qquad&#xA;B = \left[{\matrix{&#xA;        b_{00} \cr&#xA;        b_{10}&#xA;    }}\right]_{2 \times 1}&#xA;$$" class="equation" width="240" height="36"></p>
         <p><img src="warp_affine_demo_eq17067236906527809275.png" alt="$$&#xA;M = \left[{\matrix{&#xA;    A &amp; B&#xA;    }}\right]&#xA;=&#xA;\left[{\matrix{&#xA;    a_{00} &amp; a_{01} &amp; b_{00} \cr&#xA;    a_{10} &amp; a_{11} &amp; b_{10}&#xA;}}\right]_{2 \times 3}&#xA;$$" class="equation" width="228" height="37"></p>
         <p>Considering that we want to transform a 2D vector <img src="warp_affine_demo_eq09367769471301509636.png" alt="$X = \left[{\matrix{x \cr y}}\right]$" class="equation" width="59" height="36"> by using <img src="warp_affine_demo_eq05147331747641807187.png" alt="$A$" class="equation" width="10" height="11"> and <img src="warp_affine_demo_eq10170753361147586657.png" alt="$B$" class="equation" width="11" height="10">, we can do the same with:
         </p>
         <p><img src="warp_affine_demo_eq14849972587852083174.png" alt="$$T = A \cdot \left[{\matrix{x \cr y}}\right] + B$$" class="equation" width="110" height="36"></p>
         <p>or</p>
         <p><img src="warp_affine_demo_eq06924108956797778730.png" alt="$$T = M \cdot  [x, y, 1]^{T}$$" class="equation" width="109" height="18"></p>
         <p><img src="warp_affine_demo_eq11528765949148349239.png" alt="$$T = \left[{\matrix{&#xA;          a_{00}x + a_{01}y + b_{00} \cr&#xA;          a_{10}x + a_{11}y + b_{10}&#xA;      }}\right]$$" class="equation" width="154" height="36"></p>
         <p>How do we get an Affine Transformation?</p>
         <p>We mentioned that an affine transformation is basically a <b>relation</b> between two images. The information about this relation can come, roughly, in two ways:
         </p>
         <div>
            <ul>
               <li>We know both <img src="warp_affine_demo_eq12362013959998143435.png" alt="$X$" class="equation" width="13" height="10"> and T and we also know that they are related. Then our   task is to find <img src="warp_affine_demo_eq00802513524912003067.png" alt="$M$" class="equation" width="15" height="10"></li>
               <li>We know <img src="warp_affine_demo_eq00802513524912003067.png" alt="$M$" class="equation" width="15" height="10"> and <img src="warp_affine_demo_eq12362013959998143435.png" alt="$X$" class="equation" width="13" height="10">. To obtain <img src="warp_affine_demo_eq14047577632175690031.png" alt="$T$" class="equation" width="11" height="10"> we only need to apply <img src="warp_affine_demo_eq01889505930546173580.png" alt="$T = M \cdot X$" class="equation" width="69" height="10">.   Our information for <img src="warp_affine_demo_eq00802513524912003067.png" alt="$M$" class="equation" width="15" height="10"> may be explicit (i.e. have the 2-by-3 matrix) or   it can come as a geometric relation between points.
               </li>
            </ul>
         </div>
         <p>Let's explain the second point in a better way. Since <img src="warp_affine_demo_eq00802513524912003067.png" alt="$M$" class="equation" width="15" height="10"> relates two images, we can analyze the simplest case in which it relates three points in both images. Look at the figure
            below:
         </p>
         <p><img src="https://docs.opencv.org/3.2.0/Warp_Affine_Tutorial_Theory_0.jpg"></p>
         <p>the points 1, 2 and 3 (forming a triangle in image 1) are mapped into image 2, still forming a triangle, but now they have
            changed notoriously. If we find the affine transformation with these 3 points (you can choose them as you like), then we can
            apply this found relation to all the pixels in an image.
         </p>
         <h2 id="3">Code</h2>
         <p>This program:</p>
         <div>
            <ul>
               <li>Loads an image</li>
               <li>Applies an affine Transform to the image. This Transform is obtained from   the relation between three points. We use the
                  function <tt>cv.warpAffine</tt> for   that purpose.
               </li>
               <li>Applies a Rotation to the image after being transformed. This rotation is   with respect to the image center</li>
               <li>Waits until the user exits the program</li>
            </ul>
         </div>
         <p>load input image</p><pre class="codeinput">src = cv.imread(fullfile(mexopencv.root(), <span class="string">'test'</span>, <span class="string">'tsukuba.png'</span>), <span class="string">'Color'</span>,true);</pre><p><b>Affine Transform</b>: we need two sets of 3 points to derive the relation
         </p><pre class="codeinput">[rows,cols,~] = size(src);
src_tri = [0.0 0.0; cols - 1.0, 0; 0, rows - 1.0];
dst_tri = [cols*0.0, rows*0.33; cols*0.85, rows*0.25; cols*0.15, rows*0.7];
warp_mat = cv.getAffineTransform(src_tri, dst_tri);
display(warp_mat)  <span class="comment">% 2x3 affine transform matrix</span></pre><pre class="codeoutput">warp_mat =
    0.8522    0.2007         0
   -0.0602    0.3713   95.0400
</pre><p>Draw these points to get a better idea on how they change. Their locations are approximately the same as the ones depicted
            in the Theory section. You may note that the size and orientation of the triangle defined by the 3 points change.
         </p><pre class="codeinput">t = {num2str((1:3)'), <span class="string">'Color'</span>,<span class="string">'y'</span>, <span class="keyword">...</span>
    <span class="string">'VerticalAlignment'</span>,<span class="string">'middle'</span>, <span class="string">'HorizontalAlignment'</span>,<span class="string">'center'</span>};
p = {<span class="string">'c'</span>, <span class="string">'FaceAlpha'</span>,0.25, <span class="string">'EdgeColor'</span>,<span class="string">'b'</span>, <span class="string">'LineWidth'</span>,2, <span class="keyword">...</span>
    <span class="string">'Marker'</span>,<span class="string">'o'</span>, <span class="string">'MarkerSize'</span>,15, <span class="string">'MarkerFaceColor'</span>,<span class="string">'r'</span>};
pos = get(0, <span class="string">'DefaultFigurePosition'</span>);
figure(<span class="string">'Position'</span>,pos.*[1 1 1 0.5])
annotation(<span class="string">'arrow'</span>,[0.47 0.56], [0.5 0.5], <span class="string">'LineWidth'</span>,3, <span class="string">'HeadStyle'</span>,<span class="string">'plain'</span>)
subplot(121)
patch(src_tri(:,1), src_tri(:,2), p{:})
text(src_tri(:,1), src_tri(:,2), t{:})
title(<span class="string">'src'</span>), axis <span class="string">ij</span> <span class="string">image</span>, axis([1 cols 1 rows]-1), grid <span class="string">on</span>, box <span class="string">on</span>
subplot(122)
patch(dst_tri(:,1), dst_tri(:,2), p{:})
text(dst_tri(:,1), dst_tri(:,2), t{:})
title(<span class="string">'dst'</span>), axis <span class="string">ij</span> <span class="string">image</span>, axis([1 cols 1 rows]-1), grid <span class="string">on</span>, box <span class="string">on</span></pre><img src="warp_affine_demo_01.png"><p>apply the affine transform to the source image</p><pre class="codeinput">warp_dst = cv.warpAffine(src, warp_mat);</pre><p><b>Rotate</b>: we need the center with respect to which the image will rotate, the angle to be rotated, and an optional scale factor
         </p><pre class="codeinput">center = [size(warp_dst,2) size(warp_dst,1)] / 2;
ang = -50.0;  <span class="comment">% In OpenCV a positive angle is counter-clockwise</span>
scale = 0.6;
rot_mat = cv.getRotationMatrix2D(center, ang, scale);
display(rot_mat)  <span class="comment">% 2x3 rotation matrix</span></pre><pre class="codeoutput">rot_mat =
    0.3857   -0.4596  184.1371
    0.4596    0.3857    0.2148
</pre><p>apply the rotation to the output of our previous transformation</p><pre class="codeinput">warp_rotate_dst = cv.warpAffine(warp_dst, rot_mat);</pre><p>show results</p><pre class="codeinput">figure
subplot(211), imshow(src), title(<span class="string">'Source'</span>)
subplot(223), imshow(warp_dst), title(<span class="string">'Affine Transform'</span>)
subplot(224), imshow(warp_rotate_dst), title(<span class="string">'Rotation'</span>)</pre><img src="warp_affine_demo_02.png"><div class="footer">
            <p><a href="https://www.mathworks.com/products/matlab.html">Published with MATLAB&reg; R2017a</a></p>
         </div>
      </div><script type="text/x-mathjax-config">
  // https://stackoverflow.com/a/14631703/97160
  MathJax.Extension.myImg2jax = {
    version: "1.0",
    PreProcess: function (element) {
      var images = element.getElementsByTagName("img");
      for (var i = images.length - 1; i >= 0; i--) {
        var img = images[i];
        if (img.className === "equation") {
          var match = img.alt.match(/^(\$\$?)([\s\S]*)\1$/m);
          if (!match) continue;
          var script = document.createElement("script");
          script.type = "math/tex";
          if (match[1] === "$$") {script.type += ";mode=display"}
          MathJax.HTML.setScript(script, match[2]);
          img.parentNode.replaceChild(script, img);
        }
      }
    }
  };
  MathJax.Hub.Register.PreProcessor(["PreProcess", MathJax.Extension.myImg2jax]);
  </script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-AMS_CHTML"></script>
      <!--
##### SOURCE BEGIN #####
%% Image Affine Transformation
%
% In this demo, we show how to:
%
% * Use the OpenCV function |cv.warpAffine| to implement simple remapping
%   routines
% * Use the OpenCV function |cv.getRotationMatrix2D| to obtain a 2x3 rotation
%   matrix
%
% Sources:
%
% * <https://docs.opencv.org/3.2.0/d4/d61/tutorial_warp_affine.html>
% * <https://github.com/opencv/opencv/blob/3.2.0/samples/cpp/tutorial_code/ImgTrans/Geometric_Transforms_Demo.cpp>
%

%% Theory
%
% An affine transformation is any transformation that can be expressed in the
% form of a _matrix multiplication_ (linear transformation) followed by a
% _vector addition_ (translation).
%
% From the above, we can use an affine transformation to express:
%
% * Rotations (linear transformation)
% * Translations (vector addition)
% * Scale operations (linear transformation)
%
% you can see that, in essence, an affine transformation represents a
% *relation* between two images.
%
% The usual way to represent an affine transformation is by using a 2x3 matrix.
%
% $$
% A = \left[{\matrix{
%         a_{00} & a_{01} \cr
%         a_{10} & a_{11}
%     }}\right]_{2 \times 2}
% \qquad
% B = \left[{\matrix{
%         b_{00} \cr
%         b_{10}
%     }}\right]_{2 \times 1}
% $$
%
% $$
% M = \left[{\matrix{
%     A & B
%     }}\right]
% =
% \left[{\matrix{
%     a_{00} & a_{01} & b_{00} \cr
%     a_{10} & a_{11} & b_{10}
% }}\right]_{2 \times 3}
% $$
%
% Considering that we want to transform a 2D vector
% $X = \left[{\matrix{x \cr y}}\right]$ by using $A$ and $B$, we can do the
% same with:
%
% $$T = A \cdot \left[{\matrix{x \cr y}}\right] + B$$
%
% or
%
% $$T = M \cdot  [x, y, 1]^{T}$$
%
% $$T = \left[{\matrix{
%           a_{00}x + a_{01}y + b_{00} \cr
%           a_{10}x + a_{11}y + b_{10}
%       }}\right]$$
%
% How do we get an Affine Transformation?
%
% We mentioned that an affine transformation is basically a *relation* between
% two images. The information about this relation can come, roughly, in two
% ways:
%
% * We know both $X$ and T and we also know that they are related. Then our
%   task is to find $M$
% * We know $M$ and $X$. To obtain $T$ we only need to apply $T = M \cdot X$.
%   Our information for $M$ may be explicit (i.e. have the 2-by-3 matrix) or
%   it can come as a geometric relation between points.
%
% Let's explain the second point in a better way. Since $M$ relates two
% images, we can analyze the simplest case in which it relates three points in
% both images. Look at the figure below:
%
% <<https://docs.opencv.org/3.2.0/Warp_Affine_Tutorial_Theory_0.jpg>>
%
% the points 1, 2 and 3 (forming a triangle in image 1) are mapped into
% image 2, still forming a triangle, but now they have changed notoriously. If
% we find the affine transformation with these 3 points (you can choose them
% as you like), then we can apply this found relation to all the pixels in an
% image.
%

%% Code
%
% This program:
%
% * Loads an image
% * Applies an affine Transform to the image. This Transform is obtained from
%   the relation between three points. We use the function |cv.warpAffine| for
%   that purpose.
% * Applies a Rotation to the image after being transformed. This rotation is
%   with respect to the image center
% * Waits until the user exits the program
%

%%
% load input image
src = cv.imread(fullfile(mexopencv.root(), 'test', 'tsukuba.png'), 'Color',true);

%%
% *Affine Transform*: we need two sets of 3 points to derive the relation
[rows,cols,~] = size(src);
src_tri = [0.0 0.0; cols - 1.0, 0; 0, rows - 1.0];
dst_tri = [cols*0.0, rows*0.33; cols*0.85, rows*0.25; cols*0.15, rows*0.7];
warp_mat = cv.getAffineTransform(src_tri, dst_tri);
display(warp_mat)  % 2x3 affine transform matrix

%%
% Draw these points to get a better idea on how they change. Their locations
% are approximately the same as the ones depicted in the Theory section. You
% may note that the size and orientation of the triangle defined by the
% 3 points change.
t = {num2str((1:3)'), 'Color','y', ...
    'VerticalAlignment','middle', 'HorizontalAlignment','center'};
p = {'c', 'FaceAlpha',0.25, 'EdgeColor','b', 'LineWidth',2, ...
    'Marker','o', 'MarkerSize',15, 'MarkerFaceColor','r'};
pos = get(0, 'DefaultFigurePosition');
figure('Position',pos.*[1 1 1 0.5])
annotation('arrow',[0.47 0.56], [0.5 0.5], 'LineWidth',3, 'HeadStyle','plain')
subplot(121)
patch(src_tri(:,1), src_tri(:,2), p{:})
text(src_tri(:,1), src_tri(:,2), t{:})
title('src'), axis ij image, axis([1 cols 1 rows]-1), grid on, box on
subplot(122)
patch(dst_tri(:,1), dst_tri(:,2), p{:})
text(dst_tri(:,1), dst_tri(:,2), t{:})
title('dst'), axis ij image, axis([1 cols 1 rows]-1), grid on, box on

%%
% apply the affine transform to the source image
warp_dst = cv.warpAffine(src, warp_mat);

%%
% *Rotate*: we need the center with respect to which the image will rotate,
% the angle to be rotated, and an optional scale factor
center = [size(warp_dst,2) size(warp_dst,1)] / 2;
ang = -50.0;  % In OpenCV a positive angle is counter-clockwise
scale = 0.6;
rot_mat = cv.getRotationMatrix2D(center, ang, scale);
display(rot_mat)  % 2x3 rotation matrix

%%
% apply the rotation to the output of our previous transformation
warp_rotate_dst = cv.warpAffine(warp_dst, rot_mat);

%%
% show results
figure
subplot(211), imshow(src), title('Source')
subplot(223), imshow(warp_dst), title('Affine Transform')
subplot(224), imshow(warp_rotate_dst), title('Rotation')

##### SOURCE END #####
--></body>
</html>