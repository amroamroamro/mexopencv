<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
   
      <link rel="stylesheet" href="helpwin.css" />
      <title>cv.getOptimalDFTSize - mexopencv</title>
   <link rel="stylesheet" type="text/css" href="helpwin_custom.css" />
<meta name="generator" content="MATLAB 9.4.0.902940 (R2018a) Update 4" />
<meta name="description" content="cv.getOptimalDFTSize - Returns the optimal DFT size for a given vector size" />
<link rel="stylesheet" type="text/css" href="matlab.min.css" />
</head>
   <body onload="PR.prettyPrint();">
      <!--Single-page help-->
      <table border="0" cellspacing="0" width="100%">
         <tbody><tr class="subheader">
            <td class="headertitle">cv.getOptimalDFTSize - MATLAB File Help</td>
            <td class="subheader-right"></td>
         </tr>
      </tbody></table>
      <div class="title">cv.getOptimalDFTSize</div>
      <div class="helpcontent"><p class=" h1line">Returns the optimal DFT size for a given vector size</p>
<pre class=" prettyprint lang-matlab"><code>N = <a href="cv.getOptimalDFTSize.html">cv.getOptimalDFTSize</a>(vecsize)
</code></pre>
<h2>Input</h2>
<ul>
<li><strong>vecsize</strong> vector size.</li>
</ul>
<h2>Output</h2>
<ul>
<li><strong>N</strong> optimal DFT size.</li>
</ul>
<p>DFT performance is not a monotonic function of a vector size. Therefore,
when you calculate convolution of two arrays or perform the spectral
analysis of an array, it usually makes sense to pad the input data with
zeros to get a bit larger array that can be transformed much faster than the
original one. Arrays whose size is a power-of-two (2, 4, 8, 16, 32, etc.)
are the fastest to process. Though, the arrays whose size is a product of
2's, 3's, and 5's (for example, <code>300 = 5*5*3*2*2</code>) are also processed quite
efficiently.</p>
<p>The function <a href="cv.getOptimalDFTSize.html">cv.getOptimalDFTSize</a> returns the minimum number <code>N</code> that is
greater than or equal to vecsize so that the DFT of a vector of size <code>N</code> can
be processed efficiently. In the current implementation <code>N = 2^p * 3^q * 5^r</code>
for some integer <code>p</code>, <code>q</code>, <code>r</code>.</p>
<p>The function returns a negative number if <code>vecsize</code> is too large (very close
to <code>intmax</code>).</p>
<p>While the function cannot be used directly to estimate the optimal vector
size for DCT transform (since the current DCT implementation supports only
even-size vectors), it can be easily processed as
<code><a href="cv.getOptimalDFTSize.html">cv.getOptimalDFTSize</a>((vecsize+1)/2)*2</code>.</p>
</div><!--after help --><!--seeAlso--><div class="footerlinktitle">See also</div><div class="footerlink"> <a href="cv.dft.html">cv.dft</a>, <a href="cv.dct.html">cv.dct</a>, <a href="cv.mulSpectrums.html">cv.mulSpectrums</a>, <a href="https://www.mathworks.com/help/matlab/ref/nextpow2.html" target="_blank">nextpow2</a></div>
   
<script type="text/javascript" src="prettify.js"></script>
<script type="text/javascript" src="lang-matlab.min.js"></script>
</body></html>