<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
   
      <link rel="stylesheet" href="helpwin.css" />
      <title>cv.dct - mexopencv</title>
   <link rel="stylesheet" type="text/css" href="helpwin_custom.css" />
<meta name="generator" content="MATLAB 9.4.0.902940 (R2018a) Update 4" />
<meta name="description" content="cv.dct - Performs a forward or inverse discrete Cosine transform of 1D or 2D array" />
<link rel="stylesheet" type="text/css" href="matlab.min.css" />
</head>
   <body onload="PR.prettyPrint();">
      <!--Single-page help-->
      <table border="0" cellspacing="0" width="100%">
         <tbody><tr class="subheader">
            <td class="headertitle">cv.dct - MATLAB File Help</td>
            <td class="subheader-right"></td>
         </tr>
      </tbody></table>
      <div class="title">cv.dct</div>
      <div class="helpcontent"><p class=" h1line">Performs a forward or inverse discrete Cosine transform of 1D or 2D array</p>
<pre class=" prettyprint lang-matlab"><code>dst = <a href="cv.dct.html">cv.dct</a>(src)
dst = <a href="cv.dct.html">cv.dct</a>(src, 'OptionName',optionValue, ...)
</code></pre>
<h2>Input</h2>
<ul>
<li><strong>src</strong> input floating-point single-channel array.</li>
</ul>
<h2>Output</h2>
<ul>
<li><strong>dst</strong> output array of the same size and type as <code>src</code>.</li>
</ul>
<h2>Options</h2>
<ul>
<li><strong>Inverse</strong> performs an inverse 1D or 2D transform instead of the default
forward transform. default false</li>
<li><strong>Rows</strong> performs a forward or inverse transform of every individual row
of the input matrix. This flag enables you to transform multiple vectors
simultaneously and can be used to decrease the overhead (which is sometimes
several times larger than the processing itself) to perform 3D and
higher-dimensional transforms and so forth. default false</li>
</ul>
<p>The function <a href="cv.dct.html">cv.dct</a> performs a forward or inverse discrete Cosine
transform (dct) of a 1D or 2D floating-point array:</p>
<ul>
<li>
<p>Forward Cosine transform of a 1D vector of N elements:</p>
<pre class=" prettyprint lang-matlab"><code>Y = CN * X
</code></pre>
<p>where</p>
<pre class=" prettyprint lang-matlab"><code>CN(j,k) = sqrt(alpha_j/N) * cos((pi*(2k+1)*j)/2N)
</code></pre>
<p>and <code>alpha_0=1</code>, <code>alpha_j=2</code> for <code>j&gt;0</code>.</p>
</li>
<li>
<p>Inverse Cosine transform of a 1D vector of N elements:</p>
<pre class=" prettyprint lang-matlab"><code>X = inv(CN) * Y = transpose(CN) * Y
</code></pre>
<p>(since <code>CN</code> is an orthogonal matrix, <code>CN * transpose(CN) = I</code>)</p>
</li>
<li>
<p>Forward 2D Cosine transform of MxN matrix:</p>
<pre class=" prettyprint lang-matlab"><code>Y = CN * X * transpose(CN)
</code></pre>
</li>
<li>
<p>Inverse 2D Cosine transform of MxN matrix:</p>
<pre class=" prettyprint lang-matlab"><code>X =  transpose(CN) * X * CN
</code></pre>
</li>
</ul>
<p>The function chooses the mode of operation by looking at the transformation
flags and size of the input array:</p>
<ul>
<li>If <code>Inverse = true</code>, the function does a forward 1D or 2D transform.
Otherwise, it is an inverse 1D or 2D transform.</li>
<li>If <code>Rows = true</code>, the function performs a 1D transform of each row.</li>
<li>If the array is a single column or a single row, the function performs a
1D transform.</li>
<li>If none of the above is true, the function performs a 2D transform.</li>
</ul>
<p>Note: Currently <a href="cv.dct.html">cv.dct</a> supports even-size arrays (2, 4, 6, etc.). For data
analysis and approximation, you can pad the array when necessary. Also, the
function performance depends very much, and not monotonically, on the array
size (see <a href="cv.getOptimalDFTSize.html">cv.getOptimalDFTSize</a>). In the current implementation, dct of a
vector of size <code>N</code> is calculated via DFT of a vector of size <code>N/2</code>. Thus,
the optimal dct size <code>N1 &gt;= N</code> can be calculated as:</p>
<pre class=" prettyprint lang-matlab"><code>function N1 = getOptimalDCTSize(N)
    N1 = 2 * <a href="cv.getOptimalDFTSize.html">cv.getOptimalDFTSize</a>(fix((N+1)/2));
end
</code></pre>
<p>Note: <a href="cv.idct.html">cv.idct</a> is equivalent to <code><a href="cv.dct.html">cv.dct</a>(..., 'Inverse',true)</code>.</p>
</div><!--after help --><!--seeAlso--><div class="footerlinktitle">See also</div><div class="footerlink"> <a href="cv.dft.html">cv.dft</a>, <a href="cv.getOptimalDFTSize.html">cv.getOptimalDFTSize</a>, <a href="https://www.mathworks.com/help/signal/ref/dct.html" target="_blank">dct</a>, <a href="https://www.mathworks.com/help/images/ref/dct2.html" target="_blank">dct2</a>, <a href="https://www.mathworks.com/help/signal/ref/idct.html" target="_blank">idct</a>, <a href="https://www.mathworks.com/help/images/ref/idct2.html" target="_blank">idct2</a></div>
   
<script type="text/javascript" src="prettify.js"></script>
<script type="text/javascript" src="lang-matlab.min.js"></script>
</body></html>