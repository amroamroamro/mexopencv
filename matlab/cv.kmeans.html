<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
   
      <link rel="stylesheet" href="helpwin.css" />
      <title>cv.kmeans - mexopencv</title>
   <link rel="stylesheet" type="text/css" href="helpwin_custom.css" />
<meta name="generator" content="MATLAB 9.4.0.902940 (R2018a) Update 4" />
<meta name="description" content="cv.kmeans - Finds centers of clusters and groups input samples around the clusters" />
<link rel="stylesheet" type="text/css" href="matlab.min.css" />
</head>
   <body onload="PR.prettyPrint();">
      <!--Single-page help-->
      <table border="0" cellspacing="0" width="100%">
         <tbody><tr class="subheader">
            <td class="headertitle">cv.kmeans - MATLAB File Help</td>
            <td class="subheader-right"></td>
         </tr>
      </tbody></table>
      <div class="title">cv.kmeans</div>
      <div class="helpcontent"><p class=" h1line">Finds centers of clusters and groups input samples around the clusters</p>
<pre class=" prettyprint lang-matlab"><code>labels = <a href="cv.kmeans.html">cv.kmeans</a>(data, K)
[labels, centers, compactness] = <a href="cv.kmeans.html">cv.kmeans</a>(...)
[...] = <a href="cv.kmeans.html">cv.kmeans</a>(..., 'OptionName', optionValue, ...)
</code></pre>
<h2>Input</h2>
<ul>
<li><strong>data</strong> Data for clustering. An array of D-dimensional points with
floating-point coordinates is needed. Examples of this matrix can be: NxD
numeric matrix (one row per sample), or Nx1xD/1xNxD array (with dimensions
across slices).</li>
<li><strong>K</strong> Number of clusters to split the set by.</li>
</ul>
<h2>Output</h2>
<ul>
<li><strong>labels</strong> Integer array that stores the cluster indices for every sample.</li>
<li><strong>centers</strong> Output matrix of the cluster centers, one row per each cluster
center.</li>
<li><strong>compactness</strong> Measure of compactness. See below.</li>
</ul>
<h2>Options</h2>
<ul>
<li><strong>Criteria</strong> The algorithm termination criteria, that is, the maximum
number of iterations and/or the desired accuracy. The accuracy is
specified as <code>criteria.epsilon</code>. As soon as each of the cluster centers
moves by less than <code>criteria.epsilon</code> on some iteration, the algorithm
stops. default
<code>struct('type','Count+EPS', 'maxCount',100, 'epsilon',eps('float'))</code></li>
<li><strong>Attempts</strong> The number of times the algorithm is executed using different
initial labelings. The algorithm returns the labels that yield the best
compactness (see the last function parameter). default 10.</li>
<li><strong>Initialization</strong> Method to initialize seeds. One of the followings:
<ul>
<li><strong>Random</strong> Select random initial centers in each attempt. (default)</li>
<li><strong>PP</strong> Use kmeans++ center initialization by Arthur and Vassilvitskii
[Arthur2007].</li>
</ul>
</li>
<li><strong>InitialLabels</strong> Integer array that stores the initial cluster indices
for every sample. During the first (and possibly the only) attempt, kmeans
uses the user-supplied labels instead of computing them from the initial
centers. For the second and further attempts, it uses the random or
semi-random centers. Use one of the <code>Initialization</code> methods to specify
the exact method. Not set by default.</li>
</ul>
<p>The function <a href="cv.kmeans.html">cv.kmeans</a> implements a k-means algorithm that finds the centers
of <code>K</code> clusters and groups the input samples around the clusters. As an
output, <code>labels(i)</code> contains a 0-based cluster index for the sample stored
in the i-th row of the samples matrix.</p>
<p>The function returns the compactness measure that is computed as:</p>
<pre class=" prettyprint lang-matlab"><code>sum_{i} (|| samples_i - centers_{labels_i} ||^2)
</code></pre>
<p>after every attempt. The best (minimum) value is chosen and the
corresponding labels and the compactness value are returned by the
function. Basically, you can use only the core of the function, set the
number of attempts to 1, initialize labels each time using a custom
algorithm, pass them with the <code>InitialLabels</code> option, and then choose the
best (most-compact) clustering.</p>
<h2>References</h2>
<p>[Arthur2007]:</p>
<blockquote>
<p>D. Arthur, S. Vassilvitskii: &quot;k-means++: The Advantages of Careful Seeding&quot;.
In Proceedings of the eighteenth annual ACM-SIAM symposium
on Discrete algorithms, 1027-1035, 2007.</p>
</blockquote>
</div><!--after help --><!--seeAlso--><div class="footerlinktitle">See also</div><div class="footerlink"> <a href="https://www.mathworks.com/help/stats/ref/kmeans.html" target="_blank">kmeans</a></div>
   
<script type="text/javascript" src="prettify.js"></script>
<script type="text/javascript" src="lang-matlab.min.js"></script>
</body></html>