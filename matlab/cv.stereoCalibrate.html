<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
   
      <link rel="stylesheet" href="helpwin.css" />
      <title>cv.stereoCalibrate - mexopencv</title>
   <link rel="stylesheet" type="text/css" href="helpwin_custom.css" />
<meta name="generator" content="MATLAB 9.4.0.902940 (R2018a) Update 4" />
<meta name="description" content="cv.stereoCalibrate - Calibrates the stereo camera" />
<link rel="stylesheet" type="text/css" href="matlab.min.css" />
</head>
   <body onload="PR.prettyPrint();">
      <!--Single-page help-->
      <table border="0" cellspacing="0" width="100%">
         <tbody><tr class="subheader">
            <td class="headertitle">cv.stereoCalibrate - MATLAB File Help</td>
            <td class="subheader-right"></td>
         </tr>
      </tbody></table>
      <div class="title">cv.stereoCalibrate</div>
      <div class="helpcontent"><p class=" h1line">Calibrates the stereo camera</p>
<pre class=" prettyprint lang-matlab"><code>S = <a href="cv.stereoCalibrate.html">cv.stereoCalibrate</a>(objectPoints, imagePoints1, imagePoints2, imageSize)
[...] = <a href="cv.stereoCalibrate.html">cv.stereoCalibrate</a>(..., 'OptionName', optionValue, ...)
</code></pre>
<h2>Input</h2>
<ul>
<li><strong>objectPoints</strong> A cell array of cells of calibration pattern points in
the calibration pattern coordinate space  <code>{{[x,y,z], ..}, ...}</code>.</li>
<li><strong>imagePoints1</strong> A cell array of cells of the projections of calibration
pattern points <code>{{[x,y], ..}, ...}</code>, observed by the first camera.</li>
<li><strong>imagePoints2</strong> A cell array of cells of the projections of calibration
pattern points <code>{{[x,y], ..}, ...}</code>, observed by the second camera.</li>
<li><strong>imageSize</strong> Size of the image used only to initialize the intrinsic
camera matrix <code>[w,h]</code>.</li>
</ul>
<h2>Output</h2>
<ul>
<li><strong>S</strong> scalar struct having the following fields:
<ul>
<li><strong>cameraMatrix1</strong> output first camera matrix
<code>A = [fx1 0 cx1; 0 fy1 cy1; 0 0 1]</code>.</li>
<li><strong>distCoeffs1</strong> output vector of distortion coefficients
<code>[k1,k2,p1,p2,k3,k4,k5,k6,s1,s2,s3,s4,taux,tauy]</code> of 4, 5, 8, 12
or 14 elements. The output vector length depends on the options.</li>
<li><strong>cameraMatrix2</strong> output second camera matrix
<code>A = [fx2 0 cx2; 0 fy2 cy2; 0 0 1]</code>. The parameter is similar to
<code>cameraMatrix1</code>.</li>
<li><strong>distCoeffs2</strong> output lens distortion coefficients for the second
camera. The parameter is similar to <code>distCoeffs1</code>.</li>
<li><strong>R</strong> output 3x3 rotation matrix between the 1st and the 2nd camera
coordinate systems.</li>
<li><strong>T</strong> output 3x1 translation vector between the coordinate systems of
the cameras.</li>
<li><strong>E</strong> output 3x3 essential matrix.</li>
<li><strong>F</strong> output 3x3 fundamental matrix.</li>
<li><strong>reprojErr</strong> output final re-projection error (scalar).</li>
</ul>
</li>
<li><strong>perViewErrors</strong> Output matrix of the RMS re-projection error estimated
for each pattern view.</li>
</ul>
<h2>Options</h2>
<ul>
<li><strong>CameraMatrix1</strong>, <strong>CameraMatrix2</strong> Initial camera matrices. If any of
<code>UseIntrinsicGuess</code>, <code>FixAspectRatio</code>, <code>FixIntrinsic</code> (default), or
<code>FixFocalLength</code> are specified, some or all of the matrix components must
be initialized. See the flags description for details.</li>
<li><strong>DistCoeffs1</strong>, <strong>DistCoeffs2</strong> Initial lens distortion coefficients.</li>
<li><strong>R</strong>, <strong>T</strong> Initial extrinsic parameters <code>R</code> and <code>T</code>.
If <code>UseExtrinsicGuess</code> is set, these must be initialized. Not set by
default.</li>
<li><strong>FixIntrinsic</strong> Fix <code>cameraMatrix1</code>,<code>cameraMatrix2</code> and <code>distCoeffs1</code>,
<code>distCoeffs2</code> so that only <code>R</code>, <code>T</code>, <code>E</code>, and <code>F</code> matrices are estimated.
default true.</li>
<li><strong>UseIntrinsicGuess</strong> Optimize some or all of the intrinsic parameters
according to the specified flags. Initial values are provided by the user.
default false.</li>
<li><strong>UseExtrinsicGuess</strong> <code>R</code>, <code>T</code> contain valid initial values that are
optimized further. Otherwise <code>R</code>, <code>T</code> are initialized to the median value
of the pattern views (each dimension separately). default false</li>
<li><strong>FixPrincipalPoint</strong> Fix the principal points during the optimization.
default false.</li>
<li><strong>FixFocalLength</strong> Fix <code>fx1</code>,<code>fx2</code> and <code>fy1</code>,<code>fy2</code>. default false.</li>
<li><strong>FixAspectRatio</strong> Optimize <code>fy1</code>,<code>fy2</code> and fix the ratio <code>fx1/fy1</code>,
<code>fx2/fy2</code>. default false.</li>
<li><strong>SameFocalLength</strong> Enforce same <code>fx1=fx2</code> and <code>fy1=fy2</code>. default false.</li>
<li><strong>ZeroTangentDist</strong> Tangential distortion coefficients for each camera are
set to zeros and stay fixed. default false.</li>
<li><strong>FixTangentDist</strong> The tangential distortion coefficients are not
changed during the optimization. If <code>UseIntrinsicGuess</code> is set, the
coefficient from the supplied <code>DistCoeffs</code> matrix is used. Otherwise, it
is set to 0. default false.</li>
<li><strong>FixK1</strong>, ..., <strong>FixK6</strong> The corresponding radial distortion coefficient
is not changed during the optimization. If <code>UseIntrinsicGuess</code> is set, the
coefficient from the supplied <code>DistCoeffs</code> matrix is used. Otherwise, it
is set to 0. default false.</li>
<li><strong>RationalModel</strong> Coefficients <code>k4</code>, <code>k5</code>, and <code>k6</code> are enabled. To
provide the backward compatibility, this extra flag should be explicitly
specified to make the calibration function use the rational model and
return 8 coefficients. If the flag is not set, the function computes and
returns only 5 distortion coefficients. default false.
(<code>RationalModel</code> as false implies <code>FixK4</code>,<code>FixK5</code>,<code>FixK6</code> as true).</li>
<li><strong>ThinPrismModel</strong> Coefficients <code>s1</code>, <code>s2</code>, <code>s3</code> and <code>s4</code> are enabled. To
provide the backward compatibility, this extra flag should be explicitly
specified to make the calibration function use the thin prism model and
return 12 coefficients. If the flag is not set, the function computes and
returns only 5 distortion coefficients. default false.
(<code>ThinPrismModel</code> as false implies <code>FixS1S2S3S4</code> as true).</li>
<li><strong>FixS1S2S3S4</strong> The thin prism distortion coefficients are not changed
during the optimization. If <code>UseIntrinsicGuess</code> is set, the coefficient
from the supplied <code>DistCoeffs</code> matrix is used. Otherwise, it is set to 0.
default false.</li>
<li><strong>TiltedModel</strong> Coefficients <code>tauX</code> and <code>tauY</code> are enabled. To provide the
backward compatibility, this extra flag should be explicitly specified to
make the calibration function use the tilted sensor model and return 14
coefficients. If the flag is not set, the function computes and returns
only 5 distortion coefficients. default false.
(<code>TiltedModel</code> as false implies <code>FixTauXTauY</code> as true).</li>
<li><strong>FixTauXTauY</strong> The coefficients of the tilted sensor model are not
changed during the optimization. If <code>UseIntrinsicGuess</code> is set, the
coefficient from the supplied <code>DistCoeffs</code> matrix is used. Otherwise, it
is set to 0. default false.</li>
<li><strong>UseLU</strong> Use LU instead of SVD decomposition for solving. Much faster but
potentially less precise. default false.</li>
<li><strong>UseQR</strong> Use QR instead of SVD decomposition for solving. Faster but
potentially less precise. default false.</li>
<li><strong>Criteria</strong> Termination criteria for the iterative optimization algorithm.
default <code>struct('type','Count+EPS', 'maxCount',30, 'epsilon',1e-6)</code></li>
</ul>
<p>The function estimates transformation between two cameras making a stereo
pair. If you have a stereo camera where the relative position and
orientation of two cameras is fixed, and if you computed poses of an object
relative to the first camera and to the second camera, <code>(R1,T1)</code> and
<code>(R2,T2)</code>, respectively (this can be done with <a href="cv.solvePnP.html">cv.solvePnP</a>), then those
poses definitely relate to each other. This means that, given <code>(R1,T1)</code>, it
should be possible to compute <code>(R2,T2)</code>. You only need to know the position
and orientation of the second camera relative to the first camera. This is
what the described function does. It computes <code>(R,T)</code> so that:</p>
<pre class=" prettyprint lang-matlab"><code>R2 = R * R1
T2 = R * T1 + T
</code></pre>
<p>Optionally, it computes the essential matrix <code>E</code>:</p>
<pre class=" prettyprint lang-matlab"><code>E = [ 0 -T2  T1;
     T2   0 -T0;
    -T1  T0   0] * R
</code></pre>
<p>where <code>Ti</code> are components of the translation vector <code>T</code>: <code>T = [T0,T1,T2]'</code>.
And the function can also compute the fundamental matrix <code>F</code>:</p>
<pre class=" prettyprint lang-matlab"><code>F = inv(cameraMatrix2)' * E * inv(cameraMatrix1)
</code></pre>
<p>Besides the stereo-related information, the function can also perform a full
calibration of each of two cameras. However, due to the high dimensionality
of the parameter space and noise in the input data, the function can diverge
from the correct solution. If the intrinsic parameters can be estimated with
high accuracy for each of the cameras individually (for example, using
<a href="cv.calibrateCamera.html">cv.calibrateCamera</a>), you are recommended to do so and then pass
<code>FixIntrinsic</code> flag to the function along with the computed intrinsic
parameters. Otherwise, if all the parameters are estimated at once, it makes
sense to restrict some parameters, for example, pass <code>SameFocalLength</code> and
<code>ZeroTangentDist</code> flags, which is usually a reasonable assumption.</p>
<p>Similarly to <a href="cv.calibrateCamera.html">cv.calibrateCamera</a>, the function minimizes the total
re-projection error for all the points in all the available views from both
cameras. The function returns the final value of the re-projection error.</p>
</div><!--after help --><!--seeAlso--><div class="footerlinktitle">See also</div><div class="footerlink"> <a href="cv.calibrateCamera.html">cv.calibrateCamera</a>, <a href="cv.solvePnP.html">cv.solvePnP</a>, <a href="cv.stereoRectify.html">cv.stereoRectify</a>,
   <a href="https://www.mathworks.com/help/vision/ref/estimatecameraparameters.html" target="_blank">estimateCameraParameters</a>, <a href="https://www.mathworks.com/help/vision/ref/stereoparameters.html" target="_blank">stereoParameters</a>, <a href="https://www.mathworks.com/help/vision/ref/extrinsics.html" target="_blank">extrinsics</a></div>
   
<script type="text/javascript" src="prettify.js"></script>
<script type="text/javascript" src="lang-matlab.min.js"></script>
</body></html>