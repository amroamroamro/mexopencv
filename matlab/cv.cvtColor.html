<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
   
      <link rel="stylesheet" href="helpwin.css" />
      <title>cv.cvtColor - mexopencv</title>
   <link rel="stylesheet" type="text/css" href="helpwin_custom.css" />
<meta name="generator" content="MATLAB 9.4.0.902940 (R2018a) Update 4" />
<meta name="description" content="cv.cvtColor - Converts an image from one color space to another" />
<link rel="stylesheet" type="text/css" href="matlab.min.css" />
</head>
   <body onload="PR.prettyPrint();">
      <!--Single-page help-->
      <table border="0" cellspacing="0" width="100%">
         <tbody><tr class="subheader">
            <td class="headertitle">cv.cvtColor - MATLAB File Help</td>
            <td class="subheader-right"></td>
         </tr>
      </tbody></table>
      <div class="title">cv.cvtColor</div>
      <div class="helpcontent"><p class=" h1line">Converts an image from one color space to another</p>
<pre class=" prettyprint lang-matlab"><code>dst = <a href="cv.cvtColor.html">cv.cvtColor</a>(src, code)
dst = <a href="cv.cvtColor.html">cv.cvtColor</a>(src, code, 'OptionName',optionValue, ...)
</code></pre>
<h2>Input</h2>
<ul>
<li><strong>src</strong> Input image: 8-bit unsigned, 16-bit unsigned, or single-precision
floating-point.</li>
<li><strong>code</strong> Color space conversion code string, e.g., 'RGB2GRAY'. The
following codes are supported:
<ul>
<li><strong>BGR2BGRA</strong>, <strong>RGB2RGBA</strong>: add alpha channel to RGB and BGR image</li>
<li><strong>BGRA2BGR</strong>, <strong>RGBA2RGB</strong>: remove alpha channel from RGB and BGR image</li>
<li><strong>BGR2RGBA</strong>, <strong>RGB2BGRA</strong>, <strong>RGBA2BGR</strong>, <strong>BGRA2RGB</strong>, <strong>BGR2RGB</strong>,
<strong>RGB2BGR</strong>, <strong>BGRA2RGBA</strong>, <strong>RGBA2BGRA</strong>: convert between RGB and BGR
color spaces (with or without alpha channel)</li>
<li><strong>BGR2GRAY</strong>, <strong>RGB2GRAY</strong>, <strong>GRAY2BGR</strong>, <strong>GRAY2RGB</strong>, <strong>GRAY2BGRA</strong>,
<strong>GRAY2RGBA</strong>, <strong>BGRA2GRAY</strong>, <strong>RGBA2GRAY</strong>: convert between RGB/BGR and
grayscale</li>
<li><strong>BGR2BGR565</strong>, <strong>RGB2BGR565</strong>, <strong>BGR5652BGR</strong>, <strong>BGR5652RGB</strong>,
<strong>BGRA2BGR565</strong>, <strong>RGBA2BGR565</strong>, <strong>BGR5652BGRA</strong>, <strong>BGR5652RGBA</strong>:
convert between RGB/BGR and BGR565 (16-bit images)</li>
<li><strong>GRAY2BGR565</strong>, <strong>BGR5652GRAY</strong>: convert between grayscale and BGR565
(16-bit images)</li>
<li><strong>BGR2BGR555</strong>, <strong>RGB2BGR555</strong>, <strong>BGR5552BGR</strong>, <strong>BGR5552RGB</strong>,
<strong>BGRA2BGR555</strong>, <strong>RGBA2BGR555</strong>, <strong>BGR5552BGRA</strong>, <strong>BGR5552RGBA</strong>:
convert between RGB/BGR and BGR555 (16-bit images)</li>
<li><strong>GRAY2BGR555</strong>, <strong>BGR5552GRAY</strong>: convert between grayscale and BGR555
(16-bit images)</li>
<li><strong>BGR2XYZ</strong>, <strong>RGB2XYZ</strong>, <strong>XYZ2BGR</strong>, <strong>XYZ2RGB</strong>: convert between
RGB/BGR and CIE XYZ</li>
<li><strong>BGR2YCrCb</strong>, <strong>RGB2YCrCb</strong>, <strong>YCrCb2BGR</strong>, <strong>YCrCb2RGB</strong>: convert
between RGB/BGR and luma-chroma (aka YCC)</li>
<li><strong>BGR2YUV</strong>, <strong>RGB2YUV</strong>, <strong>YUV2BGR</strong>, <strong>YUV2RGB</strong>: convert between
RGB/BGR and YUV</li>
<li><strong>BGR2HSV</strong>, <strong>RGB2HSV</strong>, <strong>HSV2BGR</strong>, <strong>HSV2RGB</strong>, <strong>BGR2HSV_FULL</strong>,
<strong>RGB2HSV_FULL</strong>, <strong>HSV2BGR_FULL</strong>, <strong>HSV2RGB_FULL</strong>: convert between
RGB/BGR and HSV (hue saturation value)</li>
<li><strong>BGR2HLS</strong>, <strong>RGB2HLS</strong>, <strong>HLS2BGR</strong>, <strong>HLS2RGB</strong>, <strong>BGR2HLS_FULL</strong>,
<strong>RGB2HLS_FULL</strong>, <strong>HLS2BGR_FULL</strong>, <strong>HLS2RGB_FULL</strong>: convert between
RGB/BGR and HLS (hue lightness saturation)</li>
<li><strong>BGR2Lab</strong>, <strong>RGB2Lab</strong>, <strong>Lab2BGR</strong>, <strong>Lab2RGB</strong>, <strong>LBGR2Lab</strong>,
<strong>LRGB2Lab</strong>, <strong>Lab2LBGR</strong>, <strong>Lab2LRGB</strong>: convert between RGB/BGR and
CIE Lab</li>
<li><strong>BGR2Luv</strong>, <strong>RGB2Luv</strong>, <strong>Luv2BGR</strong>, <strong>Luv2RGB</strong>, <strong>LBGR2Luv</strong>,
<strong>LRGB2Luv</strong>, <strong>Luv2LBGR</strong>, <strong>Luv2LRGB</strong>: convert between RGB/BGR and
CIE Luv</li>
<li><strong>YUV2RGB_NV12</strong>, <strong>YUV2BGR_NV12</strong>, <strong>YUV2RGB_NV21</strong>, <strong>YUV2BGR_NV21</strong>,
<strong>YUV420sp2RGB</strong>, <strong>YUV420sp2BGR</strong>, <strong>YUV2RGBA_NV12</strong>, <strong>YUV2BGRA_NV12</strong>,
<strong>YUV2RGBA_NV21</strong>, <strong>YUV2BGRA_NV21</strong>, <strong>YUV420sp2RGBA</strong>,
<strong>YUV420sp2BGRA</strong>, <strong>YUV2RGB_YV12</strong>, <strong>YUV2BGR_YV12</strong>, <strong>YUV2RGB_IYUV</strong>,
<strong>YUV2BGR_IYUV</strong>, <strong>YUV2RGB_I420</strong>, <strong>YUV2BGR_I420</strong>, <strong>YUV420p2RGB</strong>,
<strong>YUV420p2BGR</strong>, <strong>YUV2RGBA_YV12</strong>, <strong>YUV2BGRA_YV12</strong>, <strong>YUV2RGBA_IYUV</strong>,
<strong>YUV2BGRA_IYUV</strong>, <strong>YUV2RGBA_I420</strong>, <strong>YUV2BGRA_I420</strong>,
<strong>YUV420p2RGBA</strong>, <strong>YUV420p2BGRA</strong>, <strong>YUV2GRAY_420</strong>, <strong>YUV2GRAY_NV21</strong>,
<strong>YUV2GRAY_NV12</strong>, <strong>YUV2GRAY_YV12</strong>, <strong>YUV2GRAY_IYUV</strong>,
<strong>YUV2GRAY_I420</strong>, <strong>YUV420sp2GRAY</strong>, <strong>YUV420p2GRAY</strong>: YUV 4:2:0 family
to RGB</li>
<li><strong>YUV2RGB_UYVY</strong>, <strong>YUV2BGR_UYVY</strong>, <strong>YUV2RGB_Y422</strong>, <strong>YUV2BGR_Y422</strong>,
<strong>YUV2RGB_UYNV</strong>, <strong>YUV2BGR_UYNV</strong>, <strong>YUV2RGBA_UYVY</strong>,
<strong>YUV2BGRA_UYVY</strong>, <strong>YUV2RGBA_Y422</strong>, <strong>YUV2BGRA_Y422</strong>,
<strong>YUV2RGBA_UYNV</strong>, <strong>YUV2BGRA_UYNV</strong>, <strong>YUV2RGB_YUY2</strong>, <strong>YUV2BGR_YUY2</strong>,
<strong>YUV2RGB_YVYU</strong>, <strong>YUV2BGR_YVYU</strong>, <strong>YUV2RGB_YUYV</strong>, <strong>YUV2BGR_YUYV</strong>,
<strong>YUV2RGB_YUNV</strong>, <strong>YUV2BGR_YUNV</strong>, <strong>YUV2RGBA_YUY2</strong>, <strong>YUV2BGRA_YUY2</strong>,
<strong>YUV2RGBA_YVYU</strong>, <strong>YUV2BGRA_YVYU</strong>, <strong>YUV2RGBA_YUYV</strong>,
<strong>YUV2BGRA_YUYV</strong>, <strong>YUV2RGBA_YUNV</strong>, <strong>YUV2BGRA_YUNV</strong>,
<strong>YUV2GRAY_UYVY</strong>, <strong>YUV2GRAY_YUY2</strong>, <strong>YUV2GRAY_Y422</strong>,
<strong>YUV2GRAY_UYNV</strong>, <strong>YUV2GRAY_YVYU</strong>, <strong>YUV2GRAY_YUYV</strong>,
<strong>YUV2GRAY_YUNV</strong>: YUV 4:2:2 family to RGB</li>
<li><strong>RGBA2mRGBA</strong>, <strong>mRGBA2RGBA</strong>: alpha premultiplication</li>
<li><strong>RGB2YUV_I420</strong>, <strong>BGR2YUV_I420</strong>, <strong>RGB2YUV_IYUV</strong>, <strong>BGR2YUV_IYUV</strong>,
<strong>RGBA2YUV_I420</strong>, <strong>BGRA2YUV_I420</strong>, <strong>RGBA2YUV_IYUV</strong>,
<strong>BGRA2YUV_IYUV</strong>, <strong>RGB2YUV_YV12</strong>, <strong>BGR2YUV_YV12</strong>, <strong>RGBA2YUV_YV12</strong>,
<strong>BGRA2YUV_YV12</strong>: RGB to YUV 4:2:0 family</li>
<li><strong>BayerBG2BGR</strong>, <strong>BayerGB2BGR</strong>, <strong>BayerRG2BGR</strong>, <strong>BayerGR2BGR</strong>,
<strong>BayerBG2RGB</strong>, <strong>BayerGB2RGB</strong>, <strong>BayerRG2RGB</strong>, <strong>BayerGR2RGB</strong>,
<strong>BayerBG2GRAY</strong>, <strong>BayerGB2GRAY</strong>, <strong>BayerRG2GRAY</strong>, <strong>BayerGR2GRAY</strong>,
<strong>BayerBG2BGRA</strong>, <strong>BayerGB2BGRA</strong>, <strong>BayerRG2BGRA</strong>, <strong>BayerGR2BGRA</strong>,
<strong>BayerBG2RGBA</strong>, <strong>BayerGB2RGBA</strong>, <strong>BayerRG2RGBA</strong>, <strong>BayerGR2RGBA</strong>:
Demosaicing</li>
<li><strong>BayerBG2BGR_VNG</strong>, <strong>BayerGB2BGR_VNG</strong>, <strong>BayerRG2BGR_VNG</strong>,
<strong>BayerGR2BGR_VNG</strong>, <strong>BayerBG2RGB_VNG</strong>, <strong>BayerGB2RGB_VNG</strong>,
<strong>BayerRG2RGB_VNG</strong>, <strong>BayerGR2RGB_VNG</strong>: Demosaicing using Variable
Number of Gradients</li>
<li><strong>BayerBG2BGR_EA</strong>, <strong>BayerGB2BGR_EA</strong>, <strong>BayerRG2BGR_EA</strong>,
<strong>BayerGR2BGR_EA</strong>, <strong>BayerBG2RGB_EA</strong>, <strong>BayerGB2RGB_EA</strong>,
<strong>BayerRG2RGB_EA</strong>, <strong>BayerGR2RGB_EA</strong>: Edge-Aware Demosaicing</li>
</ul>
</li>
</ul>
<h2>Output</h2>
<ul>
<li><strong>dst</strong> Output image of the same row/column size and depth as <code>src</code>.</li>
</ul>
<h2>Options</h2>
<ul>
<li><strong>DstCn</strong> Number of channels in the destination image. If the parameter is
0, the number of the channels is derived automatically from <code>src</code> and
<code>code</code>.</li>
</ul>
<p>The function converts an input image from one color space to another. In case
of a transformation to-from RGB color space, the order of the channels should
be specified explicitly (RGB or BGR). Note that the default color format in
OpenCV is often referred to as RGB but it is actually BGR (the bytes are
reversed). So the first byte in a standard (24-bit) color image will be an
8-bit Blue component, the second byte will be Green, and the third byte will
be Red. The fourth, fifth, and sixth bytes would then be the second pixel
(Blue, then Green, then Red), and so on.</p>
<p>The conventional ranges for R, G, and B channel values are:</p>
<ul>
<li>0 to 255 for <code>uint8</code> images</li>
<li>0 to 65535 for <code>uint16</code> images</li>
<li>0 to 1 for floating-point images (<code>single</code> and <code>double</code>)</li>
</ul>
<p>In case of linear transformations, the range does not matter. But in case of
a non-linear transformation, an input RGB image should be normalized to the
proper value range to get the correct results, for example, for <code>RGB</code> to
<code>L*u*v*</code> transformation. For example, if you have a 32-bit floating-point
image directly converted from an 8-bit image without any scaling, then it
will have the 0..255 value range instead of 0..1 assumed by the function.
So, before calling <a href="cv.cvtColor.html">cv.cvtColor</a>, you need first to scale the image down:</p>
<pre class=" prettyprint lang-matlab"><code>img = cvtColor(img./255, 'BGR2Luv');
</code></pre>
<p>If you use <a href="cv.cvtColor.html">cv.cvtColor</a> with 8-bit images, the conversion will have some
information lost. For many applications, this will not be noticeable but it
is recommended to use 32-bit images in applications that need the full range
of colors or that convert an image before an operation and then convert
back.</p>
<p>If conversion adds the alpha channel, its value will set to the maximum of
corresponding channel range: 255 for <code>uint8</code>, 65535 for <code>uint16</code>, and 1 for
<code>single</code>.</p>
<h1>Color Conversions</h1>
<h2>RGB ⇔ GRAY</h2>
<p>Transformations within RGB space like adding/removing the alpha channel,
reversing the channel order, conversion to/from 16-bit RGB color (<code>R5:G6:B5</code>
or <code>R5:G5:B5</code>), as well as conversion to/from grayscale using:</p>
<pre class=" prettyprint lang-matlab"><code>RGB[A] to Gray: Y = 0.299*R + 0.587*G + 0.114*B
</code></pre>
<p>and</p>
<pre class=" prettyprint lang-matlab"><code>Gray to RGB[A]: R = Y, G = Y, B = Y, A = max(ChannelRange)
</code></pre>
<p>The conversion from a RGB image to gray is done with:</p>
<pre class=" prettyprint lang-matlab"><code>bwsrc = <a href="cv.cvtColor.html">cv.cvtColor</a>(src, 'RGB2GRAY');
</code></pre>
<p>More advanced channel reordering can also be done with <a href="cv.mixChannels.html">cv.mixChannels</a>.</p>
<p>See also: 'BGR2GRAY', 'RGB2GRAY', 'GRAY2BGR', 'GRAY2RGB'</p>
<h2>RGB ⇔ CIE XYZ.Rec 709 with D65 white point</h2>
<pre class=" prettyprint lang-matlab"><code>[X;Y;Z] = [0.412453, 0.357580, 0.180423;
           0.212671, 0.715160, 0.072169;
           0.019334, 0.119193, 0.950227] * [R;G;B]

[R;G;B] = [3.240479, -1.53715, -0.498535;
          -0.969256,  1.875991, 0.041556;
           0.055648, -0.204043, 1.057311] * [X;Y;Z]
</code></pre>
<p><code>X</code>, <code>Y</code>, and <code>Z</code> cover the whole value range (in case of floating-point
images, <code>Z</code> may exceed 1).</p>
<p>See also: 'BGR2XYZ', 'RGB2XYZ', 'XYZ2BGR', 'XYZ2RGB'</p>
<h2>RGB ⇔ YCrCb JPEG (or YCC)</h2>
<pre class=" prettyprint lang-matlab"><code>Y = 0.299*R + 0.587*G + 0.114*B
Cb = (R-Y)*0.713 + delta
Cr = (B-Y)*0.564 + delta
R = Y + 1.403*(Cr-delta)
G = Y - 0.714*(Cr-delta) - 0.344*(Cb-delta)
B = Y + 1.773*(Cb-delta)
</code></pre>
<p>where</p>
<pre class=" prettyprint lang-matlab"><code>        / 128    for 8-bit images
delta = | 32768  for 16-bit images
        \ 0.5    for floating-point images
</code></pre>
<p><code>Y</code>, <code>Cr</code>, and <code>Cb</code> cover the whole value range.</p>
<p>See also: 'BGR2YCrCb', 'RGB2YCrCb', 'YCrCb2BGR', 'YCrCb2RGB'</p>
<h2>RGB ⇔ HSV</h2>
<p>In case of 8-bit and 16-bit images, <code>R</code>, <code>G</code>, and <code>B</code> are converted to the
floating-point format and scaled to fit the 0 to 1 range.</p>
<pre class=" prettyprint lang-matlab"><code>V = max(R,G,B)
S = / (V - min(R,G,B)) / V               if V != 0
    \ 0                                  otherwise
    / 60*(G-B) / (V - min(R,G,B))        if V=R
H = | 120 + 60*(B-R) / (V - min(R,G,B))  if V=G
    \ 240 + 60*(R-G) / (V - min(R,G,B))  if V=B
</code></pre>
<p>If <code>H&lt;0</code> then <code>H=H+360</code>. On output <code>0&lt;=V&lt;=1</code>, <code>0&lt;=S&lt;=1</code>, <code>0&lt;=H&lt;=360</code>.</p>
<p>The values are then converted to the destination data type:</p>
<ul>
<li>8-bit images: <code>V=255*V</code>, <code>S=255*S</code>, <code>H=H/2</code> (to fit to 0 to 255)</li>
<li>16-bit images: (currently not supported) <code>V=65535*V</code>, <code>S=65535*S</code>, <code>H=H</code></li>
<li>32-bit images: <code>H</code>, <code>S</code>, and <code>V</code> are left as is</li>
</ul>
<p>See also: 'BGR2HSV', 'RGB2HSV', 'HSV2BGR', 'HSV2RGB'</p>
<h2>RGB ⇔ HLS</h2>
<p>In case of 8-bit and 16-bit images, <code>R</code>, <code>G</code>, and <code>B</code> are converted to the
floating-point format and scaled to fit the 0 to 1 range.</p>
<pre class=" prettyprint lang-matlab"><code>Vmax = max(R,G,B)
Vmin = min(R,G,B)
L = (Vmax + Vmin)/2
S = / (Vmax - Vmin)/(Vmax + Vmin)      if L &lt;  0.5
    \ (Vmax - Vmin)/(2-(Vmax + Vmin))  if L &gt;= 0.5
    / 60*(G-B) / (Vmax - Vmin)         if Vmax=R
H = | 120 + 60*(B-R) / (Vmax - Vmin)   if Vmax=G
    \ 240 + 60*(R-G) / (Vmax - Vmin)   if Vmax=B
</code></pre>
<p>If <code>H&lt;0</code> then <code>H=H+360</code>. On output <code>0&lt;=L&lt;=1</code>, <code>0&lt;=S&lt;=1</code>, <code>0&lt;=H&lt;=360</code>.</p>
<p>The values are then converted to the destination data type:</p>
<ul>
<li>8-bit images: <code>L=255*L</code>, <code>S=255*S</code>, <code>H=H/2</code> (to fit to 0 to 255)</li>
<li>16-bit images: (currently not supported) <code>L=65535*L</code>, <code>S=65535*S</code>, <code>H=H</code></li>
<li>32-bit images: <code>H</code>, <code>S</code>, and <code>L</code> are left as is</li>
</ul>
<p>See also: 'BGR2HLS', 'RGB2HLS', 'HLS2BGR', 'HLS2RGB'</p>
<h2>RGB ⇔ CIE L<em>a</em>b*</h2>
<p>In case of 8-bit and 16-bit images, <code>R</code>, <code>G</code>, and <code>B</code> are converted to the
floating-point format and scaled to fit the 0 to 1 range.</p>
<pre class=" prettyprint lang-matlab"><code>[X;Y;Z] = [0.412453, 0.357580, 0.180423;
           0.212671, 0.715160, 0.072169;
           0.019334, 0.119193, 0.950227] * [R;G;B]

X = X/Xn, where Xn = 0.950456
Z = Z/Zn, where Zn = 1.088754

L = / 116 * Y^(1/3) - 16   for Y &gt;  0.008856
    \ 903.3 * Y            for Y &lt;= 0.008856

a = 500*(f(X) - f(Y)) + delta
b = 200*(f(Y) - f(Z)) + delta
</code></pre>
<p>where</p>
<pre class=" prettyprint lang-matlab"><code>f(t) = / t^(1/3)           for t &lt;  0.008856
       \ 7.787*t + 16/116  for t &gt;= 0.008856
</code></pre>
<p>and</p>
<pre class=" prettyprint lang-matlab"><code>delta = / 128  for 8-bit images
        \ 0    for floating-point images
</code></pre>
<p>This outputs <code>0&lt;=L&lt;=100</code>, <code>-127&lt;=a&lt;=127</code>, <code>-127&lt;=b&lt;=127</code>. The values are
then converted to the destination data type:</p>
<ul>
<li>8-bit images: <code>L=L*255/100</code>, <code>a=a+128</code>, <code>b=b+128</code></li>
<li>16-bit images: (currently not supported)</li>
<li>32-bit images: <code>L</code>, <code>a</code>, and <code>b</code> are left as is</li>
</ul>
<p>See also: 'BGR2Lab', 'RGB2Lab', 'Lab2BGR', 'Lab2RGB'</p>
<h2>RGB ⇔ CIE L<em>u</em>v*</h2>
<p>In case of 8-bit and 16-bit images, <code>R</code>, <code>G</code>, and <code>B</code> are converted to the
floating-point format and scaled to fit 0 to 1 range.</p>
<pre class=" prettyprint lang-matlab"><code>[X;Y;Z] = [0.412453, 0.357580, 0.180423;
           0.212671, 0.715160, 0.072169;
           0.019334, 0.119193, 0.950227] * [R;G;B]

L = / 116 * Y^(1/3) - 16   for Y &gt;  0.008856
    \ 903.3 * Y            for Y &lt;= 0.008856

u' = 4*X/(X + 15*Y + 32*Z)
v' = 9*Y/(X + 15*Y + 32*Z)

u = 13*L*(u' - un), where un = 0.19793943
v = 13*L*(v' - vn), where vn = 0.46831096
</code></pre>
<p>This outputs <code>0&lt;=L&lt;=100</code>, <code>-134&lt;=u&lt;=220</code>, <code>-140&lt;=v&lt;=122</code>.</p>
<p>The values are then converted to the destination data type:</p>
<ul>
<li>8-bit images: <code>L=255/100*L</code>, <code>u=255/354*(u+134),</code>v=255/262*(v+140)`</li>
<li>16-bit images: (currently not supported)</li>
<li>32-bit images: <code>L</code>, <code>u</code>, and <code>v</code> are left as is</li>
</ul>
<p>Note that when converting integer Luv images to RGB the intermediate
<code>X</code>, <code>Y</code> and <code>Z</code> values are truncated to [0,2] range to fit white point
limitations. It may lead to incorrect representation of colors with odd XYZ
values.</p>
<p>The above formulae for converting RGB to/from various color spaces have been
taken from multiple sources on the web, primarily from the
<a href="http://www.poynton.com/ColorFAQ.html" target="_blank">Charles Poynton site</a>.</p>
<p>See also: 'BGR2Luv', 'RGB2Luv', 'Luv2BGR', 'Luv2RGB'</p>
<h2>Bayer ⇔ RGB</h2>
<p>The Bayer pattern is widely used in CCD and CMOS cameras. It enables you to
get color pictures from a single plane where <code>R</code>, <code>G</code>, and <code>B</code> pixels
(sensors of a particular component) are interleaved as follows:</p>
<pre class=" prettyprint lang-matlab"><code>R   G   R   G   R
G  (B) (G)  B   G
R   G   R   G   R
G   B   G   B   G
R   G   R   G   R
</code></pre>
<p>The output RGB components of a pixel are interpolated from 1, 2, or 4
neighbors of the pixel having the same color. There are several
modifications of the above pattern that can be achieved by shifting the
pattern one pixel left and/or one pixel up. The two letters <code>C1</code> and <code>C2</code> in
the conversion constants <code>Bayer(C1)(C2)2BGR</code> and <code>Bayer(C1)(C2)2RGB</code>
indicate the particular pattern type. These are components from the second
row, second and third columns, respectively. For example, the above pattern
has a very popular &quot;BG&quot; type.</p>
<p>See also: 'BayerBG2BGR', 'BayerGB2BGR', 'BayerRG2BGR', 'BayerGR2BGR',
'BayerBG2RGB', 'BayerGB2RGB', 'BayerRG2RGB', 'BayerGR2RGB'</p>
</div><!--after help --><!--seeAlso--><div class="footerlinktitle">See also</div><div class="footerlink"> <a href="https://www.mathworks.com/help/matlab/ref/rgb2gray.html" target="_blank">rgb2gray</a>, <a href="https://www.mathworks.com/help/matlab/ref/rgb2hsv.html" target="_blank">rgb2hsv</a>, <a href="https://www.mathworks.com/help/images/ref/rgb2lab.html" target="_blank">rgb2lab</a>, <a href="https://www.mathworks.com/help/images/ref/rgb2ntsc.html" target="_blank">rgb2ntsc</a>, <a href="https://www.mathworks.com/help/images/ref/rgb2xyz.html" target="_blank">rgb2xyz</a>, <a href="https://www.mathworks.com/help/images/ref/rgb2ycbcr.html" target="_blank">rgb2ycbcr</a>,
   <a href="https://www.mathworks.com/help/matlab/ref/hsv2rgb.html" target="_blank">hsv2rgb</a>, <a href="https://www.mathworks.com/help/images/ref/lab2rgb.html" target="_blank">lab2rgb</a>, <a href="https://www.mathworks.com/help/images/ref/lab2xyz.html" target="_blank">lab2xyz</a>, <a href="https://www.mathworks.com/help/images/ref/xyz2lab.html" target="_blank">xyz2lab</a>, <a href="https://www.mathworks.com/help/images/ref/xyz2rgb.html" target="_blank">xyz2rgb</a>, <a href="https://www.mathworks.com/help/images/ref/ycbcr2rgb.html" target="_blank">ycbcr2rgb</a>, <a href="https://www.mathworks.com/help/images/ref/ntsc2rgb.html" target="_blank">ntsc2rgb</a>,
   <a href="https://www.mathworks.com/help/images/ref/makecform.html" target="_blank">makecform</a>, <a href="https://www.mathworks.com/help/images/ref/applycform.html" target="_blank">applycform</a>, <a href="cv.demosaicing.html">cv.demosaicing</a>, <a href="https://www.mathworks.com/help/images/ref/imapplymatrix.html" target="_blank">imapplymatrix</a></div>
   
<script type="text/javascript" src="prettify.js"></script>
<script type="text/javascript" src="lang-matlab.min.js"></script>
</body></html>