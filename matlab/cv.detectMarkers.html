<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
   
      <link rel="stylesheet" href="helpwin.css" />
      <title>cv.detectMarkers - mexopencv</title>
   <link rel="stylesheet" type="text/css" href="helpwin_custom.css" />
<meta name="generator" content="MATLAB 9.4.0.902940 (R2018a) Update 4" />
<meta name="description" content="cv.detectMarkers - Basic ArUco marker detection" />
<link rel="stylesheet" type="text/css" href="matlab.min.css" />
</head>
   <body onload="PR.prettyPrint();">
      <!--Single-page help-->
      <table border="0" cellspacing="0" width="100%">
         <tbody><tr class="subheader">
            <td class="headertitle">cv.detectMarkers - MATLAB File Help</td>
            <td class="subheader-right"></td>
         </tr>
      </tbody></table>
      <div class="title">cv.detectMarkers</div>
      <div class="helpcontent"><p class=" h1line">Basic ArUco marker detection</p>
<pre class=" prettyprint lang-matlab"><code>[corners, ids] = <a href="cv.detectMarkers.html">cv.detectMarkers</a>(img, dictionary)
[corners, ids, rejectedImgPoints] = <a href="cv.detectMarkers.html">cv.detectMarkers</a>(img, dictionary)
[...] = <a href="cv.detectMarkers.html">cv.detectMarkers</a>(..., 'OptionName',optionValue, ...)
</code></pre>
<h2>Input</h2>
<ul>
<li><strong>img</strong> input image (8-bit grayscale or color).</li>
<li><strong>dictionary</strong> indicates the type of markers that will be searched. You
can specify the dictionary as a cell-array that starts with the type name
followed by option arguments <code>{Type, ...}</code>. There are three types of
dictionaries available:
<ul>
<li><strong>Predefined</strong> <code>{'Predefined', name}</code> or simply as a string <code>name</code>.
Returns one of the predefined dictionaries.</li>
<li><strong>Custom</strong> <code>{'Custom', nMarkers, markerSize, 'BaseDictionary',baseDict}</code>.
Generates a new customizable marker dictionary. This creates a new
dictionary composed by <code>nMarkers</code> markers and each markers composed by
<code>markerSize*markerSize</code> bits. If <code>BaseDictionary</code> is provided, its
markers are directly included and the rest are generated based on them.
If the size of <code>baseDict</code> is higher than <code>nMarkers</code>, only the first
<code>nMarkers</code> in <code>baseDict</code> are taken and no new marker is added.</li>
<li><strong>Manual</strong> <code>{'Manual', bytesList, markerSize, maxCorrectionBits}</code>.
Creates a dictionary/set of markers manually. It contains the inner
codification.</li>
</ul>
</li>
</ul>
<h2>Output</h2>
<ul>
<li><strong>corners</strong> cell array of detected marker corners. For each marker, its
four corners are provided <code>{{[x1,y1],[x2,y2],[x3,y3],[x4,y4]}, ..}</code>. The
order of the corners is clockwise.</li>
<li><strong>ids</strong> vector of identifiers of the detected markers. The identifier is
of integer type (0-based). For N detected markers, the size of ids is also
N. The identifiers have the same order than the markers in the <code>corners</code>
array.</li>
<li><strong>rejectedImgPoints</strong> contains the <code>corners</code> of those squares whose inner
code has not a correct codification. Useful for debugging purposes.</li>
</ul>
<h2>Options</h2>
<ul>
<li><strong>DetectorParameters</strong> marker detection parameters. A struct of parameters
for the detection process, with the following fields:
<ul>
<li><strong>adaptiveThreshWinSizeMin</strong> minimum window size for adaptive
thresholding before finding contours (default 3).</li>
<li><strong>adaptiveThreshWinSizeMax</strong> maximum window size for adaptive
thresholding before finding contours (default 23).</li>
<li><strong>adaptiveThreshWinSizeStep</strong> increments from <code>AdaptiveThreshWinSizeMin</code>
to <code>AdaptiveThreshWinSizeMax</code> during the thresholding (default 10).</li>
<li><strong>adaptiveThreshConstant</strong> constant for adaptive thresholding before
finding contours (default 7)</li>
<li><strong>minMarkerPerimeterRate</strong> determine minimum perimeter for marker
contour to be detected. This is defined as a rate respect to the maximum
dimension of the input image (default 0.03).</li>
<li><strong>maxMarkerPerimeterRate</strong> determine maximum perimeter for marker
contour to be detected. This is defined as a rate respect to the maximum
dimension of the input image (default 4.0).</li>
<li><strong>polygonalApproxAccuracyRate</strong> minimum accuracy during the polygonal
approximation process to determine which contours are squares
(default 0.03).</li>
<li><strong>minCornerDistanceRate</strong> minimum distance between corners for detected
markers relative to its perimeter (default 0.05)</li>
<li><strong>minDistanceToBorder</strong> minimum distance of any corner to the image
border for detected markers (in pixels) (default 3)</li>
<li><strong>minMarkerDistanceRate</strong> minimum mean distance beetween two marker
corners to be considered similar, so that the smaller one is removed.
The rate is relative to the smaller perimeter of the two markers
(default 0.05).</li>
<li><strong>cornerRefinementMethod</strong> corner refinement method, one of:
<ul>
<li><strong>None</strong> (default) no refinement.</li>
<li><strong>Subpix</strong> do subpixel refinement (<a href="cv.cornerSubPix.html">cv.cornerSubPix</a>).</li>
<li><strong>Contour</strong> refine the corners using the contour-points.</li>
</ul>
</li>
<li><strong>cornerRefinementWinSize</strong> window size for the corner refinement
process (in pixels) (default 5).</li>
<li><strong>cornerRefinementMaxIterations</strong> maximum number of iterations for stop
criteria of the corner refinement process (default 30).</li>
<li><strong>cornerRefinementMinAccuracy</strong> minimum error for the stop cristeria of
the corner refinement process (default 0.1)</li>
<li><strong>markerBorderBits</strong> number of bits of the marker border, i.e. marker
border width (default 1).</li>
<li><strong>perpectiveRemovePixelPerCell</strong> number of bits (per dimension) for each
cell of the marker when removing the perspective (default 4).</li>
<li><strong>perspectiveRemoveIgnoredMarginPerCell</strong> width of the margin of pixels
on each cell not considered for the determination of the cell bit.
Represents the rate respect to the total size of the cell, i.e.
<code>PerpectiveRemovePixelPerCell</code> (default 0.13)</li>
<li><strong>maxErroneousBitsInBorderRate</strong> maximum number of accepted erroneous
bits in the border (i.e. number of allowed white bits in the border).
Represented as a rate respect to the total number of bits per marker
(default 0.35).</li>
<li><strong>minOtsuStdDev</strong> minimun standard deviation in pixels values during the
decodification step to apply Otsu thresholding (otherwise, all the bits
are set to 0 or 1 depending on mean higher than 128 or not) (default 5.0)</li>
<li><strong>errorCorrectionRate</strong> error correction rate respect to the maximum
error correction capability for each dictionary. (default 0.6).</li>
</ul>
</li>
<li><strong>CameraMatrix</strong> Optional 3x3 camera calibration matrix
<code>A = [fx 0 cx; 0 fy cy; 0 0 1]</code>.</li>
<li><strong>DistCoeffs</strong> Optional vector of camera distortion coefficients
<code>[k1,k2,p1,p2,k3,k4,k5,k6,s1,s2,s3,s4]</code> of 4, 5, 8 or 12 elements.</li>
</ul>
<h2>Inputs for Predefined Dictionary</h2>
<ul>
<li><strong>name</strong> name of predefined markers dictionaries/sets. Each dictionary
indicates the number of bits and the number of markers contained:
<ul>
<li><code>4x4_50</code>, <code>4x4_100</code>, <code>4x4_250</code>, <code>4x4_1000</code>: 4x4 bits with
(50|100|250|1000) markers.</li>
<li><code>5x5_50</code>, <code>5x5_100</code>, <code>5x5_250</code>, <code>5x5_1000</code>: 5x5 bits with
(50|100|250|1000) markers.</li>
<li><code>6x6_50</code>, <code>6x6_100</code>, <code>6x6_250</code>, <code>6x6_1000</code>: 6x6 bits with
(50|100|250|1000) markers.</li>
<li><code>7x7_50</code>, <code>7x7_100</code>, <code>7x7_250</code>, <code>7x7_1000</code>: 7x7 bits with
(50|100|250|1000) markers.</li>
<li><code>ArucoOriginal</code>: standard ArUco Library Markers. 1024 markers, 5x5 bits,
0 minimum distance.</li>
</ul>
</li>
</ul>
<h2>Inputs for Custom Dictionary</h2>
<ul>
<li><strong>nMarkers</strong> number of markers in the dictionary.</li>
<li><strong>markerSize</strong> number of bits per dimension of each markers.</li>
<li><strong>baseDict</strong> (Optional) include the markers in this dictionary at the
beginning. It is specified in the same format as the parent dictionary
(i.e. a cell-array <code>{Type, ...}</code>).</li>
</ul>
<h2>Inputs for Manual Dictionary</h2>
<ul>
<li><strong>bytesList</strong> marker code information. Note that the <code>bytesList</code> is given
in the form of a matrix of bits which is then converted to list of bytes
in the 4 rotations using <code>Dictionary::getByteListFromBits</code>. It contains
the marker codewords where:
<ul>
<li>the number of rows is the dictionary size</li>
<li>each marker is encoded using <code>nbytes = ceil(markerSize*markerSize/8)</code></li>
<li>each row contains all 4 rotations of the marker, so its length is
<code>4*nbytes</code></li>
<li><code>bytesList(i,k*nbytes+j)</code> is then the j-th byte of i-th marker, in its
k-th rotation.</li>
</ul>
</li>
<li><strong>markerSize</strong> number of bits per dimension.</li>
<li><strong>maxCorrectionBits</strong> maximum number of bits that can be corrected.</li>
</ul>
<p>The <a href="cv.detectMarkers.html">cv.detectMarkers</a> function performs marker detection in the input image.
Only markers included in the specific dictionary are searched. For each
detected marker, it returns the 2D position of its corner in the image and
its corresponding identifier. Note that this function does not perform pose
estimation.</p>
<h1>ArUco Marker Detection</h1>
<p>This module is dedicated to square fiducial markers (also known as Augmented
Reality Markers). These markers are useful for easy, fast and robust camera
pose estimation.</p>
<p>The main functionalities are:</p>
<ul>
<li>Detection of markers in a image</li>
<li>Pose estimation from a single marker or from a board/set of markers</li>
<li>Detection of ChArUco board for high subpixel accuracy</li>
<li>Camera calibration from both, ArUco boards and ChArUco boards.</li>
<li>Detection of ChArUco diamond markers</li>
</ul>
<p>The implementation is based on the ArUco Library [2] by [1].</p>
<p>This module has been originally developed by Sergio Garrido-Jurado as a
project for Google Summer of Code 2015 (GSoC 15).</p>
<h3>ArUco</h3>
<p>ArUco markers are easy to detect pattern grids that yield up to 1024
different patterns. They were built for augmented reality and later used for
camera calibration. Since the grid uniquely orients the square, the
detection algorithm can determing the pose of the grid.</p>
<h3>ChArUco</h3>
<p>ArUco markers were improved by interspersing them inside a checkerboard
called ChArUco. Checkerboard corner intersectionsa provide more stable
corners because the edge location bias on one square is countered by the
opposite edge orientation in the connecting square. By interspersing ArUco
markers inside the checkerboard, each checkerboard corner gets a label which
enables it to be used in complex calibration or pose scenarios where you
cannot see all the corners of the checkerboard.</p>
<p>The smallest ChArUco board is 5 checkers and 4 markers called a
&quot;Diamond Marker&quot;.</p>
<h2>References</h2>
<p>[1]:</p>
<blockquote>
<p>S. Garrido-Jurado, R. Munoz-Salinas, F. J. Madrid-Cuevas, and
M. J. Marin-Jimenez. 2014. &quot;Automatic generation and detection of highly
reliable fiducial markers under occlusion&quot;. Pattern Recogn. 47, 6
(June 2014), 2280-2292. DOI=10.1016/j.patcog.2014.01.005</p>
</blockquote>
<p>[2]:</p>
<blockquote>
<p>ArUco: a minimal library for Augmented Reality applications
based on OpenCV, <a href="http://www.uco.es/investiga/grupos/ava/node/26" target="_blank">ArUco</a></p>
</blockquote>
</div><!--after help --><!--seeAlso--><div class="footerlinktitle">See also</div><div class="footerlink"> <a href="cv.estimatePoseSingleMarkers.html">cv.estimatePoseSingleMarkers</a>, <a href="cv.estimatePoseBoard.html">cv.estimatePoseBoard</a>,
   <a href="cv.refineDetectedMarkers.html">cv.refineDetectedMarkers</a>, <a href="cv.drawDetectedMarkers.html">cv.drawDetectedMarkers</a>, <a href="cv.adaptiveThreshold.html">cv.adaptiveThreshold</a>,
   <a href="cv.threshold.html">cv.threshold</a>, <a href="cv.findContours.html">cv.findContours</a>, <a href="cv.cornerSubPix.html">cv.cornerSubPix</a></div>
   
<script type="text/javascript" src="prettify.js"></script>
<script type="text/javascript" src="lang-matlab.min.js"></script>
</body></html>